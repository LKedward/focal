var tipuesearch = {"pages":[{"title":" Focal API Reference ","text":"Focal API Reference Developer Info L. Kedward","tags":"home","loc":"index.html"},{"title":"fclDevice – Focal API Reference ","text":"type, public :: fclDevice Type wrapper for openCL device objects Contents Variables cl_device_type name nComputeUnits global_memory clock_freq version extensions platform platformName platformVendor Components Type Visibility Attributes Name Initial integer(kind=c_int64_t), public :: cl_device_type Device type character(len=:), public, allocatable :: name Device name integer(kind=c_int32_t), public :: nComputeUnits Number of device compute units integer(kind=c_int64_t), public :: global_memory Total global memory, bytes integer(kind=c_int32_t), public :: clock_freq Max clock frequency, MHz character(len=:), public, allocatable :: version OpenCL version character(len=:), public, allocatable :: extensions Supported OpenCL extensions type( fclPlatform ), public, pointer :: platform Pointer to containing platform character(len=:), public, allocatable :: platformName Name of containing platform character(len=:), public, allocatable :: platformVendor Vendor of containing platform","tags":"","loc":"type/fcldevice.html"},{"title":"fclPlatform – Focal API Reference ","text":"type, public :: fclPlatform Type wrapper for openCL platform objects Contents Variables profile version name vendor extensions numDevice devices Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profile OpenCL Profile string character(len=:), public, allocatable :: version OpenCL Version character(len=:), public, allocatable :: name Platform name character(len=:), public, allocatable :: vendor Platform vendor character(len=:), public, allocatable :: extensions Platform extensions integer, public :: numDevice No. of devices type( fclDevice ), public, allocatable :: devices (:) Focal device objects","tags":"","loc":"type/fclplatform.html"},{"title":"fclContext – Focal API Reference ","text":"type, public :: fclContext Type wrapper for openCL context objects Contents Variables cl_context platform Components Type Visibility Attributes Name Initial integer(kind=c_intptr_t), public :: cl_context = -1 openCL context pointer type( fclPlatform ), public :: platform Focal platform object","tags":"","loc":"type/fclcontext.html"},{"title":"fclEvent – Focal API Reference ","text":"type, public :: fclEvent Type wrapper for OpenCL event pointers Contents Variables cl_event Finalization Procedures fclReleaseEvent Components Type Visibility Attributes Name Initial integer(kind=c_intptr_t), public :: cl_event = -1 OpenCL event pointer Finalization Procedures final :: fclReleaseEvent Decrement cl reference counter public  interface fclReleaseEvent () Arguments None","tags":"","loc":"type/fclevent.html"},{"title":"fclCommandQ – Focal API Reference ","text":"type, public :: fclCommandQ Type wrapper for openCL command queue objects Contents Variables blockingWrite blockingRead lastWriteEvent lastReadEvent lastCopyEvent lastKernelEvent lastBarrierEvent dependencyList dependencyListPtr nDependency holdDependencies Components Type Visibility Attributes Name Initial logical, public :: blockingWrite = .true. Enable/disable blocking writes when copying from host to device logical, public :: blockingRead = .true. Enable/disable block reads when copying from device to host type( fclEvent ), public :: lastWriteEvent Focal event object for the most recent write event (host-to-device) to be enqueued type( fclEvent ), public :: lastReadEvent Focal event object for the most recent read event (device-to-host) to be enqueued type( fclEvent ), public :: lastCopyEvent Focal event object for the most recent copy event (device-to-device) to be enqueued type( fclEvent ), public :: lastKernelEvent Focal event object for the most recent kernel event to be enqueued type( fclEvent ), public :: lastBarrierEvent Focal event object for the most recent barrier event to be enqueued integer(kind=c_intptr_t), public, allocatable :: dependencyList (:) List of pre-requisite events for next enqueued action.\n All events in this list are used as dependencies for the next enqueued\n  operation. At enqueueing, the list is cleared unless holdDependencies is .true. type(c_ptr), public :: dependencyListPtr = C_NULL_PTR C pointer to dependency list. C_NULL_PTR when nDependency is zero. integer, public :: nDependency = 0 Number of items in dependency list logical, public :: holdDependencies = .false. Set to true to not automatically clear dependencies after enqueueing.\nUse for applying the same dependencies to multiple commands.\nUse fclClearDependencies to clear and reset.","tags":"","loc":"type/fclcommandq.html"},{"title":"fclCommandQPool – Focal API Reference ","text":"type, public :: fclCommandQPool Collection of fclCommandQ objects with round-robin scheduling.\n Allows easy handling of multiple command queues for parallel kernels\n data transfers. Contents Variables length queues idx Type-Bound Procedures next current Components Type Visibility Attributes Name Initial integer, public :: length Number of command queues type( fclCommandQ ), public, allocatable :: queues (:) Array of command queues integer, public :: idx = 1 Index of current command queue Type-Bound Procedures procedure, public, pass :: next => fclCommandQPool_Next Returns next scheduled queue in queue pool interface public module function fclCommandQPool_Next(qPool) result(cmdQ) Returns next scheduled queue in queue pool Arguments Type Intent Optional Attributes Name class( fclCommandQPool ), intent(inout), target :: qPool Return Value type( fclCommandQ ), pointer procedure, public, pass :: current => fclCommandQPool_Current Returns current scheduled queue in queue pool interface public module function fclCommandQPool_Current(qPool) result(cmdQ) Returns current scheduled queue in queue pool Arguments Type Intent Optional Attributes Name class( fclCommandQPool ), intent(in), target :: qPool Return Value type( fclCommandQ ), pointer","tags":"","loc":"type/fclcommandqpool.html"},{"title":"fclProgram – Focal API Reference ","text":"type, public :: fclProgram Type wrapper for openCL program objects Contents None","tags":"","loc":"type/fclprogram.html"},{"title":"fclKernelPointer – Focal API Reference ","text":"type, public :: fclKernelPointer Wrapper type for implementing an array of pointers to kernel objects Contents None","tags":"","loc":"type/fclkernelpointer.html"},{"title":"fclBufferPointer – Focal API Reference ","text":"type, public :: fclBufferPointer Wrapper type for implementing an array of pointers to buffer objects Contents None","tags":"","loc":"type/fclbufferpointer.html"},{"title":"fclProfiler – Focal API Reference ","text":"type, public :: fclProfiler Helper type to collect objects (kernels and buffers) that\n are profiled to simply user code. Contents Variables device Type-Bound Procedures add Components Type Visibility Attributes Name Initial type( fclDevice ), public :: device Device for which to dump profile data Type-Bound Procedures procedure, public, pass :: add => fclProfilerAdd interface public module subroutine fclProfilerAdd(profiler, profileSize, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9) Enable profiling for multiple container (kernel/buffer) and add to profiler collection Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(inout) :: profiler Profiler - collection of objects to profile integer, intent(in) :: profileSize Number of events to save for profiling (allocation size) class( fclProfileContainer ), intent(inout), target :: c0 Object (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c1 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c2 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c3 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c4 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c5 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c6 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c7 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c8 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c9 Subsequent objects (kernel/buffer) for which to enable profiling","tags":"","loc":"type/fclprofiler.html"},{"title":"fclProfileContainer – Focal API Reference ","text":"type, public :: fclProfileContainer Base container type for event profiling Contents Variables profileName profilingEnabled profileEvents profileSize nProfileEvent profileEventType Type-Bound Procedures pushProfileEvent Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event Type-Bound Procedures procedure, public, pass :: pushProfileEvent => fclPushProfileEvent interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type","tags":"","loc":"type/fclprofilecontainer.html"},{"title":"fclKernel – Focal API Reference ","text":"type, public, extends( fclProfileContainer ) :: fclKernel Type wrapper for openCL kernel objects Contents Variables profileName profilingEnabled profileEvents profileSize nProfileEvent profileEventType name work_dim global_work_offset global_work_size local_work_size Finalization Procedures fclReleaseKernel Type-Bound Procedures pushProfileEvent setArgs launch launchAfter Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event character(len=:), public, allocatable :: name Kernel name integer(kind=c_int32_t), public :: work_dim = 1 Number of work-range dimensions integer(kind=c_size_t), public :: global_work_offset (3) = 0 Global work dimension offsets integer(kind=c_size_t), public :: global_work_size (3) = 0 Global work-range dimensions integer(kind=c_size_t), public :: local_work_size (3) = 0 Local work-group dimensions Finalization Procedures final :: fclReleaseKernel public  interface fclReleaseKernel () Arguments None Type-Bound Procedures procedure, public, pass :: pushProfileEvent => fclPushProfileEvent interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type procedure, public, pass :: setArgs => fclSetKernelArgs Set kernel arguments without launching interface public module subroutine fclSetKernelArgs(kernel, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Set all kernel arguments at once without launching kernel. Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(in), target :: kernel Focal kernel object class(*), intent(in), optional, target :: a0 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a1 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument procedure, public, pass :: launch => fclLaunchKernel Launch the kernel interface public module subroutine fclLaunchKernel(kernel, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Enqueue a kernel with command arguments Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout), target :: kernel Focal kernel object class(*), intent(in), optional, target :: a0 Focal command queue or first kernel argument class(*), intent(in), optional, target :: a1 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument generic, public,  :: launchAfter => launchKernelAfterEvent_1, launchKernelAfterEvent_2, launchKernelAfterEventList_1, launchKernelAfterEventList_2 Launch a kernel with event dependencies public module subroutine fclLaunchKernelAfterEvent_1(kernel, cmdQ, event) Specific interface for a single event dependency on a specific command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclCommandQ ), intent(inout) :: cmdQ CmdQ on which to launch kernel type( fclEvent ), intent(in) :: event Event dependency for kernel public module subroutine fclLaunchKernelAfterEvent_2(kernel, event) Specific interface a single event dependency on the default command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclEvent ), intent(in) :: event Event dependency for kernel public module subroutine fclLaunchKernelAfterEventList_1(kernel, cmdQ, eventList) Specific interface for a multiple event dependencies on a specific command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclCommandQ ), intent(inout) :: cmdQ CmdQ on which to launch kernel type( fclEvent ), intent(in) :: eventList (:) Event dependency list for kernel public module subroutine fclLaunchKernelAfterEventList_2(kernel, eventList) Specific interface for a multiple event dependencies on the default command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclEvent ), intent(in) :: eventList (:) Event dependency list for kernel","tags":"","loc":"type/fclkernel.html"},{"title":"fclDeviceBuffer – Focal API Reference ","text":"type, public, extends( fclProfileContainer ) :: fclDeviceBuffer Type wrapper for openCL memory objects Contents Variables profileName profilingEnabled profileEvents profileSize nProfileEvent profileEventType nBytes Type-Bound Procedures pushProfileEvent Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure, public, pass :: pushProfileEvent => fclPushProfileEvent interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type","tags":"","loc":"type/fcldevicebuffer.html"},{"title":"fclDeviceInt32 – Focal API Reference ","text":"type, public, extends( fclDeviceBuffer ) :: fclDeviceInt32 Type wrapper for memory objects representing int32 Contents Variables profileName profilingEnabled profileEvents profileSize nProfileEvent profileEventType nBytes Type-Bound Procedures pushProfileEvent Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure, public, pass :: pushProfileEvent => fclPushProfileEvent interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type","tags":"","loc":"type/fcldeviceint32.html"},{"title":"fclDeviceFloat – Focal API Reference ","text":"type, public, extends( fclDeviceBuffer ) :: fclDeviceFloat Type wrapper for memory objects representing float Contents Variables profileName profilingEnabled profileEvents profileSize nProfileEvent profileEventType nBytes Type-Bound Procedures pushProfileEvent Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure, public, pass :: pushProfileEvent => fclPushProfileEvent interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type","tags":"","loc":"type/fcldevicefloat.html"},{"title":"fclDeviceDouble – Focal API Reference ","text":"type, public, extends( fclDeviceBuffer ) :: fclDeviceDouble Type wrapper for memory objects representing double Contents Variables profileName profilingEnabled profileEvents profileSize nProfileEvent profileEventType nBytes Type-Bound Procedures pushProfileEvent Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure, public, pass :: pushProfileEvent => fclPushProfileEvent interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type","tags":"","loc":"type/fcldevicedouble.html"},{"title":"fclLocalArgument – Focal API Reference ","text":"type, public :: fclLocalArgument Type for specifying local kernel arguments.\n Instantiate with on of: fclLocalInt32, fclLocalFloat, fclLocalDouble Contents Variables nBytes Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes","tags":"","loc":"type/fcllocalargument.html"},{"title":"fclLocalArgInt32 – Focal API Reference ","text":"type, public, extends( fclLocalArgument ) :: fclLocalArgInt32 Type wrapper for local kernel arguments representing 32 bit integers Contents Variables nBytes Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes","tags":"","loc":"type/fcllocalargint32.html"},{"title":"fclLocalArgFloat – Focal API Reference ","text":"type, public, extends( fclLocalArgument ) :: fclLocalArgFloat Type wrapper for local kernel arguments representing floats Contents Variables nBytes Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes","tags":"","loc":"type/fcllocalargfloat.html"},{"title":"fclLocalArgDouble – Focal API Reference ","text":"type, public, extends( fclLocalArgument ) :: fclLocalArgDouble Type wrapper for local kernel arguments representing doubles Contents Variables nBytes Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes","tags":"","loc":"type/fcllocalargdouble.html"},{"title":"fclHandleErrorInterface – Focal API Reference","text":"abstract interface public  subroutine fclHandleErrorInterface(errcode, focalCall, oclCall) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: errcode character(len=*), intent(in) :: focalCall character(len=*), intent(in) :: oclCall","tags":"","loc":"interface/fclhandleerrorinterface.html"},{"title":"fclGetErrorString – Focal API Reference","text":"interface public module function fclGetErrorString(errcode) result(errstr) Arguments Type Intent Optional Attributes Name integer, intent(in) :: errcode OpenCL API error code Return Value character(len=errStringLen) Returns OpenCL error string Description Return the text representation for an openCL error code","tags":"","loc":"interface/fclgeterrorstring.html"},{"title":"fclHandleError – Focal API Reference","text":"interface public module subroutine fclHandleError(errcode, focalCall, oclCall) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: errcode character(len=*), intent(in) :: focalCall character(len=*), intent(in) :: oclCall Description Wrapper to invoke fclErrorHandle procedure pointer (fixes issue with ifort)","tags":"","loc":"interface/fclhandleerror.html"},{"title":"fclHandleBuildError – Focal API Reference","text":"interface public module subroutine fclHandleBuildError(builderrcode, prog, ctx) Arguments Type Intent Optional Attributes Name integer, intent(in) :: builderrcode OpenCL API error code type( fclProgram ), intent(in) :: prog Focal program object type( fclContext ), intent(in) :: ctx Focal context object Description Check an openCL error code and print build log if necessary","tags":"","loc":"interface/fclhandlebuilderror.html"},{"title":"fclDefaultErrorHandler – Focal API Reference","text":"interface public module subroutine fclDefaultErrorHandler(errcode, focalCall, oclCall) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: errcode character(len=*), intent(in) :: focalCall character(len=*), intent(in) :: oclCall","tags":"","loc":"interface/fcldefaulterrorhandler.html"},{"title":"fclRuntimeError – Focal API Reference","text":"interface public module subroutine fclRuntimeError(descrip) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: descrip Description of current API call Description Stop and print message for Focal errors not caused by openCL API call","tags":"","loc":"interface/fclruntimeerror.html"},{"title":"fclAllocHost – Focal API Reference","text":"public interface fclAllocHost Generic interface for allocating host arrays using \n 'pinned' (non-paged) memory. This is required for asynchronous transfers. Currently implements interfaces for 1D and 2D int32, float and double arrays. Note This is a blocking command. Execution waits on host until map is complete Example: Allocate a 1D integer array with 100 elements integer, pointer :: hostArray(:) call fclAllocHost(cmdq,hostArray,100) NB: cmdq is optional, if omitted then the default command queue is used Contents Subroutines fclAllocHostPtr_1 fclAllocHostPtr_2 fclAllocHostInt32D1_1 fclAllocHostInt32D1_2 fclAllocHostFloatD1_1 fclAllocHostFloatD1_2 fclAllocHostDoubleD1_1 fclAllocHostDoubleD1_2 Subroutines public module subroutine fclAllocHostPtr_1(cmdq, hostPtr, nBytes) Allocate a 'pinned' (non-paged) host array Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory type(c_ptr), intent(out) :: hostPtr c pointer to allocated host memory integer(kind=c_int64_t), intent(in) :: nBytes Desired array size in bytes public module subroutine fclAllocHostPtr_2(hostPtr, nBytes) Allocate a 'pinned' (non-paged) host array on default cmdq Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: hostPtr c pointer to allocated host memory integer(kind=c_int64_t), intent(in) :: nBytes Desired array size in bytes public module subroutine fclAllocHostInt32D1_1(cmdq, hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit integers Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostInt32D1_2(hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit integers on default cmdq Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostFloatD1_1(cmdq, hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit reals Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory real(kind=c_Float), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostFloatD1_2(hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit reals on default cmdq Arguments Type Intent Optional Attributes Name real(kind=c_Float), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostDoubleD1_1(cmdq, hostPtr, dim) Allocate a 1D 'pinned' host array for 64bit reals Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory real(kind=c_Double), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostDoubleD1_2(hostPtr, dim) Allocate a 1D 'pinned' host array for 64bit reals on default cmdq Arguments Type Intent Optional Attributes Name real(kind=c_Double), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate","tags":"","loc":"interface/fclallochost.html"},{"title":"fclFreeHost – Focal API Reference","text":"public interface fclFreeHost Generic interface to free pinned host pointer Note This is a blocking command. Execution waits on host until unmap is complete Contents Subroutines fclFreeHostPtr_1 fclFreeHostPtr_2 fclFreeHostInt32_1 fclFreeHostInt32_2 fclFreeHostFloat_1 fclFreeHostFloat_2 fclFreeHostDouble_1 fclFreeHostDouble_2 Subroutines public module subroutine fclFreeHostPtr_1(cmdq, hostPtr) Enqueue unmap/free command to specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq type(c_ptr), intent(in) :: hostPtr public module subroutine fclFreeHostPtr_2(hostPtr) Enqueue unmap/free command to default command queue Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: hostPtr public module subroutine fclFreeHostInt32_1(cmdq, hostPtr) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostInt32_2(hostPtr) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostFloat_1(cmdq, hostPtr) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq real(kind=c_float), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostFloat_2(hostPtr) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostDouble_1(cmdq, hostPtr) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq real(kind=c_double), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostDouble_2(hostPtr) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), pointer :: hostPtr (:)","tags":"","loc":"interface/fclfreehost.html"},{"title":"assignment(=) – Focal API Reference","text":"public interface assignment(=) Generic interface for assignment of fclBuffer objects by operator-overloading Contents Module Procedures fclMemWriteScalarInt32 fclMemWriteScalarFloat fclMemWriteScalarDouble fclMemWriteInt32 fclMemWriteFloat fclMemWriteDouble fclMemReadInt32 fclMemReadFloat fclMemReadDouble fclMemCopyInt32 fclMemCopyFloat fclMemCopyDouble Module Procedures public  interface fclMemWriteScalarInt32 () Arguments None public  interface fclMemWriteScalarFloat () Arguments None public  interface fclMemWriteScalarDouble () Arguments None public  interface fclMemWriteInt32 () Arguments None public  interface fclMemWriteFloat () Arguments None public  interface fclMemWriteDouble () Arguments None public  interface fclMemReadInt32 () Arguments None public  interface fclMemReadFloat () Arguments None public  interface fclMemReadDouble () Arguments None public  interface fclMemCopyInt32 () Arguments None public  interface fclMemCopyFloat () Arguments None public  interface fclMemCopyDouble () Arguments None","tags":"","loc":"interface/assignment(=).html"},{"title":"fclBufferSwap – Focal API Reference","text":"interface public module subroutine fclBufferSwap(memObject1, memObject2) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout) :: memObject1 Buffer objects with which to swap pointers class( fclDeviceBuffer ), intent(inout) :: memObject2 Buffer objects with which to swap pointers Description Helper routine for swapping device buffer pointers.\nAlso swaps the command queue pointers associated with each buffer if different. Note The debug build will throw an error if either buffer is uninitialised\n       or if the buffers do not match in size.","tags":"","loc":"interface/fclbufferswap.html"},{"title":"fclInitBuffer – Focal API Reference","text":"public interface fclInitBuffer Generic interface to initialise buffers on the device Contents Subroutines fclInitBufferUntyped_1 fclInitBufferUntyped_2 fclInitBufferFloat_1 fclInitBufferFloat_2 fclInitBufferDouble_1 fclInitBufferDouble_2 fclInitBufferInt32_1 fclInitBufferInt32_2 Subroutines public module subroutine fclInitBufferUntyped_1(cmdq, buffer, nBytes, profileName, access) Initialise untyped buffer object on specified command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceBuffer ), intent(inout) :: buffer Focal memory object to initialise integer(kind=c_size_t), intent(in) :: nBytes Size of buffer in bytes character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferUntyped_2(buffer, nBytes, profileName, access) Initialise untyped buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceBuffer ), intent(inout) :: buffer Focal memory object to initialise integer(kind=c_size_t), intent(in) :: nBytes Size of buffer in bytes character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferFloat_1(cmdq, buffer, dim, profileName, access) Initialise float buffer object on specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceFloat ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferFloat_2(buffer, dim, profileName, access) Initialise float buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceFloat ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferDouble_1(cmdq, buffer, dim, profileName, access) Initialise double buffer object on specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceDouble ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferDouble_2(buffer, dim, profileName, access) Initialise double buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceDouble ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferInt32_1(cmdq, buffer, dim, profileName, access) Initialise 32bit integer buffer object on specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceInt32 ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferInt32_2(buffer, dim, profileName, access) Initialise 32bit integer buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceInt32 ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only","tags":"","loc":"interface/fclinitbuffer.html"},{"title":"fclInitSubBuffer – Focal API Reference","text":"public interface fclInitSubBuffer Generic interface to initialise sub-buffers on the device Contents Subroutines fclInitSubBufferUntyped_1 fclInitSubBufferUntyped_2 fclInitSubBufferFloat_1 fclInitSubBufferFloat_2 fclInitSubBufferDouble_1 fclInitSubBufferDouble_2 fclInitSubBufferint32_1 fclInitSubBufferint32_2 Subroutines public module subroutine fclInitSubBufferUntyped_1(cmdq, subBuffer, sourceBuffer, offset, size, profileName, access) Initialise an untyped sub-buffer from an existing buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceBuffer ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer class( fclDeviceBuffer ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer(kind=c_size_t), intent(in) :: offset Offset in bytes of sub-buffer within sourceBuffer integer(kind=c_size_t), intent(in) :: size Size in bytes of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferUntyped_2(subBuffer, sourceBuffer, offset, size, profileName, access) Initialise an untyped sub-buffer from an existing buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceBuffer ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer class( fclDeviceBuffer ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer(kind=c_size_t), intent(in) :: offset Offset in bytes of sub-buffer within sourceBuffer integer(kind=c_size_t), intent(in) :: size Size in bytes of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferFloat_1(cmdq, subBuffer, sourceBuffer, start, length, profileName, access) Initialise a float sub-buffer from an existing float buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceFloat ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceFloat ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferFloat_2(subBuffer, sourceBuffer, start, length, profileName, access) Initialise a float sub-buffer from an existing float buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceFloat ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceFloat ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferDouble_1(cmdq, subBuffer, sourceBuffer, start, length, profileName, access) Initialise a double sub-buffer from an existing float buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceDouble ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceDouble ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferDouble_2(subBuffer, sourceBuffer, start, length, profileName, access) Initialise a double sub-buffer from an existing float buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceDouble ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceDouble ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferint32_1(cmdq, subBuffer, sourceBuffer, start, length, profileName, access) Initialise a 32bit integer sub-buffer from an existing float buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceInt32 ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceInt32 ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferint32_2(subBuffer, sourceBuffer, start, length, profileName, access) Initialise a 32bit integer sub-buffer from an existing float buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceInt32 ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceInt32 ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only","tags":"","loc":"interface/fclinitsubbuffer.html"},{"title":"fclMemWriteScalar – Focal API Reference","text":"interface public module subroutine fclMemWriteScalar(memObject, hostBufferPtr, nBytesPattern) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout), target :: memObject Focal memory object to fill type(c_ptr), intent(in) :: hostBufferPtr C Pointer to host scalar patter integer(kind=c_size_t), intent(in) :: nBytesPattern Size of scalar pattern in bytes Description Fill device buffer with scalar pattern","tags":"","loc":"interface/fclmemwritescalar.html"},{"title":"fclMemWriteScalarInt32 – Focal API Reference","text":"interface public module subroutine fclMemWriteScalarInt32(memObject, hostValue) Arguments Type Intent Optional Attributes Name class( fclDeviceInt32 ), intent(inout) :: memObject Focal memory object to fill integer(kind=c_int32_t), intent(in), target :: hostValue Host value with which to fill Description Assign a scalar integer to a device integer memory buffer\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemwritescalarint32.html"},{"title":"fclMemWriteScalarFloat – Focal API Reference","text":"interface public module subroutine fclMemWriteScalarFloat(memObject, hostValue) Arguments Type Intent Optional Attributes Name class( fclDeviceFloat ), intent(inout) :: memObject Focal memory object to fill real(kind=c_float), intent(in), target :: hostValue Host value with which to fill Description Assign a scalar float to a device float memory buffer\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemwritescalarfloat.html"},{"title":"fclMemWriteScalarDouble – Focal API Reference","text":"interface public module subroutine fclMemWriteScalarDouble(memObject, hostValue) Arguments Type Intent Optional Attributes Name class( fclDeviceDouble ), intent(inout) :: memObject Focal memory object to fill real(kind=c_double), intent(in), target :: hostValue Host value with which to fill Description Assign a scalar double to a device double memory buffer\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemwritescalardouble.html"},{"title":"fclMemWrite – Focal API Reference","text":"interface public module subroutine fclMemWrite(memObject, hostBufferPtr, nBytes) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout), target :: memObject Focal memory object (target) type(c_ptr), intent(in) :: hostBufferPtr C Pointer to host array (source) integer(kind=c_size_t), intent(in) :: nBytes Size of buffers in bytes Description Transfer host buffer to device buffer","tags":"","loc":"interface/fclmemwrite.html"},{"title":"fclMemWriteInt32 – Focal API Reference","text":"interface public module subroutine fclMemWriteInt32(memObject, hostBuffer) Arguments Type Intent Optional Attributes Name class( fclDeviceInt32 ), intent(inout) :: memObject Focal memory object (target) integer(kind=c_int32_t), intent(in), target :: hostBuffer (:) Host array (source) Description Transfer host integer array to device integer array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemwriteint32.html"},{"title":"fclMemWriteFloat – Focal API Reference","text":"interface public module subroutine fclMemWriteFloat(memObject, hostBuffer) Arguments Type Intent Optional Attributes Name class( fclDeviceFloat ), intent(inout) :: memObject Focal memory object (target) real(kind=c_float), intent(in), target :: hostBuffer (:) Host array (source) Description Transfer host float array to device float array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemwritefloat.html"},{"title":"fclMemWriteDouble – Focal API Reference","text":"interface public module subroutine fclMemWriteDouble(memObject, hostBuffer) Arguments Type Intent Optional Attributes Name class( fclDeviceDouble ), intent(inout) :: memObject Focal memory object (target) real(kind=c_double), intent(in), target :: hostBuffer (:) Host array (source) Description Transfer host double array to device double array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemwritedouble.html"},{"title":"fclMemRead – Focal API Reference","text":"interface public module subroutine fclMemRead(hostBufferPtr, memObject, nBytes) Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: hostBufferPtr C pointer to host buffer (target) class( fclDeviceBuffer ), intent(in), target :: memObject Focal memory object (source) integer(kind=c_size_t), intent(in) :: nBytes Size of buffers in bytes Description Transfer device buffer to host buffer","tags":"","loc":"interface/fclmemread.html"},{"title":"fclMemReadInt32 – Focal API Reference","text":"interface public module subroutine fclMemReadInt32(hostBuffer, memObject) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(inout), target :: hostBuffer (:) Host array (target) class( fclDeviceInt32 ), intent(in) :: memObject Focal memory object (source) Description Transfer device integer array to host integer array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemreadint32.html"},{"title":"fclMemReadFloat – Focal API Reference","text":"interface public module subroutine fclMemReadFloat(hostBuffer, memObject) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(inout), target :: hostBuffer (:) Host array (target) class( fclDeviceFloat ), intent(in) :: memObject Focal memory object (source) Description Transfer device float array to host float array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemreadfloat.html"},{"title":"fclMemReadDouble – Focal API Reference","text":"interface public module subroutine fclMemReadDouble(hostBuffer, memObject) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), target :: hostBuffer (:) Host array (target) class( fclDeviceDouble ), intent(in) :: memObject Focal memory object (source) Description Transfer device double array to host double array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemreaddouble.html"},{"title":"fclMemCopy – Focal API Reference","text":"interface public module subroutine fclMemCopy(memObject1, memObject2) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceBuffer ), intent(in) :: memObject2 Focal memory object (source) Description Transfer device buffer to device buffer","tags":"","loc":"interface/fclmemcopy.html"},{"title":"fclMemCopyInt32 – Focal API Reference","text":"interface public module subroutine fclMemCopyInt32(memObject1, memObject2) Arguments Type Intent Optional Attributes Name class( fclDeviceInt32 ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceInt32 ), intent(in) :: memObject2 Focal memory object (source) Description Transfer device integer array to device integer array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemcopyint32.html"},{"title":"fclMemCopyFloat – Focal API Reference","text":"interface public module subroutine fclMemCopyFloat(memObject1, memObject2) Arguments Type Intent Optional Attributes Name class( fclDeviceFloat ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceFloat ), intent(in) :: memObject2 Focal memory object (source) Description Transfer device float array to device float array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemcopyfloat.html"},{"title":"fclMemCopyDouble – Focal API Reference","text":"interface public module subroutine fclMemCopyDouble(memObject1, memObject2) Arguments Type Intent Optional Attributes Name class( fclDeviceDouble ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceDouble ), intent(in) :: memObject2 Focal memory object (source) Description Transfer device double array to device double array\n Called by operator-overloading of assignment(=)","tags":"","loc":"interface/fclmemcopydouble.html"},{"title":"fclFreeBuffer – Focal API Reference","text":"interface public module subroutine fclFreeBuffer(memObject) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ) :: memObject Description Release device memory associated with memObject","tags":"","loc":"interface/fclfreebuffer.html"},{"title":"fclGetPlatformInfo – Focal API Reference","text":"interface public module subroutine fclGetPlatformInfo(platform, key, value) Arguments Type Intent Optional Attributes Name type( fclPlatform ), intent(in) :: platform integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value Description Query platform information.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module.","tags":"","loc":"interface/fclgetplatforminfo.html"},{"title":"fclGetDeviceInfo – Focal API Reference","text":"public interface fclGetDeviceInfo Generic interface to query device information.\nSee clGetDeviceInfo for values of 'key' argument contained in clfortran module. Contents Subroutines fclGetDeviceInfoString fclGetDeviceInfoInt32 fclGetDeviceInfoInt64 Subroutines public module subroutine fclGetDeviceInfoString(device, key, value) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public module subroutine fclGetDeviceInfoInt32(device, key, value) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value public module subroutine fclGetDeviceInfoInt64(device, key, value) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int64_t), intent(out), target :: value","tags":"","loc":"interface/fclgetdeviceinfo.html"},{"title":"fclGetKernelInfo – Focal API Reference","text":"public interface fclGetKernelInfo Generic interface to query kernel information.\nSee clGetDeviceInfo for values of 'key' argument contained in clfortran module. Contents Subroutines fclGetKernelInfoString fclGetKernelInfoInt32 Subroutines public module subroutine fclGetKernelInfoString(kernel, key, value) Query kernel information for string info.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public module subroutine fclGetKernelInfoInt32(kernel, key, value) Query kernel information for 32bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value","tags":"","loc":"interface/fclgetkernelinfo.html"},{"title":"fclGetKernelWorkGroupInfo – Focal API Reference","text":"public interface fclGetKernelWorkGroupInfo Contents Subroutines fclGetKernelWorkGroupInfoInt64 Subroutines public module subroutine fclGetKernelWorkGroupInfoInt64(kernel, device, key, value) Query kernel work group information for 64bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int64_t), intent(out), target :: value","tags":"","loc":"interface/fclgetkernelworkgroupinfo.html"},{"title":"fclGetKernelArgInfo – Focal API Reference","text":"public interface fclGetKernelArgInfo Generic interface to query kernel argument information.\nSee clGetDeviceInfo for values of 'key' argument contained in clfortran module. Contents Subroutines fclGetKernelArgInfoString fclGetKernelArgInfoInt32 Subroutines public module subroutine fclGetKernelArgInfoString(kernel, argNo, key, value) Query kernel information for string info.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public module subroutine fclGetKernelArgInfoInt32(kernel, argNo, key, value) Query kernel information for 32bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value","tags":"","loc":"interface/fclgetkernelarginfo.html"},{"title":"fclGetEventInfo – Focal API Reference","text":"interface public module subroutine fclGetEventInfo(event, key, value) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value Description Query kernel information for 32bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module.","tags":"","loc":"interface/fclgeteventinfo.html"},{"title":"fclGetPlatforms – Focal API Reference","text":"interface public module function fclGetPlatforms() result(platforms) Arguments None Return Value type( fclPlatform ),allocatable,(:) Description Return pointer to array of available fclPlatforms","tags":"","loc":"interface/fclgetplatforms.html"},{"title":"fclGetPlatform – Focal API Reference","text":"interface public module function fclGetPlatform(platform_id) result(platform) Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: platform_id OpenCL platform id Return Value type( fclPlatform ),target Description Return fclPlatform object for OpenCL platform id","tags":"","loc":"interface/fclgetplatform.html"},{"title":"fclGetPlatformDevices – Focal API Reference","text":"interface public module function fclGetPlatformDevices(platform_id) result(devices) Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: platform_id OpenCL platform id Return Value type( fclDevice ),allocatable,(:) Description Return pointer to array of fclDevices on platform id","tags":"","loc":"interface/fclgetplatformdevices.html"},{"title":"fclGetDevice – Focal API Reference","text":"interface public module function fclGetDevice(device_id) result(device) Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: device_id OpenCL device id Return Value type( fclDevice ),target Description Return fclDevice for OpenCL device id","tags":"","loc":"interface/fclgetdevice.html"},{"title":"fclCreateContext – Focal API Reference","text":"public interface fclCreateContext Generic interface to create a context Contents Functions fclCreateContextWithPlatform fclCreateContextWithVendor Functions public module function fclCreateContextWithPlatform(platform) result(ctx) Create a context with fclPlatform object Arguments Type Intent Optional Attributes Name type( fclPlatform ), intent(inout), target :: platform Return Value type( fclContext ), target public module function fclCreateContextWithVendor(vendor) result(ctx) Create a context with the first platform where the vendor property\n contains a specified string (case-insensitive). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vendor String with which to match platform vendor. Separate multiple vendors\n with commas. First matching vendor in list is used.\n Matching is case-insensitive substring. e.g. vendor='i' matches 'nvidia' and 'intel' platforms e.g. vendor='nvidia,intel' matches nvidia platform if available,\n then intel platform if available, then fails fatally if neither\n are available. Return Value type( fclContext ), target","tags":"","loc":"interface/fclcreatecontext.html"},{"title":"fclFilterDevices – Focal API Reference","text":"interface public module function fclFilterDevices(devices, vendor, type, nameLike, extensions, sortBy) result(deviceList) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: devices (:) character(len=*), intent(in), optional :: vendor Filter device list based on platform vendor.\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ),allocatable,(:) Filtered and sorted list. Unallocated if no matching devices found. Description Filter and sort list of devices based on criteria","tags":"","loc":"interface/fclfilterdevices.html"},{"title":"fclInit – Focal API Reference","text":"interface public module function fclInit(vendor, type, nameLike, extensions, sortBy) result(device) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: vendor Filter device based on platform vendor\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ),allocatable The device chosen based on the user criteria Description Quick setup helper function: find a single device based on criteria\n and set the default context accordingly.\n Raises runtime error if no matching device is found.","tags":"","loc":"interface/fclinit.html"},{"title":"fclSetDefaultContext – Focal API Reference","text":"interface public module subroutine fclSetDefaultContext(ctx) Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in) :: ctx Description Set the global default context","tags":"","loc":"interface/fclsetdefaultcontext.html"},{"title":"fclFindDevices – Focal API Reference","text":"public interface fclFindDevices Generic interface to list devices, sorted and filtered by properties\n Raises runtime error if no matching device is found. Contents Functions fclFindDevices_1 fclFindDevices_2 Functions public module function fclFindDevices_1(ctx, vendor, type, nameLike, extensions, sortBy) result(deviceList) Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx Context containing device for command queue character(len=*), intent(in), optional :: vendor Filter device list based on platform vendor.\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ), allocatable, (:) public module function fclFindDevices_2(vendor, type, nameLike, extensions, sortBy) result(deviceList) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: vendor Filter device list based on platform vendor.\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ), allocatable, (:)","tags":"","loc":"interface/fclfinddevices.html"},{"title":"fclCreateCommandQ – Focal API Reference","text":"public interface fclCreateCommandQ Generic interface to create a device command queue Contents Functions fclCreateCommandQ_1 fclCreateCommandQ_2 Functions public module function fclCreateCommandQ_1(ctx, device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(cmdq) Create a command queue with a Focal device object Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx Context containing device for command queue type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQ ) Returns fclCommandQ object public module function fclCreateCommandQ_2(device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(cmdq) Create a command queue with a Focal device object using default context Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQ ) Returns fclCommandQ object","tags":"","loc":"interface/fclcreatecommandq.html"},{"title":"fclCreateCommandQPool – Focal API Reference","text":"public interface fclCreateCommandQPool Generic interface to create a pool of command queues Contents Functions fclCreateCommandQPool_1 fclCreateCommandQPool_2 Functions public module function fclCreateCommandQPool_1(ctx, N, device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(qPool) Create a command queue pool with a Focal device object Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx Context containing device for command queue integer, intent(in) :: N Number of command queues to create in pool type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQPool ) Returns fclCommandQPool object public module function fclCreateCommandQPool_2(N, device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(qPool) Create a command queue pool with a Focal device object using default context Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of command queues to create in pool type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQPool ) Returns fclCommandQPool object","tags":"","loc":"interface/fclcreatecommandqpool.html"},{"title":"fclCommandQPool_Next – Focal API Reference","text":"interface public module function fclCommandQPool_Next(qPool) result(cmdQ) Arguments Type Intent Optional Attributes Name class( fclCommandQPool ), intent(inout), target :: qPool Return Value type( fclCommandQ ),pointer Description Returns next scheduled queue in queue pool","tags":"","loc":"interface/fclcommandqpool_next.html"},{"title":"fclCommandQPool_Current – Focal API Reference","text":"interface public module function fclCommandQPool_Current(qPool) result(cmdQ) Arguments Type Intent Optional Attributes Name class( fclCommandQPool ), intent(in), target :: qPool Return Value type( fclCommandQ ),pointer Description Returns current scheduled queue in queue pool","tags":"","loc":"interface/fclcommandqpool_current.html"},{"title":"fclSetDefaultCommandQ – Focal API Reference","text":"interface public module subroutine fclSetDefaultCommandQ(cmdq) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Description Set the global default command queue","tags":"","loc":"interface/fclsetdefaultcommandq.html"},{"title":"fclCompileProgram – Focal API Reference","text":"public interface fclCompileProgram Generic interface to compile an openCL program Contents Functions fclCompileProgram_1 fclCompileProgram_2 Functions public module function fclCompileProgram_1(ctx, source, options) result(prog) Compile program source on context ctx Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx character(len=*), intent(in) :: source Program source code character(len=*), intent(in), optional :: options OpenCL compilation options Return Value type( fclProgram ) Returns fclProgram object public module function fclCompileProgram_2(source, options) result(prog) Compile program source on fclDefaultContext Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Program source code character(len=*), intent(in), optional :: options OpenCL compilation options Return Value type( fclProgram ) Returns fclProgram object","tags":"","loc":"interface/fclcompileprogram.html"},{"title":"fclDumpBuildLog – Focal API Reference","text":"public interface fclDumpBuildLog Contents Subroutines fclDumpBuildLog_1 fclDumpBuildLog_2 Subroutines public module subroutine fclDumpBuildLog_1(ctx, prog, device, outputUnit) Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in) :: ctx type( fclProgram ), intent(in) :: prog type( fclDevice ), intent(in) :: device integer, intent(in), optional :: outputUnit public module subroutine fclDumpBuildLog_2(prog, device, outputUnit) Arguments Type Intent Optional Attributes Name type( fclProgram ), intent(in) :: prog type( fclDevice ), intent(in) :: device integer, intent(in), optional :: outputUnit","tags":"","loc":"interface/fcldumpbuildlog.html"},{"title":"fclGetProgramKernel – Focal API Reference","text":"interface public module function fclGetProgramKernel(prog, kernelName, global_work_size, local_work_size, work_dim, global_work_offset) result(kern) Arguments Type Intent Optional Attributes Name type( fclProgram ), intent(in) :: prog Compiled program object containing kernel character(len=*), intent(in) :: kernelName Name of kernel to extract for execution integer, intent(in), optional :: global_work_size (:) Global work group dimensions, default unset (must set prior to launching) integer, intent(in), optional :: local_work_size (:) Local work group dimensions, default zeros (decided by OpenCL runtime) integer, intent(in), optional :: work_dim Number of dimensions for kernel work group, default 1 integer, intent(in), optional :: global_work_offset (:) Global work group offsets, default zeros Return Value type( fclKernel ) Returns fclKernel object for execution Description Extract a kernel object for execution from a compiled program object","tags":"","loc":"interface/fclgetprogramkernel.html"},{"title":"fclLaunchKernelAfter – Focal API Reference","text":"public interface fclLaunchKernelAfter Generic interface to launch a kernel with event dependencies Contents Subroutines fclLaunchKernelAfterEvent_1 fclLaunchKernelAfterEvent_2 fclLaunchKernelAfterEventList_1 fclLaunchKernelAfterEventList_2 Subroutines public module subroutine fclLaunchKernelAfterEvent_1(kernel, cmdQ, event) Specific interface for a single event dependency on a specific command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclCommandQ ), intent(inout) :: cmdQ CmdQ on which to launch kernel type( fclEvent ), intent(in) :: event Event dependency for kernel public module subroutine fclLaunchKernelAfterEvent_2(kernel, event) Specific interface a single event dependency on the default command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclEvent ), intent(in) :: event Event dependency for kernel public module subroutine fclLaunchKernelAfterEventList_1(kernel, cmdQ, eventList) Specific interface for a multiple event dependencies on a specific command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclCommandQ ), intent(inout) :: cmdQ CmdQ on which to launch kernel type( fclEvent ), intent(in) :: eventList (:) Event dependency list for kernel public module subroutine fclLaunchKernelAfterEventList_2(kernel, eventList) Specific interface for a multiple event dependencies on the default command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclEvent ), intent(in) :: eventList (:) Event dependency list for kernel","tags":"","loc":"interface/fcllaunchkernelafter.html"},{"title":"fclLocalInt32 – Focal API Reference","text":"interface public module function fclLocalInt32(nElem) result(localArg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElem No of array elements Return Value type( fclLocalArgInt32 ) Returns local argument object Description Create a integer local kernel argument object for launching kernels","tags":"","loc":"interface/fcllocalint32.html"},{"title":"fclLocalFloat – Focal API Reference","text":"interface public module function fclLocalFloat(nElem) result(localArg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElem No of array elements Return Value type( fclLocalArgFloat ) Returns local argument object Description Create a float local kernel argument object for launching kernels","tags":"","loc":"interface/fcllocalfloat.html"},{"title":"fclLocalDouble – Focal API Reference","text":"interface public module function fclLocalDouble(nElem) result(localArg) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElem No of array elements Return Value type( fclLocalArgDouble ) Returns local argument object Description Create a double local kernel argument object for launching kernels","tags":"","loc":"interface/fcllocaldouble.html"},{"title":"fclLaunchKernel – Focal API Reference","text":"interface public module subroutine fclLaunchKernel(kernel, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout), target :: kernel Focal kernel object class(*), intent(in), optional, target :: a0 Focal command queue or first kernel argument class(*), intent(in), optional, target :: a1 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument Description Enqueue a kernel with command arguments","tags":"","loc":"interface/fcllaunchkernel.html"},{"title":"fclProcessKernelArgs – Focal API Reference","text":"interface public module subroutine fclProcessKernelArgs(kernel, cmdq, narg, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(in), target :: kernel Focal kernel object type( fclCommandQ ), intent(out), pointer :: cmdq Returns a0 if it is cmdq, otherwise returns fclDefaultCommandQ integer, intent(out) :: narg Returns the actual number of arguments passed class(*), intent(in), optional, target :: a0 Focal command queue or first kernel argument class(*), intent(in), optional, target :: a1 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument Description Sets kernel arguments and parses argument list for optional cmdq and actual number of arguments. Note This is helper routine used internally by focal.  If you just want set kernel arguments\n without launching a kernel, use fclSetKernelArgs .","tags":"","loc":"interface/fclprocesskernelargs.html"},{"title":"fclSetKernelArgs – Focal API Reference","text":"interface public module subroutine fclSetKernelArgs(kernel, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(in), target :: kernel Focal kernel object class(*), intent(in), optional, target :: a0 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a1 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument Description Set all kernel arguments at once without launching kernel.","tags":"","loc":"interface/fclsetkernelargs.html"},{"title":"fclSetKernelArg – Focal API Reference","text":"interface public module subroutine fclSetKernelArg(kernel, argIndex, argValue) Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel Focal kernel object integer(kind=c_int32_t), intent(in) :: argIndex Index of kernel argument to set class(*), intent(in), target :: argValue Value of kernel argument.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument Description Set or change a single kernel argument","tags":"","loc":"interface/fclsetkernelarg.html"},{"title":"fclReleaseKernel – Focal API Reference","text":"interface public module subroutine fclReleaseKernel(kernel) Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(inout) :: kernel Focal kernel object Description Release OpenCL memory associated with underlying kernel pointer","tags":"","loc":"interface/fclreleasekernel.html"},{"title":"fclBarrier – Focal API Reference","text":"public interface fclBarrier Generic interface to enqueue a command queue barrier\n Wait on device for all preceding queue events to complete before\n subsequent events can proceed. Contents Subroutines fclBarrier_1 fclBarrier_2 Subroutines public module subroutine fclBarrier_1(cmdq) Enqueue barrier on all events in command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(inout), target :: cmdq public module subroutine fclBarrier_2() Enqueue barrier on all events in default command queue Arguments None","tags":"","loc":"interface/fclbarrier.html"},{"title":"fclWait – Focal API Reference","text":"public interface fclWait Generic interface to wait on host for events Contents Subroutines fclFinish_1 fclFinish_2 fclFinish_3 fclWaitEvent fclWaitEventList Subroutines public module subroutine fclFinish_1(cmdq) Wait on host for all events in user-specified command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq public module subroutine fclFinish_2() Wait on host for all events in focal default command queue Arguments None public module subroutine fclFinish_3(qPool) Wait on host for all events in all queues in a queue pool Arguments Type Intent Optional Attributes Name type( fclCommandQPool ), intent(in) :: qPool public module subroutine fclWaitEvent(event) Wait on host for a specific event Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in), target :: event public module subroutine fclWaitEventList(eventList) Wait on host for set of events Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in), target :: eventList (:)","tags":"","loc":"interface/fclwait.html"},{"title":"assignment(=) – Focal API Reference","text":"public interface assignment(=) Contents Subroutines fclEventCopy Subroutines public module subroutine fclEventCopy(target, source) Overloaded assignment for event assignment.\n Handles opencl reference counting for the underlying event object Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(inout) :: target type( fclEvent ), intent(in) :: source","tags":"","loc":"interface/assignment(=)~2.html"},{"title":"fclReleaseEvent – Focal API Reference","text":"interface public module subroutine fclReleaseEvent(event) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event Focal event object to release Description Light weight wrapper for clReleaseEvent (decrement reference count)","tags":"","loc":"interface/fclreleaseevent.html"},{"title":"fclRetainEvent – Focal API Reference","text":"interface public module subroutine fclRetainEvent(event) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event Focal event object to retain Description Light weight wrapper for clRetainEvent (increment reference count)","tags":"","loc":"interface/fclretainevent.html"},{"title":"fclSetDependency – Focal API Reference","text":"public interface fclSetDependency Generic interface to set pre-requisite events for the next enqueued action.\n This does not append to any existing dependencies - it overwrites the dependency list. Contents Subroutines fclSetDependencyEvent_1 fclSetDependencyEvent_2 fclSetDependencyEventList_1 fclSetDependencyEventList_2 Subroutines public module subroutine fclSetDependencyEvent_1(cmdQ, event, hold) Interface for specifying a single event dependency on specific cmdq Arguments Type Intent Optional Attributes Name type( fclCommandQ ), target :: cmdQ Command queue type( fclEvent ), intent(in) :: event Event dependency logical, intent(in), optional :: hold Hold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. public module subroutine fclSetDependencyEvent_2(event, hold) Interface for specifying a single event dependency on default cmdq Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event Event dependency logical, intent(in), optional :: hold Hold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. public module subroutine fclSetDependencyEventList_1(cmdQ, eventList, hold) Interface for specifying a list of dependent events on specific cmdq Arguments Type Intent Optional Attributes Name type( fclCommandQ ), target :: cmdQ Command queue type( fclEvent ), intent(in) :: eventList (:) List of event dependencies logical, intent(in), optional :: hold Hold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. public module subroutine fclSetDependencyEventList_2(eventList, hold) Interface for specifying a list of dependent events on default cmdq Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: eventList (:) List of event dependencies logical, intent(in), optional :: hold Event dependency\nHold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false.","tags":"","loc":"interface/fclsetdependency.html"},{"title":"fclPopDependencies – Focal API Reference","text":"interface public module subroutine fclPopDependencies(cmdq) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(inout) :: cmdq Description Called after every enqueue operation:\nClear dependencies unless dependency hold is .true.","tags":"","loc":"interface/fclpopdependencies.html"},{"title":"fclClearDependencies – Focal API Reference","text":"public interface fclClearDependencies Generic interface to clear dependency list and reset dependency hold to .false. Contents Subroutines fclClearDependencies_1 fclClearDependencies_2 Subroutines public module subroutine fclClearDependencies_1(cmdq) Interface for specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(inout) :: cmdq public module subroutine fclClearDependencies_2() Interface for default command queueu Arguments None","tags":"","loc":"interface/fclcleardependencies.html"},{"title":"fclCreateUserEvent – Focal API Reference","text":"public interface fclCreateUserEvent Generic interface to create a user event Contents Functions fclCreateUserEvent_1 fclCreateUserEvent_2 Functions public module function fclCreateUserEvent_1(ctx) result(userEvent) Create user event in a specific context Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in) :: ctx Return Value type( fclEvent ) public module function fclCreateUserEvent_2() result(userEvent) Create user event in the default context Arguments None Return Value type( fclEvent )","tags":"","loc":"interface/fclcreateuserevent.html"},{"title":"fclSetUserEvent – Focal API Reference","text":"interface public module subroutine fclSetUserEvent(event, stat) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(inout) :: event integer(kind=c_int32_t), intent(in), optional :: stat Description Set status of a user event","tags":"","loc":"interface/fclsetuserevent.html"},{"title":"fclGetEventDurations – Focal API Reference","text":"interface public module function fclGetEventDurations(eventList) result(durations) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: eventList (:) Return Value integer(kind=c_int64_t)(size(eventList,1))","tags":"","loc":"interface/fclgeteventdurations.html"},{"title":"fclProfilerAdd – Focal API Reference","text":"interface public module subroutine fclProfilerAdd(profiler, profileSize, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9) Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(inout) :: profiler Profiler - collection of objects to profile integer, intent(in) :: profileSize Number of events to save for profiling (allocation size) class( fclProfileContainer ), intent(inout), target :: c0 Object (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c1 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c2 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c3 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c4 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c5 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c6 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c7 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c8 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c9 Subsequent objects (kernel/buffer) for which to enable profiling Description Enable profiling for multiple container (kernel/buffer) and add to profiler collection","tags":"","loc":"interface/fclprofileradd.html"},{"title":"fclEnableProfiling – Focal API Reference","text":"interface public module subroutine fclEnableProfiling(container, profileSize, profiler) Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(inout), target :: container Container on which to enable profiling. This can be one of: fclKernel , fclDeviceBuffer , fclProfileContainer . integer, intent(in) :: profileSize Number of events to allocate space for type( fclProfiler ), intent(inout), optional :: profiler Profiler collection object to which to add the kernel/buffer. Description Enable profiling on a specific container by allocating space to save events","tags":"","loc":"interface/fclenableprofiling.html"},{"title":"fclPushProfileEvent – Focal API Reference","text":"interface public module subroutine fclPushProfileEvent(container, event, type) Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type Description If profiling is enabled for the container, save an event to it","tags":"","loc":"interface/fclpushprofileevent.html"},{"title":"fclDumpProfileData – Focal API Reference","text":"interface public module subroutine fclDumpProfileData(profiler, outputUnit) Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(in) :: profiler Profiler object containing collection of kernels & buffers to profile integer, intent(in), optional :: outputUnit Output unit to write summary data Description Dump summary of profiler data for list of kernels to specific output unit","tags":"","loc":"interface/fcldumpprofiledata.html"},{"title":"fclDumpKernelProfileData – Focal API Reference","text":"interface public module subroutine fclDumpKernelProfileData(outputUnit, kernelList, device) Arguments Type Intent Optional Attributes Name integer, intent(in) :: outputUnit Output unit to write summary data class( fclKernel ), intent(in) :: kernelList (:) List of kernels for which to dump profile data type( fclDevice ), intent(in) :: device Device on which the kernels were executed\nNeeded for kernel work group info. Description Dump summary of profile data for list of kernels to specific output unit","tags":"","loc":"interface/fcldumpkernelprofiledata.html"},{"title":"fclDumpBufferProfileData – Focal API Reference","text":"interface public module subroutine fclDumpBufferProfileData(outputUnit, bufferList1, bufferList2, bufferList3) Arguments Type Intent Optional Attributes Name integer, intent(in) :: outputUnit Output unit to write summary data. class( fclDeviceBuffer ), intent(in), target :: bufferList1 (:) List of buffers for which to dump profile data class( fclDeviceBuffer ), intent(in), optional, target :: bufferList2 (:) List of buffers for which to dump profile data class( fclDeviceBuffer ), intent(in), optional, target :: bufferList3 (:) List of buffers for which to dump profile data Description Dump summary of profile data for list of buffers to specific output unit. Three buffer list inputs are provided for different buffer types","tags":"","loc":"interface/fcldumpbufferprofiledata.html"},{"title":"fclDumpTracingData – Focal API Reference","text":"interface public module subroutine fclDumpTracingData(profiler, filename) Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(in) :: profiler Profiler collection object containing kernels/buffers that have been profiled character(len=*), intent(in) :: filename Filename to which to write chrome://tracing format Description Writes a chrome://tracing data format for profiled events","tags":"","loc":"interface/fcldumptracingdata.html"},{"title":"fclDbgOptions – Focal API Reference","text":"interface public module function fclDbgOptions() result(options) Arguments None Return Value character(len=:),allocatable Description Returns OpenCL compile options as interoperable string for debug mode Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgoptions.html"},{"title":"fclDbgCheckContext – Focal API Reference","text":"interface public module subroutine fclDbgCheckContext(descrip, ctx) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: descrip Description of program location for error output type( fclContext ), intent(in), optional :: ctx Context to test. Uses fclDefaultContext if not present. Description Check the (default) context is initialised.\nAssumes uninitialised contexts have cl_context = -1. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckcontext.html"},{"title":"fclDbgCheckDevice – Focal API Reference","text":"interface public module subroutine fclDbgCheckDevice(device, descrip) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device Device object to check character(len=*), intent(in) :: descrip Description of program location for error output Description Check a device object is valid\nAssumes uninitialised devices have cl_device_id = -1. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckdevice.html"},{"title":"fclDbgCheckBufferInit – Focal API Reference","text":"interface public module subroutine fclDbgCheckBufferInit(memObject, descrip) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(in) :: memObject character(len=*), intent(in) :: descrip Description Check that a device buffer object has been initialised. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckbufferinit.html"},{"title":"fclDbgCheckBufferSize – Focal API Reference","text":"interface public module subroutine fclDbgCheckBufferSize(memObject, hostBytes, descrip) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(in) :: memObject integer(kind=c_size_t), intent(in) :: hostBytes character(len=*), intent(in) :: descrip Description Check that a host buffer matches the size in bytes of a device buffer. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckbuffersize.html"},{"title":"fclDbgCheckCopyBufferSize – Focal API Reference","text":"interface public module subroutine fclDbgCheckCopyBufferSize(memObject1, memObject2) Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(in) :: memObject1 class( fclDeviceBuffer ), intent(in) :: memObject2 Description Check that a host buffer matches the size in bytes of a device buffer. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckcopybuffersize.html"},{"title":"fclDbgCheckKernelNArg – Focal API Reference","text":"interface public module subroutine fclDbgCheckKernelNArg(kernel, nArg) Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: nArg Description Check that number of actual args matches number of kernel args. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckkernelnarg.html"},{"title":"fclDbgCheckKernelArgType – Focal API Reference","text":"interface public module subroutine fclDbgCheckKernelArgType(kernel, argNo, type) Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo character(len=*), intent(in) :: type Description Checks the types of arguments passed to kernels Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckkernelargtype.html"},{"title":"fclDbgCheckKernelArgQualifier – Focal API Reference","text":"interface public module subroutine fclDbgCheckKernelArgQualifier(kernel, argNo, qualifier) Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo character(len=*), intent(in) :: qualifier Description Checks the address qualifier of arguments passed to kernels. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgcheckkernelargqualifier.html"},{"title":"fclDbgWait – Focal API Reference","text":"interface public module subroutine fclDbgWait(event, descrip) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in), target :: event Event object to check character(len=*), intent(in), optional :: descrip Description for debugging Description Wait for an event to complete and check for successful completion.\nThrow runtime error if status is not CL_COMPLETE. Note Debug routine: only executed for debug build.","tags":"","loc":"interface/fcldbgwait.html"},{"title":"fclGetKernelResource – Focal API Reference","text":"interface public module subroutine fclGetKernelResource(kernelString) Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: kernelString Kernel source as fortran character string Description Retrieve kernel source linked as a binary resource.\n Use linker ld to include kernel source with:\n  ld -r -b binary -o fclKernels.o fclKernels.cl\n(Object file MUST be called fclKernels.o, with no path)\nThen link resulting object file as normal","tags":"","loc":"interface/fclgetkernelresource.html"},{"title":"fclSourceFromFile – Focal API Reference","text":"interface public module subroutine fclSourceFromFile(filename, sourceString) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: sourceString Description Allocate and fill character string from file","tags":"","loc":"interface/fclsourcefromfile.html"},{"title":"strStripNum – Focal API Reference","text":"interface public module function strStripNum(linei) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: linei Input string Return Value character(len=len) Converted string output Description Return copy of string with numerical characters removed","tags":"","loc":"interface/strstripnum.html"},{"title":"Focal – Focal API Reference","text":"Header module for all focal parameters, types and interfaces Note This is a header module: it contains subroutine interface definitions only.\nSubroutine implementation (code) is found in the corresponding submodule files. Note Use of global parameters must not restrict ability to use the module\n      asynchronously or within parallel/multithread environment Uses iso_fortran_env iso_c_binding Used by Descendants: Focal_Debug Focal_Error Focal_HostMemory Focal_Memory Focal_NoDebug Focal_Profile Focal_Query Focal_Setup Focal_Utils Contents Variables errStringLen fclAllocationSize CL_PLATFORM_NOT_FOUND_KHR NV_ILLEGAL_BUFFER_READ_WRITE fclDefaultCmdQ fclDefaultCtx fclLastWriteEvent fclLastReadEvent fclLastCopyEvent fclLastKernelEvent fclLastBarrierEvent fclKernelStart fclKernelEnd fclErrorHandler fclHostPtrMap Interfaces fclGetErrorString fclHandleError fclHandleBuildError fclDefaultErrorHandler fclRuntimeError fclAllocHost fclFreeHost assignment(=) fclBufferSwap fclInitBuffer fclInitSubBuffer fclMemWriteScalar fclMemWriteScalarInt32 fclMemWriteScalarFloat fclMemWriteScalarDouble fclMemWrite fclMemWriteInt32 fclMemWriteFloat fclMemWriteDouble fclMemRead fclMemReadInt32 fclMemReadFloat fclMemReadDouble fclMemCopy fclMemCopyInt32 fclMemCopyFloat fclMemCopyDouble fclFreeBuffer fclGetPlatformInfo fclGetDeviceInfo fclGetKernelInfo fclGetKernelWorkGroupInfo fclGetKernelArgInfo fclGetEventInfo fclGetPlatforms fclGetPlatform fclGetPlatformDevices fclGetDevice fclCreateContext fclFilterDevices fclInit fclSetDefaultContext fclFindDevices fclCreateCommandQ fclCreateCommandQPool fclCommandQPool_Next fclCommandQPool_Current fclSetDefaultCommandQ fclCompileProgram fclDumpBuildLog fclGetProgramKernel fclLaunchKernelAfter fclLocalInt32 fclLocalFloat fclLocalDouble fclLaunchKernel fclProcessKernelArgs fclSetKernelArgs fclSetKernelArg fclReleaseKernel fclBarrier fclWait assignment(=) fclReleaseEvent fclRetainEvent fclSetDependency fclPopDependencies fclClearDependencies fclCreateUserEvent fclSetUserEvent fclGetEventDurations fclProfilerAdd fclEnableProfiling fclPushProfileEvent fclDumpProfileData fclDumpKernelProfileData fclDumpBufferProfileData fclDumpTracingData fclDbgOptions fclDbgCheckContext fclDbgCheckDevice fclDbgCheckBufferInit fclDbgCheckBufferSize fclDbgCheckCopyBufferSize fclDbgCheckKernelNArg fclDbgCheckKernelArgType fclDbgCheckKernelArgQualifier fclDbgWait fclGetKernelResource fclSourceFromFile strStripNum Abstract Interfaces fclHandleErrorInterface Derived Types fclDevice fclPlatform fclContext fclEvent fclCommandQ fclCommandQPool fclProgram fclKernelPointer fclBufferPointer fclProfiler fclProfileContainer fclKernel fclDeviceBuffer fclDeviceInt32 fclDeviceFloat fclDeviceDouble fclLocalArgument fclLocalArgInt32 fclLocalArgFloat fclLocalArgDouble Variables Type Visibility Attributes Name Initial integer, public, parameter :: errStringLen = 50 Max length of OpenCL error code strings integer, public, parameter :: fclAllocationSize = 10 Default allocation increment for dynamically growing lists integer, public, parameter :: CL_PLATFORM_NOT_FOUND_KHR = -1001 Extension error: No valid ICDs found integer, public, parameter :: NV_ILLEGAL_BUFFER_READ_WRITE = -9999 Vendor error: Illegal read or write to a buffer in NDRangeKernel type( fclCommandQ ), public, target :: fclDefaultCmdQ Default command queue: used when command queue is omittetd in focal api calls type( fclContext ), public, target :: fclDefaultCtx Default context: used when context is omittetd in focal api calls type( fclEvent ), public, target :: fclLastWriteEvent Focal event object for the most recent write event (host-to-device) to be enqueued type( fclEvent ), public, target :: fclLastReadEvent Focal event object for the most recent read event (device-to-host) to be enqueued type( fclEvent ), public, target :: fclLastCopyEvent Focal event object for the most recent copy event (device-to-device) to be enqueued type( fclEvent ), public, target :: fclLastKernelEvent Focal event object for the most recent kernel event to be enqueued type( fclEvent ), public, target :: fclLastBarrierEvent Focal event object for the most recent barrier event to be enqueued character(kind=c_char, len=1), public, target, bind(C,name=\"0\") :: fclKernelStart c interoperable character for start of fclKernels binary resource character(kind=c_char, len=1), public, target, bind(C,name=\"0\") :: fclKernelEnd c interoperable character for sendtart of fclKernels binary resource procedure( fclHandleErrorInterface ), public, pointer :: fclErrorHandler => NULL() Procedure pointer for custom OpenCL runtime error handler integer(kind=c_intptr_t), public, allocatable :: fclHostPtrMap (:,:) Map allocated host pointers to cl_buffer pointers (needed for deallocation) Interfaces interface public module function fclGetErrorString(errcode) result(errstr) Return the text representation for an openCL error code Arguments Type Intent Optional Attributes Name integer, intent(in) :: errcode OpenCL API error code Return Value character(len=errStringLen) Returns OpenCL error string interface public module subroutine fclHandleError(errcode, focalCall, oclCall) Wrapper to invoke fclErrorHandle procedure pointer (fixes issue with ifort) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: errcode character(len=*), intent(in) :: focalCall character(len=*), intent(in) :: oclCall interface public module subroutine fclHandleBuildError(builderrcode, prog, ctx) Check an openCL error code and print build log if necessary Arguments Type Intent Optional Attributes Name integer, intent(in) :: builderrcode OpenCL API error code type( fclProgram ), intent(in) :: prog Focal program object type( fclContext ), intent(in) :: ctx Focal context object interface public module subroutine fclDefaultErrorHandler(errcode, focalCall, oclCall) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: errcode character(len=*), intent(in) :: focalCall character(len=*), intent(in) :: oclCall interface public module subroutine fclRuntimeError(descrip) Stop and print message for Focal errors not caused by openCL API call Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: descrip Description of current API call public        interface fclAllocHost Generic interface for allocating host arrays using \n 'pinned' (non-paged) memory. This is required for asynchronous transfers. Currently implements interfaces for 1D and 2D int32, float and double arrays. Note This is a blocking command. Execution waits on host until map is complete Example: Allocate a 1D integer array with 100 elements integer, pointer :: hostArray(:) call fclAllocHost(cmdq,hostArray,100) NB: cmdq is optional, if omitted then the default command queue is used public module subroutine fclAllocHostPtr_1(cmdq, hostPtr, nBytes) Allocate a 'pinned' (non-paged) host array Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory type(c_ptr), intent(out) :: hostPtr c pointer to allocated host memory integer(kind=c_int64_t), intent(in) :: nBytes Desired array size in bytes public module subroutine fclAllocHostPtr_2(hostPtr, nBytes) Allocate a 'pinned' (non-paged) host array on default cmdq Arguments Type Intent Optional Attributes Name type(c_ptr), intent(out) :: hostPtr c pointer to allocated host memory integer(kind=c_int64_t), intent(in) :: nBytes Desired array size in bytes public module subroutine fclAllocHostInt32D1_1(cmdq, hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit integers Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostInt32D1_2(hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit integers on default cmdq Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostFloatD1_1(cmdq, hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit reals Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory real(kind=c_Float), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostFloatD1_2(hostPtr, dim) Allocate a 1D 'pinned' host array for 32bit reals on default cmdq Arguments Type Intent Optional Attributes Name real(kind=c_Float), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostDoubleD1_1(cmdq, hostPtr, dim) Allocate a 1D 'pinned' host array for 64bit reals Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq Command Q with which to associate the allocated device memory real(kind=c_Double), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public module subroutine fclAllocHostDoubleD1_2(hostPtr, dim) Allocate a 1D 'pinned' host array for 64bit reals on default cmdq Arguments Type Intent Optional Attributes Name real(kind=c_Double), intent(inout), pointer :: hostPtr (:) Host array pointer to allocate integer, intent(in) :: dim Size of array to allocate public        interface fclFreeHost Generic interface to free pinned host pointer Note This is a blocking command. Execution waits on host until unmap is complete public module subroutine fclFreeHostPtr_1(cmdq, hostPtr) Enqueue unmap/free command to specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq type(c_ptr), intent(in) :: hostPtr public module subroutine fclFreeHostPtr_2(hostPtr) Enqueue unmap/free command to default command queue Arguments Type Intent Optional Attributes Name type(c_ptr), intent(inout) :: hostPtr public module subroutine fclFreeHostInt32_1(cmdq, hostPtr) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostInt32_2(hostPtr) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostFloat_1(cmdq, hostPtr) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq real(kind=c_float), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostFloat_2(hostPtr) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostDouble_1(cmdq, hostPtr) Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq real(kind=c_double), intent(inout), pointer :: hostPtr (:) public module subroutine fclFreeHostDouble_2(hostPtr) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), pointer :: hostPtr (:) public        interface assignment(=) Generic interface for assignment of fclBuffer objects by operator-overloading public  interface fclMemWriteScalarInt32 () Arguments None public  interface fclMemWriteScalarFloat () Arguments None public  interface fclMemWriteScalarDouble () Arguments None public  interface fclMemWriteInt32 () Arguments None public  interface fclMemWriteFloat () Arguments None public  interface fclMemWriteDouble () Arguments None public  interface fclMemReadInt32 () Arguments None public  interface fclMemReadFloat () Arguments None public  interface fclMemReadDouble () Arguments None public  interface fclMemCopyInt32 () Arguments None public  interface fclMemCopyFloat () Arguments None public  interface fclMemCopyDouble () Arguments None interface public module subroutine fclBufferSwap(memObject1, memObject2) Helper routine for swapping device buffer pointers.\nAlso swaps the command queue pointers associated with each buffer if different. Note The debug build will throw an error if either buffer is uninitialised\n       or if the buffers do not match in size. Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout) :: memObject1 Buffer objects with which to swap pointers class( fclDeviceBuffer ), intent(inout) :: memObject2 Buffer objects with which to swap pointers public        interface fclInitBuffer Generic interface to initialise buffers on the device public module subroutine fclInitBufferUntyped_1(cmdq, buffer, nBytes, profileName, access) Initialise untyped buffer object on specified command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceBuffer ), intent(inout) :: buffer Focal memory object to initialise integer(kind=c_size_t), intent(in) :: nBytes Size of buffer in bytes character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferUntyped_2(buffer, nBytes, profileName, access) Initialise untyped buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceBuffer ), intent(inout) :: buffer Focal memory object to initialise integer(kind=c_size_t), intent(in) :: nBytes Size of buffer in bytes character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferFloat_1(cmdq, buffer, dim, profileName, access) Initialise float buffer object on specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceFloat ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferFloat_2(buffer, dim, profileName, access) Initialise float buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceFloat ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferDouble_1(cmdq, buffer, dim, profileName, access) Initialise double buffer object on specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceDouble ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferDouble_2(buffer, dim, profileName, access) Initialise double buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceDouble ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferInt32_1(cmdq, buffer, dim, profileName, access) Initialise 32bit integer buffer object on specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceInt32 ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitBufferInt32_2(buffer, dim, profileName, access) Initialise 32bit integer buffer object on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceInt32 ), intent(inout) :: buffer Focal memory object to initialise integer, intent(in) :: dim Dimension of buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public        interface fclInitSubBuffer Generic interface to initialise sub-buffers on the device public module subroutine fclInitSubBufferUntyped_1(cmdq, subBuffer, sourceBuffer, offset, size, profileName, access) Initialise an untyped sub-buffer from an existing buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceBuffer ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer class( fclDeviceBuffer ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer(kind=c_size_t), intent(in) :: offset Offset in bytes of sub-buffer within sourceBuffer integer(kind=c_size_t), intent(in) :: size Size in bytes of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferUntyped_2(subBuffer, sourceBuffer, offset, size, profileName, access) Initialise an untyped sub-buffer from an existing buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceBuffer ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer class( fclDeviceBuffer ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer(kind=c_size_t), intent(in) :: offset Offset in bytes of sub-buffer within sourceBuffer integer(kind=c_size_t), intent(in) :: size Size in bytes of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferFloat_1(cmdq, subBuffer, sourceBuffer, start, length, profileName, access) Initialise a float sub-buffer from an existing float buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceFloat ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceFloat ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferFloat_2(subBuffer, sourceBuffer, start, length, profileName, access) Initialise a float sub-buffer from an existing float buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceFloat ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceFloat ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferDouble_1(cmdq, subBuffer, sourceBuffer, start, length, profileName, access) Initialise a double sub-buffer from an existing float buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceDouble ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceDouble ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferDouble_2(subBuffer, sourceBuffer, start, length, profileName, access) Initialise a double sub-buffer from an existing float buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceDouble ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceDouble ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferint32_1(cmdq, subBuffer, sourceBuffer, start, length, profileName, access) Initialise a 32bit integer sub-buffer from an existing float buffer Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in), target :: cmdq Queue with which to associate new buffer type( fclDeviceInt32 ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceInt32 ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only public module subroutine fclInitSubBufferint32_2(subBuffer, sourceBuffer, start, length, profileName, access) Initialise a 32bit integer sub-buffer from an existing float buffer on the default command queue Arguments Type Intent Optional Attributes Name type( fclDeviceInt32 ), intent(inout) :: subBuffer Focal memory object to initialise as new sub-buffer type( fclDeviceInt32 ), intent(inout) :: sourceBuffer Focal memory object in which to create sub-buffer integer, intent(in) :: start Zero-based start element of sub-buffer within sourceBuffer integer, intent(in) :: length Length (no. of elements) of sub-buffer character(len=*), intent(in), optional :: profileName Descriptive name for profiling output character(len=*), intent(in), optional :: access Read/write access of kernels to buffer\n'rw' = read&write (default), 'r'=read-only, 'w'=write-only interface public module subroutine fclMemWriteScalar(memObject, hostBufferPtr, nBytesPattern) Fill device buffer with scalar pattern Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout), target :: memObject Focal memory object to fill type(c_ptr), intent(in) :: hostBufferPtr C Pointer to host scalar patter integer(kind=c_size_t), intent(in) :: nBytesPattern Size of scalar pattern in bytes interface public module subroutine fclMemWriteScalarInt32(memObject, hostValue) Assign a scalar integer to a device integer memory buffer\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceInt32 ), intent(inout) :: memObject Focal memory object to fill integer(kind=c_int32_t), intent(in), target :: hostValue Host value with which to fill interface public module subroutine fclMemWriteScalarFloat(memObject, hostValue) Assign a scalar float to a device float memory buffer\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceFloat ), intent(inout) :: memObject Focal memory object to fill real(kind=c_float), intent(in), target :: hostValue Host value with which to fill interface public module subroutine fclMemWriteScalarDouble(memObject, hostValue) Assign a scalar double to a device double memory buffer\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceDouble ), intent(inout) :: memObject Focal memory object to fill real(kind=c_double), intent(in), target :: hostValue Host value with which to fill interface public module subroutine fclMemWrite(memObject, hostBufferPtr, nBytes) Transfer host buffer to device buffer Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout), target :: memObject Focal memory object (target) type(c_ptr), intent(in) :: hostBufferPtr C Pointer to host array (source) integer(kind=c_size_t), intent(in) :: nBytes Size of buffers in bytes interface public module subroutine fclMemWriteInt32(memObject, hostBuffer) Transfer host integer array to device integer array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceInt32 ), intent(inout) :: memObject Focal memory object (target) integer(kind=c_int32_t), intent(in), target :: hostBuffer (:) Host array (source) interface public module subroutine fclMemWriteFloat(memObject, hostBuffer) Transfer host float array to device float array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceFloat ), intent(inout) :: memObject Focal memory object (target) real(kind=c_float), intent(in), target :: hostBuffer (:) Host array (source) interface public module subroutine fclMemWriteDouble(memObject, hostBuffer) Transfer host double array to device double array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceDouble ), intent(inout) :: memObject Focal memory object (target) real(kind=c_double), intent(in), target :: hostBuffer (:) Host array (source) interface public module subroutine fclMemRead(hostBufferPtr, memObject, nBytes) Transfer device buffer to host buffer Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: hostBufferPtr C pointer to host buffer (target) class( fclDeviceBuffer ), intent(in), target :: memObject Focal memory object (source) integer(kind=c_size_t), intent(in) :: nBytes Size of buffers in bytes interface public module subroutine fclMemReadInt32(hostBuffer, memObject) Transfer device integer array to host integer array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(inout), target :: hostBuffer (:) Host array (target) class( fclDeviceInt32 ), intent(in) :: memObject Focal memory object (source) interface public module subroutine fclMemReadFloat(hostBuffer, memObject) Transfer device float array to host float array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name real(kind=c_float), intent(inout), target :: hostBuffer (:) Host array (target) class( fclDeviceFloat ), intent(in) :: memObject Focal memory object (source) interface public module subroutine fclMemReadDouble(hostBuffer, memObject) Transfer device double array to host double array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name real(kind=c_double), intent(inout), target :: hostBuffer (:) Host array (target) class( fclDeviceDouble ), intent(in) :: memObject Focal memory object (source) interface public module subroutine fclMemCopy(memObject1, memObject2) Transfer device buffer to device buffer Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceBuffer ), intent(in) :: memObject2 Focal memory object (source) interface public module subroutine fclMemCopyInt32(memObject1, memObject2) Transfer device integer array to device integer array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceInt32 ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceInt32 ), intent(in) :: memObject2 Focal memory object (source) interface public module subroutine fclMemCopyFloat(memObject1, memObject2) Transfer device float array to device float array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceFloat ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceFloat ), intent(in) :: memObject2 Focal memory object (source) interface public module subroutine fclMemCopyDouble(memObject1, memObject2) Transfer device double array to device double array\n Called by operator-overloading of assignment(=) Arguments Type Intent Optional Attributes Name class( fclDeviceDouble ), intent(inout), target :: memObject1 Focal memory object (target) class( fclDeviceDouble ), intent(in) :: memObject2 Focal memory object (source) interface public module subroutine fclFreeBuffer(memObject) Release device memory associated with memObject Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ) :: memObject interface public module subroutine fclGetPlatformInfo(platform, key, value) Query platform information.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclPlatform ), intent(in) :: platform integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public        interface fclGetDeviceInfo Generic interface to query device information.\nSee clGetDeviceInfo for values of 'key' argument contained in clfortran module. public module subroutine fclGetDeviceInfoString(device, key, value) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public module subroutine fclGetDeviceInfoInt32(device, key, value) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value public module subroutine fclGetDeviceInfoInt64(device, key, value) Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int64_t), intent(out), target :: value public        interface fclGetKernelInfo Generic interface to query kernel information.\nSee clGetDeviceInfo for values of 'key' argument contained in clfortran module. public module subroutine fclGetKernelInfoString(kernel, key, value) Query kernel information for string info.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public module subroutine fclGetKernelInfoInt32(kernel, key, value) Query kernel information for 32bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value public        interface fclGetKernelWorkGroupInfo public module subroutine fclGetKernelWorkGroupInfoInt64(kernel, device, key, value) Query kernel work group information for 64bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel type( fclDevice ), intent(in) :: device integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int64_t), intent(out), target :: value public        interface fclGetKernelArgInfo Generic interface to query kernel argument information.\nSee clGetDeviceInfo for values of 'key' argument contained in clfortran module. public module subroutine fclGetKernelArgInfoString(kernel, argNo, key, value) Query kernel information for string info.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo integer(kind=c_int32_t), intent(in) :: key character(len=:), intent(out), allocatable, target :: value public module subroutine fclGetKernelArgInfoInt32(kernel, argNo, key, value) Query kernel information for 32bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value interface public module subroutine fclGetEventInfo(event, key, value) Query kernel information for 32bit integer.\nSee clGetPlatformInfo for values of 'key' argument containined in clfortran module. Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event integer(kind=c_int32_t), intent(in) :: key integer(kind=c_int32_t), intent(out), target :: value interface public module function fclGetPlatforms() result(platforms) Return pointer to array of available fclPlatforms Arguments None Return Value type( fclPlatform ), allocatable, (:) interface public module function fclGetPlatform(platform_id) result(platform) Return fclPlatform object for OpenCL platform id Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: platform_id OpenCL platform id Return Value type( fclPlatform ), target interface public module function fclGetPlatformDevices(platform_id) result(devices) Return pointer to array of fclDevices on platform id Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: platform_id OpenCL platform id Return Value type( fclDevice ), allocatable, (:) interface public module function fclGetDevice(device_id) result(device) Return fclDevice for OpenCL device id Arguments Type Intent Optional Attributes Name integer(kind=c_intptr_t), intent(in) :: device_id OpenCL device id Return Value type( fclDevice ), target public        interface fclCreateContext Generic interface to create a context public module function fclCreateContextWithPlatform(platform) result(ctx) Create a context with fclPlatform object Arguments Type Intent Optional Attributes Name type( fclPlatform ), intent(inout), target :: platform Return Value type( fclContext ), target public module function fclCreateContextWithVendor(vendor) result(ctx) Create a context with the first platform where the vendor property\n contains a specified string (case-insensitive). Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: vendor String with which to match platform vendor. Separate multiple vendors\n with commas. First matching vendor in list is used.\n Matching is case-insensitive substring. e.g. vendor='i' matches 'nvidia' and 'intel' platforms e.g. vendor='nvidia,intel' matches nvidia platform if available,\n then intel platform if available, then fails fatally if neither\n are available. Return Value type( fclContext ), target interface public module function fclFilterDevices(devices, vendor, type, nameLike, extensions, sortBy) result(deviceList) Filter and sort list of devices based on criteria Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: devices (:) character(len=*), intent(in), optional :: vendor Filter device list based on platform vendor.\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ), allocatable, (:) Filtered and sorted list. Unallocated if no matching devices found. interface public module function fclInit(vendor, type, nameLike, extensions, sortBy) result(device) Quick setup helper function: find a single device based on criteria\n and set the default context accordingly.\n Raises runtime error if no matching device is found. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: vendor Filter device based on platform vendor\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ), allocatable The device chosen based on the user criteria interface public module subroutine fclSetDefaultContext(ctx) Set the global default context Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in) :: ctx public        interface fclFindDevices Generic interface to list devices, sorted and filtered by properties\n Raises runtime error if no matching device is found. public module function fclFindDevices_1(ctx, vendor, type, nameLike, extensions, sortBy) result(deviceList) Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx Context containing device for command queue character(len=*), intent(in), optional :: vendor Filter device list based on platform vendor.\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ), allocatable, (:) public module function fclFindDevices_2(vendor, type, nameLike, extensions, sortBy) result(deviceList) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: vendor Filter device list based on platform vendor.\n Specify multiple possible vendors in comma-separate list character(len=*), intent(in), optional :: type Filter device list based on device type.\nSpecify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character(len=*), intent(in), optional :: nameLike Filter devices based on device name. Look for this substring in device name. character(len=*), intent(in), optional :: extensions Filter devices based on supported device extensions.\nSpecify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64.\nSee clGetDeviceInfo Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character(len=*), intent(in), optional :: sortBy Sort device list based on either 'memory': total global memory,\n 'cores': total number of compute units, 'clock': maximum clock speed Return Value type( fclDevice ), allocatable, (:) public        interface fclCreateCommandQ Generic interface to create a device command queue public module function fclCreateCommandQ_1(ctx, device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(cmdq) Create a command queue with a Focal device object Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx Context containing device for command queue type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQ ) Returns fclCommandQ object public module function fclCreateCommandQ_2(device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(cmdq) Create a command queue with a Focal device object using default context Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQ ) Returns fclCommandQ object public        interface fclCreateCommandQPool Generic interface to create a pool of command queues public module function fclCreateCommandQPool_1(ctx, N, device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(qPool) Create a command queue pool with a Focal device object Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx Context containing device for command queue integer, intent(in) :: N Number of command queues to create in pool type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQPool ) Returns fclCommandQPool object public module function fclCreateCommandQPool_2(N, device, enableProfiling, outOfOrderExec, blockingWrite, blockingRead) result(qPool) Create a command queue pool with a Focal device object using default context Arguments Type Intent Optional Attributes Name integer, intent(in) :: N Number of command queues to create in pool type( fclDevice ), intent(inout), target :: device Device on which to create command queue logical, intent(in), optional :: enableProfiling Enable OpenCL profiling logical, intent(in), optional :: outOfOrderExec Enable out of order execution logical, intent(in), optional :: blockingWrite Enable/disable host-blocking write to device logical, intent(in), optional :: blockingRead Enable/disable host-blocking read from device Return Value type( fclCommandQPool ) Returns fclCommandQPool object interface public module function fclCommandQPool_Next(qPool) result(cmdQ) Returns next scheduled queue in queue pool Arguments Type Intent Optional Attributes Name class( fclCommandQPool ), intent(inout), target :: qPool Return Value type( fclCommandQ ), pointer interface public module function fclCommandQPool_Current(qPool) result(cmdQ) Returns current scheduled queue in queue pool Arguments Type Intent Optional Attributes Name class( fclCommandQPool ), intent(in), target :: qPool Return Value type( fclCommandQ ), pointer interface public module subroutine fclSetDefaultCommandQ(cmdq) Set the global default command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq public        interface fclCompileProgram Generic interface to compile an openCL program public module function fclCompileProgram_1(ctx, source, options) result(prog) Compile program source on context ctx Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in), target :: ctx character(len=*), intent(in) :: source Program source code character(len=*), intent(in), optional :: options OpenCL compilation options Return Value type( fclProgram ) Returns fclProgram object public module function fclCompileProgram_2(source, options) result(prog) Compile program source on fclDefaultContext Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: source Program source code character(len=*), intent(in), optional :: options OpenCL compilation options Return Value type( fclProgram ) Returns fclProgram object public        interface fclDumpBuildLog public module subroutine fclDumpBuildLog_1(ctx, prog, device, outputUnit) Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in) :: ctx type( fclProgram ), intent(in) :: prog type( fclDevice ), intent(in) :: device integer, intent(in), optional :: outputUnit public module subroutine fclDumpBuildLog_2(prog, device, outputUnit) Arguments Type Intent Optional Attributes Name type( fclProgram ), intent(in) :: prog type( fclDevice ), intent(in) :: device integer, intent(in), optional :: outputUnit interface public module function fclGetProgramKernel(prog, kernelName, global_work_size, local_work_size, work_dim, global_work_offset) result(kern) Extract a kernel object for execution from a compiled program object Arguments Type Intent Optional Attributes Name type( fclProgram ), intent(in) :: prog Compiled program object containing kernel character(len=*), intent(in) :: kernelName Name of kernel to extract for execution integer, intent(in), optional :: global_work_size (:) Global work group dimensions, default unset (must set prior to launching) integer, intent(in), optional :: local_work_size (:) Local work group dimensions, default zeros (decided by OpenCL runtime) integer, intent(in), optional :: work_dim Number of dimensions for kernel work group, default 1 integer, intent(in), optional :: global_work_offset (:) Global work group offsets, default zeros Return Value type( fclKernel ) Returns fclKernel object for execution public        interface fclLaunchKernelAfter Generic interface to launch a kernel with event dependencies public module subroutine fclLaunchKernelAfterEvent_1(kernel, cmdQ, event) Specific interface for a single event dependency on a specific command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclCommandQ ), intent(inout) :: cmdQ CmdQ on which to launch kernel type( fclEvent ), intent(in) :: event Event dependency for kernel public module subroutine fclLaunchKernelAfterEvent_2(kernel, event) Specific interface a single event dependency on the default command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclEvent ), intent(in) :: event Event dependency for kernel public module subroutine fclLaunchKernelAfterEventList_1(kernel, cmdQ, eventList) Specific interface for a multiple event dependencies on a specific command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclCommandQ ), intent(inout) :: cmdQ CmdQ on which to launch kernel type( fclEvent ), intent(in) :: eventList (:) Event dependency list for kernel public module subroutine fclLaunchKernelAfterEventList_2(kernel, eventList) Specific interface for a multiple event dependencies on the default command queue Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout) :: kernel Focal kernel object to launch type( fclEvent ), intent(in) :: eventList (:) Event dependency list for kernel interface public module function fclLocalInt32(nElem) result(localArg) Create a integer local kernel argument object for launching kernels Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElem No of array elements Return Value type( fclLocalArgInt32 ) Returns local argument object interface public module function fclLocalFloat(nElem) result(localArg) Create a float local kernel argument object for launching kernels Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElem No of array elements Return Value type( fclLocalArgFloat ) Returns local argument object interface public module function fclLocalDouble(nElem) result(localArg) Create a double local kernel argument object for launching kernels Arguments Type Intent Optional Attributes Name integer, intent(in) :: nElem No of array elements Return Value type( fclLocalArgDouble ) Returns local argument object interface public module subroutine fclLaunchKernel(kernel, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Enqueue a kernel with command arguments Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(inout), target :: kernel Focal kernel object class(*), intent(in), optional, target :: a0 Focal command queue or first kernel argument class(*), intent(in), optional, target :: a1 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument interface public module subroutine fclProcessKernelArgs(kernel, cmdq, narg, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Sets kernel arguments and parses argument list for optional cmdq and actual number of arguments. Note This is helper routine used internally by focal.  If you just want set kernel arguments\n without launching a kernel, use fclSetKernelArgs . Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(in), target :: kernel Focal kernel object type( fclCommandQ ), intent(out), pointer :: cmdq Returns a0 if it is cmdq, otherwise returns fclDefaultCommandQ integer, intent(out) :: narg Returns the actual number of arguments passed class(*), intent(in), optional, target :: a0 Focal command queue or first kernel argument class(*), intent(in), optional, target :: a1 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Subsequent kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument interface public module subroutine fclSetKernelArgs(kernel, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20, a21, a22, a23, a24, a25, a26, a27, a28, a29, a30, a31, a32, a33, a34, a35, a36, a37, a38, a39, a40, a41, a42, a43, a44, a45, a46, a47, a48, a49, a50, a51, a52, a53, a54, a55, a56, a57, a58, a59, a60, a61, a62, a63, a64, a65, a66, a67, a68, a69, a70, a71, a72, a73, a74, a75, a76, a77, a78, a79, a80, a81, a82, a83, a84, a85, a86, a87, a88, a89, a90, a91, a92, a93, a94, a95, a96, a97, a98, a99) Set all kernel arguments at once without launching kernel. Arguments Type Intent Optional Attributes Name class( fclKernel ), intent(in), target :: kernel Focal kernel object class(*), intent(in), optional, target :: a0 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a1 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a2 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a3 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a4 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a5 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a6 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a7 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a8 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a9 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a10 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a11 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a12 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a13 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a14 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a15 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a16 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a17 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a18 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a19 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a20 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a21 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a22 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a23 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a24 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a25 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a26 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a27 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a28 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a29 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a30 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a31 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a32 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a33 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a34 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a35 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a36 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a37 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a38 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a39 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a40 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a41 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a42 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a43 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a44 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a45 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a46 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a47 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a48 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a49 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a50 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a51 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a52 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a53 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a54 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a55 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a56 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a57 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a58 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a59 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a60 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a61 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a62 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a63 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a64 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a65 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a66 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a67 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a68 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a69 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a70 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a71 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a72 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a73 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a74 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a75 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a76 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a77 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a78 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a79 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a80 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a81 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a82 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a83 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a84 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a85 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a86 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a87 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a88 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a89 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a90 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a91 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a92 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a93 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a94 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a95 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a96 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a97 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a98 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument class(*), intent(in), optional, target :: a99 Kernel arguments.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument interface public module subroutine fclSetKernelArg(kernel, argIndex, argValue) Set or change a single kernel argument Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel Focal kernel object integer(kind=c_int32_t), intent(in) :: argIndex Index of kernel argument to set class(*), intent(in), target :: argValue Value of kernel argument.\nCan be a scalar, an fclDeviceBuffer object, or an fclLocalArgument interface public module subroutine fclReleaseKernel(kernel) Release OpenCL memory associated with underlying kernel pointer Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(inout) :: kernel Focal kernel object public        interface fclBarrier Generic interface to enqueue a command queue barrier\n Wait on device for all preceding queue events to complete before\n subsequent events can proceed. public module subroutine fclBarrier_1(cmdq) Enqueue barrier on all events in command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(inout), target :: cmdq public module subroutine fclBarrier_2() Enqueue barrier on all events in default command queue Arguments None public        interface fclWait Generic interface to wait on host for events public module subroutine fclFinish_1(cmdq) Wait on host for all events in user-specified command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(in) :: cmdq public module subroutine fclFinish_2() Wait on host for all events in focal default command queue Arguments None public module subroutine fclFinish_3(qPool) Wait on host for all events in all queues in a queue pool Arguments Type Intent Optional Attributes Name type( fclCommandQPool ), intent(in) :: qPool public module subroutine fclWaitEvent(event) Wait on host for a specific event Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in), target :: event public module subroutine fclWaitEventList(eventList) Wait on host for set of events Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in), target :: eventList (:) public        interface assignment(=) public module subroutine fclEventCopy(target, source) Overloaded assignment for event assignment.\n Handles opencl reference counting for the underlying event object Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(inout) :: target type( fclEvent ), intent(in) :: source interface public module subroutine fclReleaseEvent(event) Light weight wrapper for clReleaseEvent (decrement reference count) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event Focal event object to release interface public module subroutine fclRetainEvent(event) Light weight wrapper for clRetainEvent (increment reference count) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event Focal event object to retain public        interface fclSetDependency Generic interface to set pre-requisite events for the next enqueued action.\n This does not append to any existing dependencies - it overwrites the dependency list. public module subroutine fclSetDependencyEvent_1(cmdQ, event, hold) Interface for specifying a single event dependency on specific cmdq Arguments Type Intent Optional Attributes Name type( fclCommandQ ), target :: cmdQ Command queue type( fclEvent ), intent(in) :: event Event dependency logical, intent(in), optional :: hold Hold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. public module subroutine fclSetDependencyEvent_2(event, hold) Interface for specifying a single event dependency on default cmdq Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: event Event dependency logical, intent(in), optional :: hold Hold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. public module subroutine fclSetDependencyEventList_1(cmdQ, eventList, hold) Interface for specifying a list of dependent events on specific cmdq Arguments Type Intent Optional Attributes Name type( fclCommandQ ), target :: cmdQ Command queue type( fclEvent ), intent(in) :: eventList (:) List of event dependencies logical, intent(in), optional :: hold Hold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. public module subroutine fclSetDependencyEventList_2(eventList, hold) Interface for specifying a list of dependent events on default cmdq Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: eventList (:) List of event dependencies logical, intent(in), optional :: hold Event dependency\nHold dependency list: set to true to not automatically clear dependencies after enqueueing.\n Use for applying the same dependency to multiple commands. Default false. interface public module subroutine fclPopDependencies(cmdq) Called after every enqueue operation:\nClear dependencies unless dependency hold is .true. Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(inout) :: cmdq public        interface fclClearDependencies Generic interface to clear dependency list and reset dependency hold to .false. public module subroutine fclClearDependencies_1(cmdq) Interface for specific command queue Arguments Type Intent Optional Attributes Name type( fclCommandQ ), intent(inout) :: cmdq public module subroutine fclClearDependencies_2() Interface for default command queueu Arguments None public        interface fclCreateUserEvent Generic interface to create a user event public module function fclCreateUserEvent_1(ctx) result(userEvent) Create user event in a specific context Arguments Type Intent Optional Attributes Name type( fclContext ), intent(in) :: ctx Return Value type( fclEvent ) public module function fclCreateUserEvent_2() result(userEvent) Create user event in the default context Arguments None Return Value type( fclEvent ) interface public module subroutine fclSetUserEvent(event, stat) Set status of a user event Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(inout) :: event integer(kind=c_int32_t), intent(in), optional :: stat interface public module function fclGetEventDurations(eventList) result(durations) Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in) :: eventList (:) Return Value integer(kind=c_int64_t), (size(eventList,1)) interface public module subroutine fclProfilerAdd(profiler, profileSize, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9) Enable profiling for multiple container (kernel/buffer) and add to profiler collection Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(inout) :: profiler Profiler - collection of objects to profile integer, intent(in) :: profileSize Number of events to save for profiling (allocation size) class( fclProfileContainer ), intent(inout), target :: c0 Object (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c1 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c2 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c3 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c4 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c5 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c6 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c7 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c8 Subsequent objects (kernel/buffer) for which to enable profiling class( fclProfileContainer ), intent(inout), optional, target :: c9 Subsequent objects (kernel/buffer) for which to enable profiling interface public module subroutine fclEnableProfiling(container, profileSize, profiler) Enable profiling on a specific container by allocating space to save events Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(inout), target :: container Container on which to enable profiling. This can be one of: fclKernel , fclDeviceBuffer , fclProfileContainer . integer, intent(in) :: profileSize Number of events to allocate space for type( fclProfiler ), intent(inout), optional :: profiler Profiler collection object to which to add the kernel/buffer. interface public module subroutine fclPushProfileEvent(container, event, type) If profiling is enabled for the container, save an event to it Arguments Type Intent Optional Attributes Name class( fclProfileContainer ), intent(in) :: container Profiling container ( fclKernel , fclDeviceBuffer , fclProfileContainer ) type( fclEvent ), intent(in) :: event Event to push to container integer, intent(in), optional :: type For buffer object events only, indicates transfer type interface public module subroutine fclDumpProfileData(profiler, outputUnit) Dump summary of profiler data for list of kernels to specific output unit Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(in) :: profiler Profiler object containing collection of kernels & buffers to profile integer, intent(in), optional :: outputUnit Output unit to write summary data interface public module subroutine fclDumpKernelProfileData(outputUnit, kernelList, device) Dump summary of profile data for list of kernels to specific output unit Arguments Type Intent Optional Attributes Name integer, intent(in) :: outputUnit Output unit to write summary data class( fclKernel ), intent(in) :: kernelList (:) List of kernels for which to dump profile data type( fclDevice ), intent(in) :: device Device on which the kernels were executed\nNeeded for kernel work group info. interface public module subroutine fclDumpBufferProfileData(outputUnit, bufferList1, bufferList2, bufferList3) Dump summary of profile data for list of buffers to specific output unit. Three buffer list inputs are provided for different buffer types Arguments Type Intent Optional Attributes Name integer, intent(in) :: outputUnit Output unit to write summary data. class( fclDeviceBuffer ), intent(in), target :: bufferList1 (:) List of buffers for which to dump profile data class( fclDeviceBuffer ), intent(in), optional, target :: bufferList2 (:) List of buffers for which to dump profile data class( fclDeviceBuffer ), intent(in), optional, target :: bufferList3 (:) List of buffers for which to dump profile data interface public module subroutine fclDumpTracingData(profiler, filename) Writes a chrome://tracing data format for profiled events Arguments Type Intent Optional Attributes Name class( fclProfiler ), intent(in) :: profiler Profiler collection object containing kernels/buffers that have been profiled character(len=*), intent(in) :: filename Filename to which to write chrome://tracing format interface public module function fclDbgOptions() result(options) Returns OpenCL compile options as interoperable string for debug mode Note Debug routine: only executed for debug build. Arguments None Return Value character(len=:), allocatable interface public module subroutine fclDbgCheckContext(descrip, ctx) Check the (default) context is initialised.\nAssumes uninitialised contexts have cl_context = -1. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: descrip Description of program location for error output type( fclContext ), intent(in), optional :: ctx Context to test. Uses fclDefaultContext if not present. interface public module subroutine fclDbgCheckDevice(device, descrip) Check a device object is valid\nAssumes uninitialised devices have cl_device_id = -1. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name type( fclDevice ), intent(in) :: device Device object to check character(len=*), intent(in) :: descrip Description of program location for error output interface public module subroutine fclDbgCheckBufferInit(memObject, descrip) Check that a device buffer object has been initialised. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(in) :: memObject character(len=*), intent(in) :: descrip interface public module subroutine fclDbgCheckBufferSize(memObject, hostBytes, descrip) Check that a host buffer matches the size in bytes of a device buffer. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(in) :: memObject integer(kind=c_size_t), intent(in) :: hostBytes character(len=*), intent(in) :: descrip interface public module subroutine fclDbgCheckCopyBufferSize(memObject1, memObject2) Check that a host buffer matches the size in bytes of a device buffer. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name class( fclDeviceBuffer ), intent(in) :: memObject1 class( fclDeviceBuffer ), intent(in) :: memObject2 interface public module subroutine fclDbgCheckKernelNArg(kernel, nArg) Check that number of actual args matches number of kernel args. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: nArg interface public module subroutine fclDbgCheckKernelArgType(kernel, argNo, type) Checks the types of arguments passed to kernels Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo character(len=*), intent(in) :: type interface public module subroutine fclDbgCheckKernelArgQualifier(kernel, argNo, qualifier) Checks the address qualifier of arguments passed to kernels. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name type( fclKernel ), intent(in) :: kernel integer, intent(in) :: argNo character(len=*), intent(in) :: qualifier interface public module subroutine fclDbgWait(event, descrip) Wait for an event to complete and check for successful completion.\nThrow runtime error if status is not CL_COMPLETE. Note Debug routine: only executed for debug build. Arguments Type Intent Optional Attributes Name type( fclEvent ), intent(in), target :: event Event object to check character(len=*), intent(in), optional :: descrip Description for debugging interface public module subroutine fclGetKernelResource(kernelString) Retrieve kernel source linked as a binary resource.\n Use linker ld to include kernel source with:\n  ld -r -b binary -o fclKernels.o fclKernels.cl\n(Object file MUST be called fclKernels.o, with no path)\nThen link resulting object file as normal Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: kernelString Kernel source as fortran character string interface public module subroutine fclSourceFromFile(filename, sourceString) Allocate and fill character string from file Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: filename character(len=:), intent(out), allocatable :: sourceString interface public module function strStripNum(linei) Return copy of string with numerical characters removed Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: linei Input string Return Value character(len=len) Converted string output Abstract Interfaces abstract interface public  subroutine fclHandleErrorInterface(errcode, focalCall, oclCall) Arguments Type Intent Optional Attributes Name integer(kind=c_int32_t), intent(in) :: errcode character(len=*), intent(in) :: focalCall character(len=*), intent(in) :: oclCall Derived Types type, public :: fclDevice Type wrapper for openCL device objects Components Type Visibility Attributes Name Initial integer(kind=c_int64_t), public :: cl_device_type Device type character(len=:), public, allocatable :: name Device name integer(kind=c_int32_t), public :: nComputeUnits Number of device compute units integer(kind=c_int64_t), public :: global_memory Total global memory, bytes integer(kind=c_int32_t), public :: clock_freq Max clock frequency, MHz character(len=:), public, allocatable :: version OpenCL version character(len=:), public, allocatable :: extensions Supported OpenCL extensions type( fclPlatform ), public, pointer :: platform Pointer to containing platform character(len=:), public, allocatable :: platformName Name of containing platform character(len=:), public, allocatable :: platformVendor Vendor of containing platform type, public :: fclPlatform Type wrapper for openCL platform objects Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profile OpenCL Profile string character(len=:), public, allocatable :: version OpenCL Version character(len=:), public, allocatable :: name Platform name character(len=:), public, allocatable :: vendor Platform vendor character(len=:), public, allocatable :: extensions Platform extensions integer, public :: numDevice No. of devices type( fclDevice ), public, allocatable :: devices (:) Focal device objects type, public :: fclContext Type wrapper for openCL context objects Components Type Visibility Attributes Name Initial integer(kind=c_intptr_t), public :: cl_context = -1 openCL context pointer type( fclPlatform ), public :: platform Focal platform object type, public :: fclEvent Type wrapper for OpenCL event pointers Components Type Visibility Attributes Name Initial integer(kind=c_intptr_t), public :: cl_event = -1 OpenCL event pointer Finalizations Procedures final :: fclReleaseEvent Decrement cl reference counter type, public :: fclCommandQ Type wrapper for openCL command queue objects Components Type Visibility Attributes Name Initial logical, public :: blockingWrite = .true. Enable/disable blocking writes when copying from host to device logical, public :: blockingRead = .true. Enable/disable block reads when copying from device to host type( fclEvent ), public :: lastWriteEvent Focal event object for the most recent write event (host-to-device) to be enqueued type( fclEvent ), public :: lastReadEvent Focal event object for the most recent read event (device-to-host) to be enqueued type( fclEvent ), public :: lastCopyEvent Focal event object for the most recent copy event (device-to-device) to be enqueued type( fclEvent ), public :: lastKernelEvent Focal event object for the most recent kernel event to be enqueued type( fclEvent ), public :: lastBarrierEvent Focal event object for the most recent barrier event to be enqueued integer(kind=c_intptr_t), public, allocatable :: dependencyList (:) List of pre-requisite events for next enqueued action.\n All events in this list are used as dependencies for the next enqueued\n  operation. At enqueueing, the list is cleared unless holdDependencies is .true. type(c_ptr), public :: dependencyListPtr = C_NULL_PTR C pointer to dependency list. C_NULL_PTR when nDependency is zero. integer, public :: nDependency = 0 Number of items in dependency list logical, public :: holdDependencies = .false. Set to true to not automatically clear dependencies after enqueueing.\nUse for applying the same dependencies to multiple commands.\nUse fclClearDependencies to clear and reset. type, public :: fclCommandQPool Collection of fclCommandQ objects with round-robin scheduling.\n Allows easy handling of multiple command queues for parallel kernels\n data transfers. Components Type Visibility Attributes Name Initial integer, public :: length Number of command queues type( fclCommandQ ), public, allocatable :: queues (:) Array of command queues integer, public :: idx = 1 Index of current command queue Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: next => fclCommandQPool_Next Interface Returns next scheduled queue in queue pool procedure\n                    ,                  public\n, pass                  :: current => fclCommandQPool_Current Interface Returns current scheduled queue in queue pool type, public :: fclProgram Type wrapper for openCL program objects type, public :: fclKernelPointer Wrapper type for implementing an array of pointers to kernel objects type, public :: fclBufferPointer Wrapper type for implementing an array of pointers to buffer objects type, public :: fclProfiler Helper type to collect objects (kernels and buffers) that\n are profiled to simply user code. Components Type Visibility Attributes Name Initial type( fclDevice ), public :: device Device for which to dump profile data Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: add => fclProfilerAdd Interface type, public :: fclProfileContainer Base container type for event profiling Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: pushProfileEvent => fclPushProfileEvent Interface type, public, extends( fclProfileContainer ) :: fclKernel Type wrapper for openCL kernel objects Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event character(len=:), public, allocatable :: name Kernel name integer(kind=c_int32_t), public :: work_dim = 1 Number of work-range dimensions integer(kind=c_size_t), public :: global_work_offset (3) = 0 Global work dimension offsets integer(kind=c_size_t), public :: global_work_size (3) = 0 Global work-range dimensions integer(kind=c_size_t), public :: local_work_size (3) = 0 Local work-group dimensions Finalizations Procedures final :: fclReleaseKernel Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: pushProfileEvent => fclPushProfileEvent Interface procedure\n                    ,                  public\n, pass                  :: setArgs => fclSetKernelArgs Interface Set kernel arguments without launching procedure\n                    ,                  public\n, pass                  :: launch => fclLaunchKernel Interface Launch the kernel generic,\n                  public\n,                   :: launchAfter =>\n                    launchKernelAfterEvent_1, launchKernelAfterEvent_2, launchKernelAfterEventList_1, launchKernelAfterEventList_2 Launch a kernel with event dependencies type, public, extends( fclProfileContainer ) :: fclDeviceBuffer Type wrapper for openCL memory objects Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: pushProfileEvent => fclPushProfileEvent Interface type, public, extends( fclDeviceBuffer ) :: fclDeviceInt32 Type wrapper for memory objects representing int32 Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: pushProfileEvent => fclPushProfileEvent Interface type, public, extends( fclDeviceBuffer ) :: fclDeviceFloat Type wrapper for memory objects representing float Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: pushProfileEvent => fclPushProfileEvent Interface type, public, extends( fclDeviceBuffer ) :: fclDeviceDouble Type wrapper for memory objects representing double Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: profileName Descriptive name for output of profiling information logical, public :: profilingEnabled = .false. Switch to enable saving of events for profiling type( fclEvent ), public, pointer :: profileEvents (:) => NULL() Array of events for profiling integer, public :: profileSize = 0 Allocation size of profileEvents(:) array integer, public, pointer :: nProfileEvent => NULL() Number of events saved to profileEvents(:) array integer, public, pointer :: profileEventType (:) => NULL() Integer for indicating type of buffer event integer(kind=c_size_t), public :: nBytes = -1 Size of buffer in bytes Type-Bound Procedures procedure\n                    ,                  public\n, pass                  :: pushProfileEvent => fclPushProfileEvent Interface type, public :: fclLocalArgument Type for specifying local kernel arguments.\n Instantiate with on of: fclLocalInt32, fclLocalFloat, fclLocalDouble Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes type, public, extends( fclLocalArgument ) :: fclLocalArgInt32 Type wrapper for local kernel arguments representing 32 bit integers Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes type, public, extends( fclLocalArgument ) :: fclLocalArgFloat Type wrapper for local kernel arguments representing floats Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes type, public, extends( fclLocalArgument ) :: fclLocalArgDouble Type wrapper for local kernel arguments representing doubles Components Type Visibility Attributes Name Initial integer(kind=c_size_t), public :: nBytes Size of local argument in bytes","tags":"","loc":"module/focal.html"},{"title":"Focal_Setup – Focal API Reference","text":"Implementation module for openCL setup routines: context, command queues and programs. Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses M_strings clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_setup.html"},{"title":"Focal_Query – Focal API Reference","text":"Implementation module for query routines Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses M_Strings clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_query.html"},{"title":"Focal_NoDebug – Focal API Reference","text":"Implementation module for focal debug routines.\n This submodule is linked in the release version of Focal build. Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses Ancestors: Focal Contents None","tags":"","loc":"module/focal_nodebug.html"},{"title":"Focal_Error – Focal API Reference","text":"Implementation module for error handling Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_error.html"},{"title":"Focal_Memory – Focal API Reference","text":"Implementation module Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_memory.html"},{"title":"Focal_Profile – Focal API Reference","text":"Implementation module for openCL profiling routines Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_profile.html"},{"title":"Focal_HostMemory – Focal API Reference","text":"Implementation module Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_hostmemory.html"},{"title":"Focal_Utils – Focal API Reference","text":"Implementation module for focal utility routines Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses Ancestors: Focal Contents None","tags":"","loc":"module/focal_utils.html"},{"title":"Focal_Debug – Focal API Reference","text":"Implementation module for focal debug routines.\n This submodule is linked in the debug version of Focal build. Note This is an implementation submodule: it contains the code implementing the subroutines defined in the\n corresponding header module file. See header module file (Focal.f90) for interface definitions. Uses clfortran Ancestors: Focal Contents None","tags":"","loc":"module/focal_debug.html"},{"title":"Focal_Setup.f90 – Focal API Reference","text":"Contents Submodules Focal_Setup Source Code Focal_Setup.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Setup !!  Implementation module for openCL setup routines: context, command queues and programs. !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran use M_strings , only : upperStr => upper , splitStr => split implicit none contains module procedure fclCreateContextWithPlatform !(platform) result(ctx) integer ( c_intptr_t ), target :: properties ( 3 ) integer ( c_int32_t ) :: errcode properties ( 1 ) = CL_CONTEXT_PLATFORM properties ( 2 ) = platform % cl_platform_id properties ( 3 ) = 0 ctx % cl_context = clCreateContext ( c_loc ( properties ), & platform % numDevice , c_loc ( platform % cl_device_ids ), & C_NULL_FUNPTR , C_NULL_PTR , errcode ) call fclHandleError ( errcode , 'fclCreateContextWithPlatform' , 'clCreateContext' ) ! platform%ctx = ctx ctx % platform = platform return end procedure fclCreateContextWithPlatform ! --------------------------------------------------------------------------- module procedure fclCreateContextWithVendor !(vendor) result(ctx) integer :: vi , i logical :: vendorFound type ( fclPlatform ), allocatable :: platforms (:) type ( fclPlatform ) :: chosenPlatform character (:), allocatable :: vendors (:) ! Get platforms platforms = fclGetPlatforms (); ! Check for multiple vendors call splitStr ( vendor , vendors , delimiters = ',' ) vendorFound = . FALSE . vendorLoop : do vi = 1 , size ( vendors , 1 ) do i = 1 , size ( platforms , 1 ) if ( index ( upperstr ( platforms ( i )% vendor ) , upperstr ( trim ( vendors ( vi ))) ) > 0 . or . & index ( upperstr ( platforms ( i )% name ) , upperstr ( trim ( vendors ( vi ))) ) > 0 ) then chosenPlatform = platforms ( i ) vendorFound = . TRUE . exit vendorLoop end if end do end do vendorLoop if ( vendorFound ) then ctx = fclCreateContextWithPlatform ( chosenPlatform ) else call fclRuntimeError ( 'fclCreateContextWithVendor: vendor(s) \"' // trim ( vendor ) // '\" was not found.' ) end if end procedure fclCreateContextWithVendor ! --------------------------------------------------------------------------- module procedure fclSetDefaultContext !(ctx) ! Set the global default context call fclDbgCheckContext ( 'fclSetDefaultContext' , ctx ) fclDefaultCtx = ctx end procedure fclSetDefaultContext ! --------------------------------------------------------------------------- module procedure fclFilterDevices !(devices,vendor,type,nameLike,extensions,sortBy) result(deviceList) !! Filter and sort list of devices based on criteria use futils_sorting , only : argsort integer :: i , j integer :: sortMetric ( size ( devices , 1 )) integer :: sortList ( size ( devices , 1 )) logical :: filter ( size ( devices , 1 )), platformMatch integer ( c_int64_t ) :: typeFilter integer ( c_int64_t ) :: deviceType integer :: nFiltered , nFill integer ( c_int64_t ) :: int64Metric character ( 3 ) :: CPU_TYPE character (:), allocatable :: extensionList (:) character (:), allocatable :: vendorList (:) CPU_TYPE = 'CPU' ! --- Parse any request to filter by device type --- typeFilter = 0 if ( present ( type )) then if ( index ( upperstr ( type ), 'CPU' ) > 0 . and . index ( upperstr ( type ), 'GPU' ) > 0 ) then typeFilter = 0 else if ( index ( upperstr ( type ), 'CPU' ) > 0 ) then typeFilter = CL_DEVICE_TYPE_CPU elseif ( index ( upperstr ( type ) , 'GPU' ) > 0 ) then typeFilter = CL_DEVICE_TYPE_GPU else call fclRuntimeError ( \"fclFindDevices: \" // & \"Unknown type specified for type argument. Expecting 'cpu' or 'gpu'.'\" ) end if end if if ( present ( extensions )) then call splitStr ( extensions , extensionList , delimiters = ',' ) end if if ( present ( vendor )) then call splitStr ( vendor , vendorList , delimiters = ',' ) end if ! --- Process the devices --- filter = . true . do i = 1 , size ( devices , 1 ) ! --- Filter by device type --- if ( typeFilter > 0 ) then call fclGetDeviceInfo ( devices ( i ), CL_DEVICE_TYPE , deviceType ) if ( deviceType /= typeFilter ) then filter ( i ) = . false . ! Filtered out by device type end if end if ! --- Filter by device extensions --- if ( allocated ( extensionList )) then do j = 1 , size ( extensionList , 1 ) if ( index ( upperstr ( devices ( i )% extensions ), & upperstr ( trim ( extensionList ( j )))) == 0 ) then filter ( i ) = . false . ! Filtered out by device extensions exit end if end do end if ! --- Filter by device platform vendor --- if ( allocated ( vendorList )) then platformMatch = . false . do j = 1 , size ( vendorList , 1 ) if ( index ( upperstr ( devices ( i )% platformName ), upperstr ( trim ( vendorList ( j )))) > 0 . or . & index ( upperstr ( devices ( i )% platformVendor ), upperstr ( trim ( vendorList ( j )))) > 0 ) then platformMatch = . true . exit end if end do filter ( i ) = filter ( i ). and . platformMatch ! Filtered out by device platform vendor end if ! --- Extract sorting metric --- if ( present ( sortBy )) then select case ( upperstr ( sortBy )) case ( 'MEMORY' ) call fclGetDeviceInfo ( devices ( i ), CL_DEVICE_GLOBAL_MEM_SIZE , int64Metric ) sortMetric ( i ) = int ( int64Metric / 1000000 , c_int32_t ) ! Convert to megabytes to avoid overflow in int32 case ( 'CORES' ) call fclGetDeviceInfo ( devices ( i ), CL_DEVICE_MAX_COMPUTE_UNITS , sortMetric ( i )) case ( 'CLOCK' ) call fclGetDeviceInfo ( devices ( i ), CL_DEVICE_MAX_CLOCK_FREQUENCY , sortMetric ( i )) end select else sortMetric ( i ) = 0 end if ! --- Filter by device name --- if ( present ( nameLike )) then if ( index ( upperstr ( devices ( i )% name ), upperstr ( nameLike )) == 0 ) then filter ( i ) = . false . ! Filtered out by device name end if end if end do ! --- Sort by sorting metric --- sortMetric = - sortMetric ! Sort descending sortList = argsort ( sortMetric ) nFiltered = count ( filter ) allocate ( deviceList ( nFiltered )) if ( nFiltered < 1 ) then return end if ! --- Output filtered sorted list of devices --- nFill = 1 do i = 1 , size ( devices , 1 ) j = sortList ( i ) if ( filter ( j )) then deviceList ( nFill ) = devices ( j ) nFill = nFill + 1 end if if ( nFill > nFiltered ) then exit end if end do end procedure fclFilterDevices ! --------------------------------------------------------------------------- module procedure fclInit !(vendor,type,nameLike,extensions,sortBy) result(device) !! Quick setup helper function: find a single device based on criteria !!  and set the default context accordingly. !!  Raises runtime error if no matching device is found. integer :: i type ( fclPlatform ) :: chosenPlatform type ( fclPlatform ), allocatable :: platforms (:) type ( fclDevice ), allocatable :: devices (:), deviceList (:) integer :: nDevice logical :: found ! Get platforms platforms = fclGetPlatforms (); ! Count total number of system devices nDevice = 0 do i = 1 , size ( platforms , 1 ) nDevice = nDevice + platforms ( i )% numDevice end do ! Concatenate device lists across platforms allocate ( devices ( nDevice )) nDevice = 0 do i = 1 , size ( platforms , 1 ) devices ( nDevice + 1 : nDevice + platforms ( i )% numDevice ) = platforms ( i )% devices (:) nDevice = nDevice + platforms ( i )% numDevice end do ! Find devices based on criteria deviceList = fclFilterDevices ( devices , vendor , type , nameLike , extensions , sortBy ) if ( size ( deviceList , 1 ) < 1 ) then call fclRuntimeError ( 'fclInit: no devices matching the specified criteria were found.' ) end if ! Choose first device in filtered, sorted list device = deviceList ( 1 ) ! Find corresponding platform for creating context found = . false . do i = 1 , size ( platforms , 1 ) if ( platforms ( i )% cl_platform_id == device % cl_platform_id ) then chosenPlatform = platforms ( i ) found = . true . exit end if end do ! Create context and set as default call fclSetDefaultContext ( fclCreateContext ( chosenPlatform )) end procedure fclInit ! --------------------------------------------------------------------------- module procedure fclFindDevices_1 !(ctx,vendor,type,nameLike,extensions,sortBy) result(deviceList) !! Create command queue by finding a device use futils_sorting , only : argsort call fclDbgCheckContext ( 'fclFindDevices' , ctx ) deviceList = fclFilterDevices ( ctx % platform % devices , vendor , type , nameLike , extensions , sortBy ) if (. not . allocated ( deviceList )) then call fclRuntimeError ( 'fclFindDevices: no devices matching the specified criteria were found.' ) end if end procedure fclFindDevices_1 ! --------------------------------------------------------------------------- module procedure fclFindDevices_2 !(type,vendor,nameLike,extensions,sortBy) result(deviceList) call fclDbgCheckContext ( 'fclFindDevices' ) deviceList = fclFindDevices_1 ( fclDefaultCtx , vendor , type , nameLike , extensions , sortBy ) end procedure fclFindDevices_2 ! --------------------------------------------------------------------------- module procedure fclCreateCommandQ_1 !(ctx,device,enableProfiling,outOfOrderExec,& !blockingWrite,blockingRead) result(cmdq) !! Create a command queue with a Focal device object integer ( c_int32_t ) :: errcode integer ( c_int64_t ) :: properties properties = 0 call fclDbgCheckContext ( 'fclCreateCommandQ' , ctx ) if ( present ( enableProfiling )) then if ( enableProfiling ) then properties = ior ( properties , CL_QUEUE_PROFILING_ENABLE ) end if end if if ( present ( outOfOrderExec )) then if ( outOfOrderExec ) then properties = ior ( properties , CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE ) end if end if if ( present ( blockingWrite )) then cmdq % blockingWrite = blockingWrite end if if ( present ( blockingRead )) then cmdq % blockingRead = blockingRead end if cmdq % cl_command_queue = clCreateCommandQueue ( ctx % cl_context , device % cl_device_id , & properties , errcode ) call fclHandleError ( errcode , 'fclCreateDeviceCommandQWithDevice' , 'clCreateCommandQueue' ) end procedure fclCreateCommandQ_1 ! --------------------------------------------------------------------------- module procedure fclCreateCommandQ_2 !(device,enableProfiling,outOfOrderExec,& !blockingWrite,blockingRead) result(cmdq) !! Create a command queue with a Focal device object using default context call fclDbgCheckContext ( 'fclCreateCommandQ' ) cmdq = fclCreateCommandQ_1 ( fclDefaultCtx , device , enableProfiling , outOfOrderExec , & blockingWrite , blockingRead ) end procedure fclCreateCommandQ_2 ! --------------------------------------------------------------------------- module procedure fclCreateCommandQPool_1 !(ctx,N,device,enableProfiling,outOfOrderExec,& ! blockingWrite,blockingRead) result(qPool) !! Create a command queue pool with a Focal device object integer :: i call fclDbgCheckContext ( 'fclCreateCommandQPool' , ctx ) qPool % length = N allocate ( qPool % queues ( N )) do i = 1 , N qPool % queues ( i ) = fclCreateCommandQ_1 ( ctx , device , enableProfiling , outOfOrderExec , & blockingWrite , blockingRead ) end do end procedure fclCreateCommandQPool_1 ! --------------------------------------------------------------------------- module procedure fclCreateCommandQPool_2 !(N,device,enableProfiling,outOfOrderExec,& ! blockingWrite,blockingRead) result(qPool) !! Create a command queue pool with a Focal device object using the default context call fclDbgCheckContext ( 'fclCreateCommandQPool' ) qPool = fclCreateCommandQPool_1 ( fclDefaultCtx , N , device , enableProfiling , outOfOrderExec ,& blockingWrite , blockingRead ) end procedure fclCreateCommandQPool_2 ! --------------------------------------------------------------------------- module procedure fclCommandQPool_Next !(qPool) result(cmdQ) !! Returns next scheduled queue in queue pool ! Increment queue index (round-robin scheduling) qPool % idx = qPool % idx + 1 qPool % idx = mod ( qPool % idx - 1 , qPool % length ) + 1 ! Return next queue cmdQ => qPool % queues ( qPool % idx ) end procedure fclCommandQPool_Next ! --------------------------------------------------------------------------- module procedure fclCommandQPool_Current !(qPool) result(cmdQ) !! Returns current scheduled queue in queue pool cmdQ => qPool % queues ( qPool % idx ) end procedure fclCommandQPool_Current ! --------------------------------------------------------------------------- module procedure fclSetDefaultCommandQ !(cmdq) !! Set the global default command queue fclDefaultCmdQ = cmdq end procedure fclSetDefaultCommandQ ! --------------------------------------------------------------------------- module procedure fclCompileProgram_1 !(ctx,source,options) result(prog) integer :: i integer ( c_int32_t ) :: errcode character ( len = 1 , kind = c_char ), target :: c_source ( len ( source ) + 1 ) type ( c_ptr ), target :: c_source_p character (:), allocatable :: options_temp character ( len = 1 , kind = c_char ), allocatable , target :: c_options (:) call fclDbgCheckContext ( 'fclCompileProgram' , ctx ) ! Convert to c character array do i = 1 , len ( source ) c_source ( i ) = source ( i : i ) end do c_source ( len ( source ) + 1 ) = C_NULL_CHAR c_source_p = c_loc ( c_source ) prog % cl_program = clCreateProgramWithSource ( ctx % cl_context , 1 , & C_LOC ( c_source_p ), C_NULL_PTR , errcode ) call fclHandleError ( errcode , 'fclCompileProgram' , 'clCreateProgramWithSource' ) if ( present ( options )) then options_temp = options // ' ' // fclDbgOptions () else options_temp = fclDbgOptions () end if allocate ( c_options ( len ( options_temp ) + 1 )) do i = 1 , len ( options_temp ) c_options ( i ) = options_temp ( i : i ) end do c_options ( len ( options_temp ) + 1 ) = C_NULL_CHAR errcode = clBuildProgram ( prog % cl_program , 0 , & C_NULL_PTR , C_LOC ( c_options ), C_NULL_FUNPTR , C_NULL_PTR ) call fclHandleBuildError ( errcode , prog , ctx ) deallocate ( c_options ) end procedure fclCompileProgram_1 ! --------------------------------------------------------------------------- module procedure fclCompileProgram_2 !(source,options) result(prog) call fclDbgCheckContext ( 'fclCompileProgram' ) prog = fclCompileProgram_1 ( fclDefaultCtx , source , options ) end procedure fclCompileProgram_2 ! --------------------------------------------------------------------------- module procedure fclDumpBuildLog_1 !(ctx,prog,device,outputUnit) use iso_fortran_env , only : stdout => output_unit integer ( c_int32_t ) :: errcode integer :: out integer ( c_size_t ) :: buffLen , int32_ret character ( len = 1 ), allocatable , target :: buildLogBuffer (:) call fclDbgCheckContext ( 'fclDumpBuildLog' , ctx ) if ( present ( outputUnit )) then out = outputUnit else out = stdout end if errcode = clGetProgramBuildInfo ( prog % cl_program , device % cl_device_id , & CL_PROGRAM_BUILD_LOG , int ( 0 , c_size_t ), C_NULL_PTR , buffLen ) call fclHandleError ( errcode , 'fclCompileProgram' , 'clGetProgramBuildInfo' ) allocate ( buildLogBuffer ( buffLen )) buffLen = size ( buildLogBuffer , 1 ) errcode = clGetProgramBuildInfo ( prog % cl_program , device % cl_device_id , & CL_PROGRAM_BUILD_LOG , buffLen , c_loc ( buildLogBuffer ), int32_ret ) call fclHandleError ( errcode , 'fclCompileProgram' , 'clGetProgramBuildInfo' ) write ( * , * ) ' fclDumpBuildLog: Build log for context device: ' , device % name write ( out , * ) buildLogBuffer write ( out , * ) deallocate ( buildLogBuffer ) end procedure fclDumpBuildLog_1 ! --------------------------------------------------------------------------- module procedure fclDumpBuildLog_2 !(prog,device,outputUnit) call fclDbgCheckContext ( 'fclDumpBuildLog' ) call fclDumpBuildLog_1 ( fclDefaultCtx , prog , device , outputUnit ) end procedure fclDumpBuildLog_2 ! --------------------------------------------------------------------------- module procedure fclGetProgramKernel !(prog,kernelName,global_work_size,local_work_size, & ! work_dim,global_work_offset) result(kern) integer :: i integer ( c_int32_t ) :: errcode character ( len = 1 , kind = c_char ), target :: c_name ( len ( kernelName ) + 1 ) do i = 1 , len ( kernelName ) c_name ( i ) = kernelName ( i : i ) end do c_name ( len ( kernelName ) + 1 ) = C_NULL_CHAR kern % cl_kernel = clCreateKernel ( prog % cl_program , C_LOC ( c_name ), errcode ) call fclHandleError ( errcode , 'fclGetProgramKernel' , 'clCreateKernel' ) allocate ( character ( len = len ( kernelName )) :: kern % name ) kern % name = kernelName if ( present ( global_work_size )) then if ( size ( global_work_size , 1 ) > 3 ) then call fclRuntimeError ( 'fclGetProgramKernel: global work size must have dimension less than or equal to three.' ) else kern % work_dim = size ( global_work_size , 1 ) kern % global_work_size ( 1 : size ( global_work_size , 1 )) = global_work_size end if end if if ( present ( local_work_size )) then if ( size ( local_work_size , 1 ) > 3 ) then call fclRuntimeError ( 'fclGetProgramKernel: local work size must have dimension less than or equal to three.' ) else kern % local_work_size ( 1 : size ( local_work_size , 1 )) = local_work_size end if end if if ( present ( work_dim )) then if ( work_dim > 3 ) then call fclRuntimeError ( 'fclGetProgramKernel: kernel work dimensionmust be less than or equal to three.' ) else kern % work_dim = work_dim end if end if if ( present ( global_work_offset )) then if ( size ( global_work_offset , 1 ) > 3 ) then call fclRuntimeError ( 'fclGetProgramKernel: global work offset must have dimension less than or equal to three.' ) else kern % global_work_offset ( 1 : size ( global_work_offset , 1 )) = global_work_offset end if end if end procedure fclGetProgramKernel ! --------------------------------------------------------------------------- module procedure fclLaunchKernelAfterEvent_1 !(kernel,cmdQ,event) !! Specific interface for a single event dependency on a specific command queue call fclSetDependency ( cmdQ , event ) call fclLaunchKernel ( kernel , cmdQ ) end procedure fclLaunchKernelAfterEvent_1 ! --------------------------------------------------------------------------- module procedure fclLaunchKernelAfterEvent_2 !(kernel,event) !! Specific interface a single event dependency on the __default command queue__ call fclLaunchKernelAfterEvent_1 ( kernel , fclDefaultCmdQ , event ) end procedure fclLaunchKernelAfterEvent_2 ! --------------------------------------------------------------------------- module procedure fclLaunchKernelAfterEventList_1 !(kernel,cmdQ,eventList) !! Specific interface for a multiple event dependencies on a specific command queue call fclSetDependency ( cmdQ , eventList ) call fclLaunchKernel ( kernel , cmdQ ) end procedure fclLaunchKernelAfterEventList_1 ! --------------------------------------------------------------------------- module procedure fclLaunchKernelAfterEventList_2 !(kernel,eventList) !! Specific interface for a multiple event dependencies on the __default command queue__ call fclLaunchKernelAfterEventList_1 ( kernel , fclDefaultCmdQ , eventList ) end procedure fclLaunchKernelAfterEventList_2 ! --------------------------------------------------------------------------- module procedure fclLaunchKernel !(kernel,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9,& ! a10,a11,a12,a13,a14,a15,a16,a17,a18,a19, & !  a20,a21,a22,a23,a24,a25,a26,a27,a28,a29, & !  a30,a31,a32,a33,a34,a35,a36,a37,a38,a39, & !  a40,a41,a42,a43,a44,a45,a46,a47,a48,a49, & !  a50,a51,a52,a53,a54,a55,a56,a57,a58,a59, & !  a60,a61,a62,a63,a64,a65,a66,a67,a68,a69, & !  a70,a71,a72,a73,a74,a75,a76,a77,a78,a79, & !  a80,a81,a82,a83,a84,a85,a86,a87,a88,a89, & !  a90,a91,a92,a93,a94,a95,a96,a97,a98,a99) integer ( c_size_t ) :: i , nBlocki integer ( c_int32_t ) :: errcode type ( fclCommandQ ), pointer :: cmdQ type ( c_ptr ) :: localSizePtr integer :: nArg type ( fclEvent ), target :: kernelEvent ! Check global size has been set if ( sum ( abs ( kernel % global_work_size )) == 0 ) then write ( * , * ) 'Kernel name: ' , trim ( kernel % name ) call fclRuntimeError ( 'fclLaunchKernel: kernel global_work_size is unset.' ) end if ! Check if local size has been set if ( sum ( abs ( kernel % local_work_size )) == 0 ) then localSizePtr = C_NULL_PTR else localSizePtr = c_loc ( kernel % local_work_size ) ! Check global dims are multiples of user-specified !  local dims and update if necessary do i = 1 , kernel % work_dim if ( mod ( kernel % global_work_size ( i ), kernel % local_work_size ( i )) > 0 ) then nBlocki = ( kernel % global_work_size ( i ) + kernel % local_work_size ( i ) - 1 ) / kernel % local_work_size ( i ) kernel % global_work_size ( i ) = nBlocki * kernel % local_work_size ( i ) end if end do end if ! Set arguments and parse (get number of args and cmdq if specified) call fclProcessKernelArgs ( kernel , cmdq , narg , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 ,& a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 ) errcode = clEnqueueNDRangeKernel ( cmdq % cl_command_queue , & kernel % cl_kernel , kernel % work_dim , & c_loc ( kernel % global_work_offset ), & c_loc ( kernel % global_work_size ), localSizePtr , & cmdq % nDependency , cmdq % dependencyListPtr , & c_loc ( kernelEvent % cl_event )) call fclDbgWait ( kernelEvent ) call fclPopDependencies ( cmdq ) call fclHandleError ( errcode , 'fclLaunchKernel' , 'clEnqueueNDRangeKernel' ) fclLastKernelEvent = kernelEvent cmdQ % lastKernelEvent = kernelEvent call kernel % pushProfileEvent ( kernelEvent ) end procedure fclLaunchKernel ! --------------------------------------------------------------------------- module procedure fclProcessKernelArgs !(kernel,cmdq,narg,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9, & ! a10,a11,a12,a13,a14,a15,a16,a17,a18,a19, & ! a20,a21,a22,a23,a24,a25,a26,a27,a28,a29, & ! a30,a31,a32,a33,a34,a35,a36,a37,a38,a39, & ! a40,a41,a42,a43,a44,a45,a46,a47,a48,a49, & ! a50,a51,a52,a53,a54,a55,a56,a57,a58,a59, & ! a60,a61,a62,a63,a64,a65,a66,a67,a68,a69, & ! a70,a71,a72,a73,a74,a75,a76,a77,a78,a79, & ! a80,a81,a82,a83,a84,a85,a86,a87,a88,a89, & ! a90,a91,a92,a93,a94,a95,a96,a97,a98,a99) !! Sets kernel arguments and parses argument list for optional cmdq and actual number of arguments integer :: i0 ! --- Check if command queue was specified --- nArg = 0 i0 = 0 cmdQ => fclDefaultCmdQ if ( present ( a0 )) then select type ( arg => a0 ) class is ( fclCommandQ ) !! cmdQ is specified in first arg cmdQ => arg i0 = 0 class default !! First arg is not cmdQ: then it is a kernel arg call fclSetKernelArg ( kernel , 0 , arg ) i0 = 1 nArg = nArg + 1 end select end if ! --- Set arguments --- if ( present ( a1 )) then call fclSetKernelArg ( kernel , i0 + 0 , a1 ) nArg = nArg + 1 end if if ( present ( a2 )) then call fclSetKernelArg ( kernel , i0 + 1 , a2 ) nArg = nArg + 1 end if if ( present ( a3 )) then call fclSetKernelArg ( kernel , i0 + 2 , a3 ) nArg = nArg + 1 end if if ( present ( a4 )) then call fclSetKernelArg ( kernel , i0 + 3 , a4 ) nArg = nArg + 1 end if if ( present ( a5 )) then call fclSetKernelArg ( kernel , i0 + 4 , a5 ) nArg = nArg + 1 end if if ( present ( a6 )) then call fclSetKernelArg ( kernel , i0 + 5 , a6 ) nArg = nArg + 1 end if if ( present ( a7 )) then call fclSetKernelArg ( kernel , i0 + 6 , a7 ) nArg = nArg + 1 end if if ( present ( a8 )) then call fclSetKernelArg ( kernel , i0 + 7 , a8 ) nArg = nArg + 1 end if if ( present ( a9 )) then call fclSetKernelArg ( kernel , i0 + 8 , a9 ) nArg = nArg + 1 end if if ( present ( a10 )) then call fclSetKernelArg ( kernel , i0 + 9 , a10 ) nArg = nArg + 1 end if if ( present ( a11 )) then call fclSetKernelArg ( kernel , i0 + 10 , a11 ) nArg = nArg + 1 end if if ( present ( a12 )) then call fclSetKernelArg ( kernel , i0 + 11 , a12 ) nArg = nArg + 1 end if if ( present ( a13 )) then call fclSetKernelArg ( kernel , i0 + 12 , a13 ) nArg = nArg + 1 end if if ( present ( a14 )) then call fclSetKernelArg ( kernel , i0 + 13 , a14 ) nArg = nArg + 1 end if if ( present ( a15 )) then call fclSetKernelArg ( kernel , i0 + 14 , a15 ) nArg = nArg + 1 end if if ( present ( a16 )) then call fclSetKernelArg ( kernel , i0 + 15 , a16 ) nArg = nArg + 1 end if if ( present ( a17 )) then call fclSetKernelArg ( kernel , i0 + 16 , a17 ) nArg = nArg + 1 end if if ( present ( a18 )) then call fclSetKernelArg ( kernel , i0 + 17 , a18 ) nArg = nArg + 1 end if if ( present ( a19 )) then call fclSetKernelArg ( kernel , i0 + 18 , a19 ) nArg = nArg + 1 end if if ( present ( a20 )) then call fclSetKernelArg ( kernel , i0 + 19 , a20 ) nArg = nArg + 1 end if if ( present ( a21 )) then call fclSetKernelArg ( kernel , i0 + 20 , a21 ) nArg = nArg + 1 end if if ( present ( a22 )) then call fclSetKernelArg ( kernel , i0 + 21 , a22 ) nArg = nArg + 1 end if if ( present ( a23 )) then call fclSetKernelArg ( kernel , i0 + 22 , a23 ) nArg = nArg + 1 end if if ( present ( a24 )) then call fclSetKernelArg ( kernel , i0 + 23 , a24 ) nArg = nArg + 1 end if if ( present ( a25 )) then call fclSetKernelArg ( kernel , i0 + 24 , a25 ) nArg = nArg + 1 end if if ( present ( a26 )) then call fclSetKernelArg ( kernel , i0 + 25 , a26 ) nArg = nArg + 1 end if if ( present ( a27 )) then call fclSetKernelArg ( kernel , i0 + 26 , a27 ) nArg = nArg + 1 end if if ( present ( a28 )) then call fclSetKernelArg ( kernel , i0 + 27 , a28 ) nArg = nArg + 1 end if if ( present ( a29 )) then call fclSetKernelArg ( kernel , i0 + 28 , a29 ) nArg = nArg + 1 end if if ( present ( a30 )) then call fclSetKernelArg ( kernel , i0 + 29 , a30 ) nArg = nArg + 1 end if if ( present ( a31 )) then call fclSetKernelArg ( kernel , i0 + 30 , a31 ) nArg = nArg + 1 end if if ( present ( a32 )) then call fclSetKernelArg ( kernel , i0 + 31 , a32 ) nArg = nArg + 1 end if if ( present ( a33 )) then call fclSetKernelArg ( kernel , i0 + 32 , a33 ) nArg = nArg + 1 end if if ( present ( a34 )) then call fclSetKernelArg ( kernel , i0 + 33 , a34 ) nArg = nArg + 1 end if if ( present ( a35 )) then call fclSetKernelArg ( kernel , i0 + 34 , a35 ) nArg = nArg + 1 end if if ( present ( a36 )) then call fclSetKernelArg ( kernel , i0 + 35 , a36 ) nArg = nArg + 1 end if if ( present ( a37 )) then call fclSetKernelArg ( kernel , i0 + 36 , a37 ) nArg = nArg + 1 end if if ( present ( a38 )) then call fclSetKernelArg ( kernel , i0 + 37 , a38 ) nArg = nArg + 1 end if if ( present ( a39 )) then call fclSetKernelArg ( kernel , i0 + 38 , a39 ) nArg = nArg + 1 end if if ( present ( a40 )) then call fclSetKernelArg ( kernel , i0 + 39 , a40 ) nArg = nArg + 1 end if if ( present ( a41 )) then call fclSetKernelArg ( kernel , i0 + 40 , a41 ) nArg = nArg + 1 end if if ( present ( a42 )) then call fclSetKernelArg ( kernel , i0 + 41 , a42 ) nArg = nArg + 1 end if if ( present ( a43 )) then call fclSetKernelArg ( kernel , i0 + 42 , a43 ) nArg = nArg + 1 end if if ( present ( a44 )) then call fclSetKernelArg ( kernel , i0 + 43 , a44 ) nArg = nArg + 1 end if if ( present ( a45 )) then call fclSetKernelArg ( kernel , i0 + 44 , a45 ) nArg = nArg + 1 end if if ( present ( a46 )) then call fclSetKernelArg ( kernel , i0 + 45 , a46 ) nArg = nArg + 1 end if if ( present ( a47 )) then call fclSetKernelArg ( kernel , i0 + 46 , a47 ) nArg = nArg + 1 end if if ( present ( a48 )) then call fclSetKernelArg ( kernel , i0 + 47 , a48 ) nArg = nArg + 1 end if if ( present ( a49 )) then call fclSetKernelArg ( kernel , i0 + 48 , a49 ) nArg = nArg + 1 end if if ( present ( a50 )) then call fclSetKernelArg ( kernel , i0 + 49 , a50 ) nArg = nArg + 1 end if if ( present ( a51 )) then call fclSetKernelArg ( kernel , i0 + 50 , a51 ) nArg = nArg + 1 end if if ( present ( a52 )) then call fclSetKernelArg ( kernel , i0 + 51 , a52 ) nArg = nArg + 1 end if if ( present ( a53 )) then call fclSetKernelArg ( kernel , i0 + 52 , a53 ) nArg = nArg + 1 end if if ( present ( a54 )) then call fclSetKernelArg ( kernel , i0 + 53 , a54 ) nArg = nArg + 1 end if if ( present ( a55 )) then call fclSetKernelArg ( kernel , i0 + 54 , a55 ) nArg = nArg + 1 end if if ( present ( a56 )) then call fclSetKernelArg ( kernel , i0 + 55 , a56 ) nArg = nArg + 1 end if if ( present ( a57 )) then call fclSetKernelArg ( kernel , i0 + 56 , a57 ) nArg = nArg + 1 end if if ( present ( a58 )) then call fclSetKernelArg ( kernel , i0 + 57 , a58 ) nArg = nArg + 1 end if if ( present ( a59 )) then call fclSetKernelArg ( kernel , i0 + 58 , a59 ) nArg = nArg + 1 end if if ( present ( a60 )) then call fclSetKernelArg ( kernel , i0 + 59 , a60 ) nArg = nArg + 1 end if if ( present ( a61 )) then call fclSetKernelArg ( kernel , i0 + 60 , a61 ) nArg = nArg + 1 end if if ( present ( a62 )) then call fclSetKernelArg ( kernel , i0 + 61 , a62 ) nArg = nArg + 1 end if if ( present ( a63 )) then call fclSetKernelArg ( kernel , i0 + 62 , a63 ) nArg = nArg + 1 end if if ( present ( a64 )) then call fclSetKernelArg ( kernel , i0 + 63 , a64 ) nArg = nArg + 1 end if if ( present ( a65 )) then call fclSetKernelArg ( kernel , i0 + 64 , a65 ) nArg = nArg + 1 end if if ( present ( a66 )) then call fclSetKernelArg ( kernel , i0 + 65 , a66 ) nArg = nArg + 1 end if if ( present ( a67 )) then call fclSetKernelArg ( kernel , i0 + 66 , a67 ) nArg = nArg + 1 end if if ( present ( a68 )) then call fclSetKernelArg ( kernel , i0 + 67 , a68 ) nArg = nArg + 1 end if if ( present ( a69 )) then call fclSetKernelArg ( kernel , i0 + 68 , a69 ) nArg = nArg + 1 end if if ( present ( a70 )) then call fclSetKernelArg ( kernel , i0 + 69 , a70 ) nArg = nArg + 1 end if if ( present ( a71 )) then call fclSetKernelArg ( kernel , i0 + 70 , a71 ) nArg = nArg + 1 end if if ( present ( a72 )) then call fclSetKernelArg ( kernel , i0 + 71 , a72 ) nArg = nArg + 1 end if if ( present ( a73 )) then call fclSetKernelArg ( kernel , i0 + 72 , a73 ) nArg = nArg + 1 end if if ( present ( a74 )) then call fclSetKernelArg ( kernel , i0 + 73 , a74 ) nArg = nArg + 1 end if if ( present ( a75 )) then call fclSetKernelArg ( kernel , i0 + 74 , a75 ) nArg = nArg + 1 end if if ( present ( a76 )) then call fclSetKernelArg ( kernel , i0 + 75 , a76 ) nArg = nArg + 1 end if if ( present ( a77 )) then call fclSetKernelArg ( kernel , i0 + 76 , a77 ) nArg = nArg + 1 end if if ( present ( a78 )) then call fclSetKernelArg ( kernel , i0 + 77 , a78 ) nArg = nArg + 1 end if if ( present ( a79 )) then call fclSetKernelArg ( kernel , i0 + 78 , a79 ) nArg = nArg + 1 end if if ( present ( a80 )) then call fclSetKernelArg ( kernel , i0 + 79 , a80 ) nArg = nArg + 1 end if if ( present ( a81 )) then call fclSetKernelArg ( kernel , i0 + 80 , a81 ) nArg = nArg + 1 end if if ( present ( a82 )) then call fclSetKernelArg ( kernel , i0 + 81 , a82 ) nArg = nArg + 1 end if if ( present ( a83 )) then call fclSetKernelArg ( kernel , i0 + 82 , a83 ) nArg = nArg + 1 end if if ( present ( a84 )) then call fclSetKernelArg ( kernel , i0 + 83 , a84 ) nArg = nArg + 1 end if if ( present ( a85 )) then call fclSetKernelArg ( kernel , i0 + 84 , a85 ) nArg = nArg + 1 end if if ( present ( a86 )) then call fclSetKernelArg ( kernel , i0 + 85 , a86 ) nArg = nArg + 1 end if if ( present ( a87 )) then call fclSetKernelArg ( kernel , i0 + 86 , a87 ) nArg = nArg + 1 end if if ( present ( a88 )) then call fclSetKernelArg ( kernel , i0 + 87 , a88 ) nArg = nArg + 1 end if if ( present ( a89 )) then call fclSetKernelArg ( kernel , i0 + 88 , a89 ) nArg = nArg + 1 end if if ( present ( a90 )) then call fclSetKernelArg ( kernel , i0 + 89 , a90 ) nArg = nArg + 1 end if if ( present ( a91 )) then call fclSetKernelArg ( kernel , i0 + 90 , a91 ) nArg = nArg + 1 end if if ( present ( a92 )) then call fclSetKernelArg ( kernel , i0 + 91 , a92 ) nArg = nArg + 1 end if if ( present ( a93 )) then call fclSetKernelArg ( kernel , i0 + 92 , a93 ) nArg = nArg + 1 end if if ( present ( a94 )) then call fclSetKernelArg ( kernel , i0 + 93 , a94 ) nArg = nArg + 1 end if if ( present ( a95 )) then call fclSetKernelArg ( kernel , i0 + 94 , a95 ) nArg = nArg + 1 end if if ( present ( a96 )) then call fclSetKernelArg ( kernel , i0 + 95 , a96 ) nArg = nArg + 1 end if if ( present ( a97 )) then call fclSetKernelArg ( kernel , i0 + 96 , a97 ) nArg = nArg + 1 end if if ( present ( a98 )) then call fclSetKernelArg ( kernel , i0 + 97 , a98 ) nArg = nArg + 1 end if if ( present ( a99 )) then call fclSetKernelArg ( kernel , i0 + 98 , a99 ) nArg = nArg + 1 end if if ( nArg > 0 ) then ! If any kernel arguments are specified, check that they are all present call fclDbgCheckKernelNArg ( kernel , nArg ) end if end procedure fclProcessKernelArgs ! --------------------------------------------------------------------------- module procedure fclSetKernelArgs !(kernel,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9, & ! a10,a11,a12,a13,a14,a15,a16,a17,a18,a19, & !  a20,a21,a22,a23,a24,a25,a26,a27,a28,a29, & !  a30,a31,a32,a33,a34,a35,a36,a37,a38,a39, & ! a40,a41,a42,a43,a44,a45,a46,a47,a48,a49, & ! a50,a51,a52,a53,a54,a55,a56,a57,a58,a59, & ! a60,a61,a62,a63,a64,a65,a66,a67,a68,a69, & ! a70,a71,a72,a73,a74,a75,a76,a77,a78,a79, & ! a80,a81,a82,a83,a84,a85,a86,a87,a88,a89, & ! a90,a91,a92,a93,a94,a95,a96,a97,a98,a99) !! Set all kernel arguments at once without launching kernel. type ( fclCommandQ ), pointer :: cmdq integer :: nArg call fclProcessKernelArgs ( kernel , cmdq , narg , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 ) end procedure fclSetKernelArgs ! --------------------------------------------------------------------------- module procedure fclSetKernelArg !(kernel,argIndex,argValue) integer ( c_int32_t ) :: errcode type ( c_ptr ) :: argPtr integer ( c_size_t ) :: argSize !! @note !! \" The argument data pointed to by arg_value is copied and the arg_value pointer !!   can therefore be reused by the application after clSetKernelArg returns.\" !! https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clSetKernelArg.html !! @endnote !! @todo Debug check argument types against kernel arg types (clGetKernelArgInfo) @endtodo argPtr = C_NULL_PTR argSize = - 1 select type ( arg => argValue ) class is ( fclDeviceBuffer ) argPtr = c_loc ( arg % cl_mem ) argSize = c_sizeof ( arg % cl_mem ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'global,constant' ) call fclDbgCheckBufferInit ( arg , 'fclSetKernelArg' ) class is ( fclDeviceInt32 ) argPtr = c_loc ( arg % cl_mem ) argSize = c_sizeof ( arg % cl_mem ) call fclDbgCheckKernelArgType ( kernel , argIndex , 'int*' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'global,constant' ) call fclDbgCheckBufferInit ( arg , 'fclSetKernelArg' ) class is ( fclDeviceFloat ) argPtr = c_loc ( arg % cl_mem ) argSize = c_sizeof ( arg % cl_mem ) call fclDbgCheckKernelArgType ( kernel , argIndex , 'float*' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'global,constant' ) call fclDbgCheckBufferInit ( arg , 'fclSetKernelArg' ) class is ( fclDeviceDouble ) argPtr = c_loc ( arg % cl_mem ) argSize = c_sizeof ( arg % cl_mem ) call fclDbgCheckKernelArgType ( kernel , argIndex , 'double*' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'global,constant' ) call fclDbgCheckBufferInit ( arg , 'fclSetKernelArg' ) class is ( fclLocalArgument ) argPtr = C_NULL_PTR argSize = arg % nBytes call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'local' ) class is ( fclLocalArgInt32 ) argPtr = C_NULL_PTR argSize = arg % nBytes call fclDbgCheckKernelArgType ( kernel , argIndex , 'int*' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'local' ) class is ( fclLocalArgFloat ) argPtr = C_NULL_PTR argSize = arg % nBytes call fclDbgCheckKernelArgType ( kernel , argIndex , 'float*' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'local' ) class is ( fclLocalArgDouble ) argPtr = C_NULL_PTR argSize = arg % nBytes call fclDbgCheckKernelArgType ( kernel , argIndex , 'double*' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'local' ) type is ( integer ( c_int32_t )) argPtr = c_loc ( arg ) argSize = c_sizeof ( int ( 1 , c_int32_t )) call fclDbgCheckKernelArgType ( kernel , argIndex , 'int' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'private' ) type is ( real ( c_float )) argPtr = c_loc ( arg ) argSize = c_sizeof ( real ( 1.0 , c_float )) call fclDbgCheckKernelArgType ( kernel , argIndex , 'float' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'private' ) type is ( real ( c_double )) argPtr = c_loc ( arg ) argSize = c_sizeof ( real ( 1.0d0 , c_double )) call fclDbgCheckKernelArgType ( kernel , argIndex , 'double' ) call fclDbgCheckKernelArgQualifier ( kernel , argIndex , 'private' ) class default write ( * , * ) 'Kernel name: ' , trim ( kernel % name ) write ( * , '(A,I4)' ) 'Argument index: ' , argIndex call fclRuntimeError ( 'fclSetKernelArg: unsupported argument type passed to kernel.' ) end select errcode = clSetKernelArg ( kernel % cl_kernel , argIndex , argSize , argPtr ) call fclHandleError ( errcode , 'fclSetKernelArg' , 'clSetKernelArg' ) end procedure fclSetKernelArg ! --------------------------------------------------------------------------- module procedure fclLocalInt32 !(nElem) result(localArg) !! Create a integer local kernel argument object for launching kernels localArg % nBytes = c_sizeof ( int ( 1 , c_int32_t )) * nElem end procedure fclLocalInt32 ! --------------------------------------------------------------------------- module procedure fclLocalFloat !(nElem) result(localArg) !! Create a integer local kernel argument object for launching kernels localArg % nBytes = c_sizeof ( real ( 1.0 , c_float )) * nElem end procedure fclLocalFloat ! --------------------------------------------------------------------------- module procedure fclLocalDouble !(nElem) result(localArg) !! Create a integer local kernel argument object for launching kernels localArg % nBytes = c_sizeof ( real ( 1.0d0 , c_double )) * nElem end procedure fclLocalDouble ! --------------------------------------------------------------------------- module procedure fclReleaseKernel !(kernel) !! Release OpenCL memory associated with underlying kernel pointer integer :: errcode errcode = clReleaseKernel ( kernel % cl_kernel ) end procedure fclReleaseKernel ! --------------------------------------------------------------------------- module procedure fclBarrier_1 !(cmdq) !! Enqueue barrier on all events in command queue integer ( c_int32_t ) :: errcode type ( fclEvent ), target :: barrierEvent errcode = clEnqueueBarrierWithWaitList ( cmdq % cl_command_queue , & cmdq % nDependency , cmdq % dependencyListPtr , & c_loc ( barrierEvent % cl_event )) call fclPopDependencies ( cmdq ) call fclHandleError ( errcode , 'fclBarrierAll' , 'clEnqueueBarrierWithWaitList' ) fclLastBarrierEvent = barrierEvent cmdq % lastBarrierEvent = barrierEvent end procedure fclBarrier_1 ! --------------------------------------------------------------------------- module procedure fclBarrier_2 !(cmdq) !! Enqueue barrier on all events in default command queue call fclBarrier_1 ( fclDefaultCmdQ ) end procedure fclBarrier_2 ! --------------------------------------------------------------------------- module procedure fclFinish_1 !(cmdq) !! Wait on host for all events in user-specified command queue integer ( c_int32_t ) :: errcode errcode = clFinish ( cmdq % cl_command_queue ) call fclHandleError ( errcode , 'fclFinish' , 'clFinish' ) end procedure fclFinish_1 ! --------------------------------------------------------------------------- module procedure fclFinish_2 !! Wait on host for all events in focal default command queue call fclFinish_1 ( fclDefaultCmdQ ) end procedure fclFinish_2 ! --------------------------------------------------------------------------- module procedure fclFinish_3 !(qPool) !! Wait on host for all events in all queues in a queue pool integer :: i do i = 1 , qPool % length call fclFinish_1 ( qPool % queues ( i )) end do end procedure fclFinish_3 ! --------------------------------------------------------------------------- module procedure fclWaitEvent !(event) !! Wait on host for a specific event integer ( c_int32_t ) :: errcode errcode = clWaitForEvents ( 1 , c_loc ( event % cl_event ) ) call fclHandleError ( errcode , 'fclWaitEvent' , 'clWaitForEvents' ) end procedure fclWaitEvent ! --------------------------------------------------------------------------- module procedure fclWaitEventList !(eventList) !! Wait on host for set of events integer :: i integer ( c_int32_t ) :: errcode integer ( c_intptr_t ), target :: cl_eventList ( size ( eventList , 1 )) ! Populate array of c_ptr cl_eventList = [( eventList ( i )% cl_event , i = 1 , size ( eventList , 1 ))] errcode = clWaitForEvents ( size ( eventList , 1 ), c_loc ( cl_eventList ) ) call fclHandleError ( errcode , 'fclWaitEventList' , 'clWaitForEvents' ) end procedure fclWaitEventList ! --------------------------------------------------------------------------- module procedure fclEventCopy !(target, source) !! Overloaded assignment for event assignment. !!  Handles opencl reference counting for the underlying event object if ( target % cl_event > 0 ) then call fclReleaseEvent ( target ) end if call fclRetainEvent ( source ) target % cl_event = source % cl_event end procedure fclEventCopy ! --------------------------------------------------------------------------- module procedure fclReleaseEvent !(event) !! Light weight wrapper for clReleaseEvent (decrement reference count) integer ( c_int32_t ) :: errcode if ( event % cl_event > 0 ) then errcode = clReleaseEvent ( event % cl_event ) call fclHandleError ( errcode , 'fclReleaseEvent' , 'clReleaseEvent' ) end if end procedure fclReleaseEvent ! --------------------------------------------------------------------------- module procedure fclRetainEvent !(event) !! Light weight wrapper for clRetainEvent (increment reference count) integer ( c_int32_t ) :: errcode if ( event % cl_event > 0 ) then errcode = clRetainEvent ( event % cl_event ) call fclHandleError ( errcode , 'fclRetainEvent' , 'clRetainEvent' ) end if end procedure fclRetainEvent ! --------------------------------------------------------------------------- module procedure fclSetDependencyEvent_1 !(cmdq,event,hold) !! Specify a single event dependency on specific cmdq integer ( c_int32_t ) :: errcode if (. not . allocated ( cmdq % dependencyList )) then allocate ( cmdq % dependencyList ( fclAllocationSize )) end if cmdq % dependencyList ( 1 ) = event % cl_event cmdq % nDependency = 1 cmdq % dependencyListPtr = c_loc ( cmdq % dependencyList ) ! Explicitly increment event reference counter errcode = clRetainEvent ( event % cl_event ) call fclHandleError ( errcode , 'fclSetDependencyEvent' , 'clRetainEvent' ) if ( present ( hold )) then cmdq % holdDependencies = hold end if end procedure fclSetDependencyEvent_1 ! --------------------------------------------------------------------------- module procedure fclSetDependencyEvent_2 !(event,hold) !! Specify a single event dependency on default cmdq call fclSetDependencyEvent_1 ( fclDefaultCmdQ , event , hold ) end procedure fclSetDependencyEvent_2 ! --------------------------------------------------------------------------- module procedure fclSetDependencyEventList_1 !(cmdq,eventList,hold) !! Specify a list of dependent events on specific cmdq integer :: i , nEvent , nAlloc integer ( c_int32_t ) :: errcode nEvent = size ( eventList , 1 ) nAlloc = max ( fclAllocationSize , nEvent ) if (. not . allocated ( cmdq % dependencyList )) then !! Allocate for first time allocate ( cmdq % dependencyList ( nAlloc )) elseif ( size ( cmdq % dependencyList , 1 ) < nEvent ) then !! Re-allocate bigger deallocate ( cmdq % dependencyList ) allocate ( cmdq % dependencyList ( nAlloc )) end if cmdq % dependencyList ( 1 : nEvent ) = [( eventList ( i )% cl_event , i = 1 , nEvent )] cmdq % nDependency = nEvent cmdq % dependencyListPtr = c_loc ( cmdq % dependencyList ) ! Explicitly increment event reference counters do i = 1 , nEvent errcode = clRetainEvent ( eventList ( i )% cl_event ) call fclHandleError ( errcode , 'fclSetDependencyEvent' , 'clRetainEvent' ) end do if ( present ( hold )) then cmdq % holdDependencies = hold end if end procedure fclSetDependencyEventList_1 ! --------------------------------------------------------------------------- module procedure fclSetDependencyEventList_2 !(eventList,hold) !! Specify a list of dependent events on the default cmdq call fclSetDependencyEventList_1 ( fclDefaultCmdQ , eventList , hold ) end procedure fclSetDependencyEventList_2 ! --------------------------------------------------------------------------- module procedure fclPopDependencies !(cmdq) !! Called after every enqueue operation: !! Clear dependencies unless dependency hold is .true. if (. not . cmdq % holdDependencies ) then call fclClearDependencies ( cmdq ) end if end procedure fclPopDependencies ! --------------------------------------------------------------------------- module procedure fclClearDependencies_1 !(cmdq) !! Reset dependency list integer :: i integer ( c_int32_t ) :: errcode ! Explicitly decrement event reference counters do i = 1 , cmdq % nDependency errcode = clReleaseEvent ( cmdq % dependencyList ( i )) call fclHandleError ( errcode , 'fclClearDependencies' , 'clReleaseEvent' ) end do cmdq % nDependency = 0 cmdq % dependencyListPtr = C_NULL_PTR cmdq % holdDependencies = . false . end procedure fclClearDependencies_1 ! --------------------------------------------------------------------------- module procedure fclClearDependencies_2 !! Reset dependency list on default command queue call fclClearDependencies_1 ( fclDefaultCmdQ ) end procedure fclClearDependencies_2 ! --------------------------------------------------------------------------- module procedure fclCreateUserEvent_1 !(ctx) result(userEvent) !! Create user event in a specific context integer ( c_int32_t ) :: errcode userEvent % cl_event = clCreateUserEvent ( ctx % cl_context , errcode ) call fclHandleError ( errcode , 'fclCreateUserEvent' , 'clCreateUserEvent' ) end procedure fclCreateUserEvent_1 ! --------------------------------------------------------------------------- module procedure fclCreateUserEvent_2 !() result(userEvent) !! Create user event in in the default context userEvent = fclCreateUserEvent_1 ( fclDefaultCtx ) end procedure fclCreateUserEvent_2 ! --------------------------------------------------------------------------- module procedure fclSetUserEvent !(event,stat) !! Set status of a user event integer ( c_int32_t ) :: errcode , eStatus if ( present ( stat )) then eStatus = stat else eStatus = 0 end if errcode = clSetUserEventStatus ( event % cl_event , eStatus ) call fclHandleError ( errcode , 'fclSetUserEvent' , 'clSetUserEventStatus' ) end procedure fclSetUserEvent ! --------------------------------------------------------------------------- end submodule Focal_Setup","tags":"","loc":"sourcefile/focal_setup.f90.html"},{"title":"Focal_Query.f90 – Focal API Reference","text":"Contents Submodules Focal_Query Source Code Focal_Query.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Query !!  Implementation module for query routines !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran use M_Strings , only : str_noesc => noesc implicit none contains module procedure fclGetPlatformInfo !(platform,key,value) ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html integer ( c_size_t ) :: zero_size = 0 integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret errcode = clGetPlatformInfo ( platform % cl_platform_id , key , zero_size , C_NULL_PTR , temp_size ) call fclHandleError ( errcode , 'fclGetPlatformInfo' , 'clGetPlatformInfo' ) allocate ( character ( len = temp_size ) :: value ) errcode = clGetPlatformInfo ( platform % cl_platform_id , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetPlatformInfo' , 'clGetPlatformInfo' ) ! Remove non-printable characters (terminating null char) value = str_noesc ( value ) end procedure fclGetPlatformInfo ! --------------------------------------------------------------------------- module procedure fclGetDeviceInfoString !(device,key,value) ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html integer ( c_size_t ) :: zero_size = 0 integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret errcode = clGetDeviceInfo ( device % cl_device_id , key , zero_size , C_NULL_PTR , temp_size ) call fclHandleError ( errcode , 'fclGetDeviceInfoString' , 'clGetDeviceInfo' ) allocate ( character ( len = temp_size ) :: value ) errcode = clGetDeviceInfo ( device % cl_device_id , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetDeviceInfoString' , 'clGetDeviceInfo' ) ! Remove non-printable characters (terminating null char) value = str_noesc ( value ) end procedure fclGetDeviceInfoString ! --------------------------------------------------------------------------- module procedure fclGetDeviceInfoInt32 !(device,key,value) ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret temp_size = c_sizeof ( int ( 1 , c_int32_t )) errcode = clGetDeviceInfo ( device % cl_device_id , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetDeviceInfoInt32' , 'clGetDeviceInfo' ) end procedure fclGetDeviceInfoInt32 ! --------------------------------------------------------------------------- module procedure fclGetDeviceInfoInt64 !(device,key,value) ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret temp_size = c_sizeof ( int ( 1 , c_int64_t )) errcode = clGetDeviceInfo ( device % cl_device_id , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetDeviceInfoInt64' , 'clGetDeviceInfo' ) end procedure fclGetDeviceInfoInt64 ! --------------------------------------------------------------------------- module procedure fclGetKernelInfoString !(kernel,key,value) !! Query kernel information for string info. ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetKernelInfo.html integer ( c_size_t ) :: zero_size = 0 integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret errcode = clGetKernelInfo ( kernel % cl_kernel , key , zero_size , C_NULL_PTR , temp_size ) call fclHandleError ( errcode , 'fclGetKernelInfoString' , 'clGetKernelInfo' ) allocate ( character ( len = temp_size ) :: value ) errcode = clGetKernelInfo ( kernel % cl_kernel , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetKernelInfoString' , 'clGetKernelInfo' ) ! Remove non-printable characters (terminating null char) value = str_noesc ( value ) end procedure fclGetKernelInfoString ! --------------------------------------------------------------------------- module procedure fclGetKernelInfoInt32 !(kernel,key,value) !! Query kernel information for 32bit integer. ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetKernelInfo.html integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret temp_size = c_sizeof ( int ( 1 , c_int32_t )) errcode = clGetKernelInfo ( kernel % cl_kernel , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetKernelInfoInt32' , 'clGetKernelInfo' ) end procedure fclGetKernelInfoInt32 ! --------------------------------------------------------------------------- module procedure fclGetKernelWorkGroupInfoInt64 !(kernel,device,key,value) !! Query kernel work group information for 64bit integer. ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetKernelWorkGroupInfo.html integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret temp_size = c_sizeof ( int ( 1 , c_int64_t )) errcode = clGetKernelWorkGroupInfo ( kernel % cl_kernel , device % cl_device_id , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetKernelWorkGroupInfoInt64' , 'clGetKernelWorkGroupInfo' ) end procedure fclGetKernelWorkGroupInfoInt64 ! --------------------------------------------------------------------------- module procedure fclGetKernelArgInfoString !(kernel,key,value) !! Query kernel argument information for string info. ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetKernelArgInfo.html integer ( c_size_t ) :: zero_size = 0 integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret errcode = clGetKernelArgInfo ( kernel % cl_kernel , argNo , key , zero_size , C_NULL_PTR , temp_size ) call fclHandleError ( errcode , 'fclGetKernelArgInfoString' , 'clGetKernelArgInfo' ) allocate ( character ( len = temp_size ) :: value ) errcode = clGetKernelArgInfo ( kernel % cl_kernel , argNo , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetKernelArgInfoString' , 'clGetKernelArgInfo' ) ! Remove non-printable characters (terminating null char) value = str_noesc ( value ) end procedure fclGetKernelArgInfoString ! --------------------------------------------------------------------------- module procedure fclGetKernelArgInfoInt32 !(kernel,argNo,key,value) !! Query kernel argument information for 32bit integer. ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetKernelArgInfo.html integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret temp_size = c_sizeof ( int ( 1 , c_int32_t )) errcode = clGetKernelArgInfo ( kernel % cl_kernel , argNo , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetKernelInfoInt32' , 'clGetKernelInfo' ) end procedure fclGetKernelArgInfoInt32 ! --------------------------------------------------------------------------- module procedure fclGetEventInfo !(event,key,value) !! Query event information for 32bit integer. ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetEventInfo.html integer ( c_int32_t ) :: errcode integer ( c_size_t ) :: temp_size , size_ret temp_size = c_sizeof ( int ( 1 , c_int32_t )) errcode = clGetEventInfo ( event % cl_event , key , temp_size , C_LOC ( value ), size_ret ) call fclHandleError ( errcode , 'fclGetEventInfo' , 'clGetEventInfo' ) end procedure fclGetEventInfo ! --------------------------------------------------------------------------- module procedure fclGetPlatforms !result(platforms) integer :: i integer ( c_int32_t ) :: num_platforms , int32_ret integer ( c_int32_t ) :: errcode integer ( c_intptr_t ), allocatable , target :: platform_ids (:) ! Get number of platforms errcode = clGetPlatformIDs ( 0 , C_NULL_PTR , num_platforms ) call fclHandleError ( errcode , 'fclGetPlatforms' , 'clGetPlatformIDs' ) ! Allocate platform_ids array allocate ( platform_ids ( num_platforms )) ! Populate platform_ids array errcode = clGetPlatformIDs ( num_platforms , c_loc ( platform_ids ), int32_ret ) call fclHandleError ( errcode , 'fclGetPlatforms' , 'clGetPlatformIDs' ) ! Populate output fclPlatform structure array allocate ( platforms ( num_platforms )) do i = 1 , num_platforms platforms ( i ) = fclGetPlatform ( platform_ids ( i )) end do ! Cleanup deallocate ( platform_ids ) end procedure fclGetPlatforms ! --------------------------------------------------------------------------- module procedure fclGetPlatform !(platform_id) result(platform) integer :: i integer ( c_int32_t ) :: errcode integer ( c_int32_t ) :: int32_ret platform % cl_platform_id = platform_id ! --- Get number of devices --- errcode = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_ALL , 0 , C_NULL_PTR , platform % numDevice ) call fclHandleError ( errcode , 'fclGetPlatform' , 'clGetDeviceIDs' ) allocate ( platform % devices ( platform % numDevice )) allocate ( platform % cl_device_ids ( platform % numDevice )) ! --- Get device ids --- errcode = clGetDeviceIDs ( platform_id , CL_DEVICE_TYPE_ALL , platform % numDevice , & C_LOC ( platform % cl_device_ids ), int32_ret ) call fclHandleError ( errcode , 'fclGetPlatform' , 'clGetDeviceIDs' ) ! --- Populate fclPlatform info strings --- call fclGetPlatformInfo ( platform , CL_PLATFORM_PROFILE , platform % profile ) call fclGetPlatformInfo ( platform , CL_PLATFORM_VERSION , platform % version ) call fclGetPlatformInfo ( platform , CL_PLATFORM_NAME , platform % name ) call fclGetPlatformInfo ( platform , CL_PLATFORM_VENDOR , platform % vendor ) call fclGetPlatformInfo ( platform , CL_PLATFORM_EXTENSIONS , platform % extensions ) ! --- Populate fclDevice structure array --- do i = 1 , platform % numDevice platform % devices ( i ) = fclGetDevice ( platform % cl_device_ids ( i )) platform % devices ( i )% platformName = platform % name platform % devices ( i )% platformVendor = platform % vendor platform % devices ( i )% cl_platform_id = platform_id end do end procedure fclGetPlatform ! --------------------------------------------------------------------------- module procedure fclGetDevice !(device_id) result(device) ! https://www.khronos.org/registry/OpenCL/sdk/1.0/docs/man/xhtml/clGetDeviceInfo.html device % cl_device_id = device_id call fclGetDeviceInfo ( device , CL_DEVICE_NAME , device % name ) call fclGetDeviceInfo ( device , CL_DEVICE_TYPE , device % cl_device_type ) call fclGetDeviceInfo ( device , CL_DEVICE_MAX_COMPUTE_UNITS , device % nComputeUnits ) call fclGetDeviceInfo ( device , CL_DEVICE_GLOBAL_MEM_SIZE , device % global_memory ) call fclGetDeviceInfo ( device , CL_DEVICE_MAX_CLOCK_FREQUENCY , device % clock_freq ) call fclGetDeviceInfo ( device , CL_DEVICE_VERSION , device % version ) call fclGetDeviceInfo ( device , CL_DEVICE_EXTENSIONS , device % extensions ) end procedure fclGetDevice ! --------------------------------------------------------------------------- end submodule Focal_Query","tags":"","loc":"sourcefile/focal_query.f90.html"},{"title":"Focal_NoDebug.f90 – Focal API Reference","text":"Contents Submodules Focal_NoDebug Source Code Focal_NoDebug.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_NoDebug !!  Implementation module for focal debug routines. !!  This submodule is linked in the release version of Focal build. !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote implicit none contains module procedure fclDbgCheckContext !(ctx) !! Check the (default) context is initialised. end procedure fclDbgCheckContext ! --------------------------------------------------------------------------- module procedure fclDbgCheckDevice !(device,descrip) !! Check a device object is valid end procedure fclDbgCheckDevice ! --------------------------------------------------------------------------- module procedure fclDbgCheckBufferInit !(memObject) !! Check that a device buffer object has been initialised. end procedure fclDbgCheckBufferInit ! --------------------------------------------------------------------------- module procedure fclDbgCheckBufferSize !(memObject,hostBytes) !! Check that a host buffer matches the size in bytes of a device buffer end procedure fclDbgCheckBufferSize ! --------------------------------------------------------------------------- module procedure fclDbgCheckCopyBufferSize !(memObject1,memObject2) !! Check that device buffers match in size in bytes for copying end procedure fclDbgCheckCopyBufferSize ! --------------------------------------------------------------------------- module procedure fclDbgCheckKernelNArg !(kernel,nArg) !! Check that number of actual args matches number of kernel args end procedure fclDbgCheckKernelNArg ! --------------------------------------------------------------------------- module procedure fclDbgCheckKernelArgType !(kernel,argNo,type) end procedure fclDbgCheckKernelArgType ! --------------------------------------------------------------------------- module procedure fclDbgCheckKernelArgQualifier !(kernel,argNo,qualifier) end procedure fclDbgCheckKernelArgQualifier ! --------------------------------------------------------------------------- module procedure fclDbgOptions !(options) options = '' end procedure fclDbgOptions ! --------------------------------------------------------------------------- module procedure fclDbgWait !(event,descrip) end procedure fclDbgWait ! --------------------------------------------------------------------------- end submodule Focal_NoDebug","tags":"","loc":"sourcefile/focal_nodebug.f90.html"},{"title":"Focal_Error.f90 – Focal API Reference","text":"Contents Submodules Focal_Error Source Code Focal_Error.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Error !!  Implementation module for error handling !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran implicit none interface !! Interface to c function abort(). !!  Used to print backtrace on error. subroutine c_abort () bind ( C , name = \"abort\" ) end subroutine end interface contains module procedure fclHandleError if ( associated ( fclErrorHandler )) then call fclErrorHandler ( errcode , focalCall , oclCall ) else call fclDefaultErrorHandler ( errcode , focalCall , oclCall ) end if end procedure fclHandleError ! --------------------------------------------------------------------------- module procedure fclDefaultErrorHandler if ( errcode /= CL_SUCCESS ) then write ( * , * ) '(!) Fatal openCl error ' , errcode , ' : ' , trim ( fclGetErrorString ( errcode )) write ( * , * ) '      at ' , focalCall , ':' , oclCall call c_abort () end if end procedure fclDefaultErrorHandler ! --------------------------------------------------------------------------- module procedure fclHandleBuildError !(builderrcode,prog,ctx) integer :: i ! Handle compilation error if ( builderrcode /= CL_SUCCESS ) then write ( * , * ) '(!) Fatal openCl error while building kernel: ' , builderrcode , ' : ' , trim ( fclGetErrorString ( builderrcode )) ! Iterate over context devices do i = 1 , ctx % platform % numDevice call fclDumpBuildLog ( ctx , prog , ctx % platform % devices ( i )) end do stop 1 end if end procedure fclHandleBuildError ! --------------------------------------------------------------------------- module procedure fclGetErrorString !(errcode) select case ( errcode ) case ( CL_DEVICE_NOT_FOUND ) errstr = 'CL_DEVICE_NOT_FOUND' case ( CL_DEVICE_NOT_AVAILABLE ) errstr = 'CL_DEVICE_NOT_AVAILABLE' case ( CL_COMPILER_NOT_AVAILABLE ) errstr = 'CL_COMPILER_NOT_AVAILABLE' case ( CL_MEM_OBJECT_ALLOCATION_FAILURE ) errstr = 'CL_MEM_OBJECT_ALLOCATION_FAILURE' case ( CL_OUT_OF_RESOURCES ) errstr = 'CL_OUT_OF_RESOURCES' case ( CL_OUT_OF_HOST_MEMORY ) errstr = 'CL_OUT_OF_HOST_MEMORY' case ( CL_PROFILING_INFO_NOT_AVAILABLE ) errstr = 'CL_PROFILING_INFO_NOT_AVAILABLE' case ( CL_MEM_COPY_OVERLAP ) errstr = 'CL_MEM_COPY_OVERLAP' case ( CL_BUILD_PROGRAM_FAILURE ) errstr = 'CL_BUILD_PROGRAM_FAILURE' case ( CL_MAP_FAILURE ) errstr = 'CL_MAP_FAILURE' case ( CL_MISALIGNED_SUB_BUFFER_OFFSET ) errstr = 'CL_MISALIGNED_SUB_BUFFER_OFFSET' case ( CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST ) errstr = 'CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST' case ( CL_COMPILE_PROGRAM_FAILURE ) errstr = 'CL_COMPILE_PROGRAM_FAILURE' case ( CL_LINKER_NOT_AVAILABLE ) errstr = 'CL_LINKER_NOT_AVAILABLE' case ( CL_LINK_PROGRAM_FAILURE ) errstr = 'CL_LINK_PROGRAM_FAILURE' case ( CL_DEVICE_PARTITION_FAILED ) errstr = 'CL_DEVICE_PARTITION_FAILED' case ( CL_KERNEL_ARG_INFO_NOT_AVAILABLE ) errstr = 'CL_KERNEL_ARG_INFO_NOT_AVAILABLE' case ( CL_INVALID_VALUE ) errstr = 'CL_INVALID_VALUE' case ( CL_INVALID_DEVICE_TYPE ) errstr = 'CL_INVALID_DEVICE_TYPE' case ( CL_INVALID_PLATFORM ) errstr = 'CL_INVALID_PLATFORM' case ( CL_INVALID_DEVICE ) errstr = 'CL_INVALID_DEVICE' case ( CL_INVALID_CONTEXT ) errstr = 'CL_INVALID_CONTEXT' case ( CL_INVALID_QUEUE_PROPERTIES ) errstr = 'CL_INVALID_QUEUE_PROPERTIES' case ( CL_INVALID_COMMAND_QUEUE ) errstr = 'CL_INVALID_COMMAND_QUEUE' case ( CL_INVALID_HOST_PTR ) errstr = 'CL_INVALID_HOST_PTR' case ( CL_INVALID_MEM_OBJECT ) errstr = 'CL_INVALID_MEM_OBJECT' case ( CL_INVALID_BINARY ) errstr = 'CL_INVALID_BINARY' case ( CL_INVALID_BUILD_OPTIONS ) errstr = 'CL_INVALID_BUILD_OPTIONS' case ( CL_INVALID_PROGRAM ) errstr = 'CL_INVALID_PROGRAM' case ( CL_INVALID_PROGRAM_EXECUTABLE ) errstr = 'CL_INVALID_PROGRAM_EXECUTABLE' case ( CL_INVALID_KERNEL_NAME ) errstr = 'CL_INVALID_KERNEL_NAME' case ( CL_INVALID_KERNEL_DEFINITION ) errstr = 'CL_INVALID_KERNEL_DEFINITION' case ( CL_INVALID_KERNEL ) errstr = 'CL_INVALID_KERNEL' case ( CL_INVALID_ARG_INDEX ) errstr = 'CL_INVALID_ARG_INDEX' case ( CL_INVALID_ARG_VALUE ) errstr = 'CL_INVALID_ARG_VALUE' case ( CL_INVALID_ARG_SIZE ) errstr = 'CL_INVALID_ARG_SIZE' case ( CL_INVALID_KERNEL_ARGS ) errstr = 'CL_INVALID_KERNEL_ARGS' case ( CL_INVALID_WORK_DIMENSION ) errstr = 'CL_INVALID_WORK_DIMENSION' case ( CL_INVALID_WORK_GROUP_SIZE ) errstr = 'CL_INVALID_WORK_GROUP_SIZE' case ( CL_INVALID_WORK_ITEM_SIZE ) errstr = 'CL_INVALID_WORK_ITEM_SIZE' case ( CL_INVALID_GLOBAL_OFFSET ) errstr = 'CL_INVALID_GLOBAL_OFFSET' case ( CL_INVALID_EVENT_WAIT_LIST ) errstr = 'CL_INVALID_EVENT_WAIT_LIST' case ( CL_INVALID_EVENT ) errstr = 'CL_INVALID_EVENT' case ( CL_INVALID_OPERATION ) errstr = 'CL_INVALID_OPERATION' case ( CL_INVALID_BUFFER_SIZE ) errstr = 'CL_INVALID_BUFFER_SIZE' case ( CL_INVALID_GLOBAL_WORK_SIZE ) errstr = 'CL_INVALID_GLOBAL_WORK_SIZE' case ( CL_INVALID_PROPERTY ) errstr = 'CL_INVALID_PROPERTY' case ( CL_INVALID_COMPILER_OPTIONS ) errstr = 'CL_INVALID_COMPILER_OPTIONS' case ( CL_INVALID_LINKER_OPTIONS ) errstr = 'CL_INVALID_LINKER_OPTIONS' case ( CL_INVALID_DEVICE_PARTITION_COUNT ) errstr = 'CL_INVALID_DEVICE_PARTITION_COUNT' case ( CL_PLATFORM_NOT_FOUND_KHR ) errstr = 'CL_PLATFORM_NOT_FOUND_KHR' case ( NV_ILLEGAL_BUFFER_READ_WRITE ) errstr = 'NVidia: Illegal read or write to a buffer' case default errstr = 'UNKNOWN' end select end procedure fclGetErrorString ! --------------------------------------------------------------------------- module procedure fclRuntimeError !(descrip) write ( * , * ) '(!) Fatal runtime error: an incorrect Focal program has been written.' if ( present ( descrip )) then write ( * , * ) '      at ' , descrip end if call c_abort () end procedure fclRuntimeError ! --------------------------------------------------------------------------- end submodule Focal_Error","tags":"","loc":"sourcefile/focal_error.f90.html"},{"title":"Focal_Memory.f90 – Focal API Reference","text":"Contents Submodules Focal_Memory Source Code Focal_Memory.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Memory !!  Implementation module !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran implicit none contains module procedure fclBufferSwap !(memObject1, memObject2) !! Helper routine for swapping device buffer pointers integer ( c_intptr_t ) :: tempPtr type ( fclCommandQ ), pointer :: tempCmdQ call fclDbgCheckBufferInit ( memObject1 , 'fclBufferSwap:memObject1' ) call fclDbgCheckBufferInit ( memObject2 , 'fclBufferSwap:memObject2' ) call fclDbgCheckCopyBufferSize ( memObject1 , memObject2 ) ! Swap OpenCL pointers tempPtr = memObject2 % cl_mem memObject2 % cl_mem = memObject1 % cl_mem memObject1 % cl_mem = tempPtr ! Swap command queue pointers tempCmdQ => memObject2 % cmdq memObject2 % cmdQ => memObject1 % cmdQ memObject1 % cmdQ => tempCmdQ end procedure fclBufferSwap ! --------------------------------------------------------------------------- module procedure fclInitBufferUntyped_1 !(cmdq,buffer,nBytes,profileName,access) !! Initialise untyped buffer object on specified command queue use M_strings , only : upperStr => upper integer ( c_int32_t ) :: errcode integer ( c_int64_t ) :: MEM_FLAGS integer ( c_intptr_t ), target :: cl_context integer ( c_size_t ) :: size_ret ! Get command queue context errcode = clGetCommandQueueInfo ( cmdq % cl_command_queue , & CL_QUEUE_CONTEXT , c_sizeof ( cl_context ), & c_loc ( cl_context ), size_ret ) call fclHandleError ( errcode , 'fclInitBuffer' , 'clGetCommandQueueInfo' ) ! Check kernel access flags if ( present ( access )) then buffer % kernelRead = index ( upperstr ( access ), 'R' ) > 0 buffer % kernelWrite = index ( upperstr ( access ), 'W' ) > 0 else buffer % kernelRead = . true . buffer % kernelWrite = . true . end if MEM_FLAGS = CL_MEM_READ_WRITE if (. not . buffer % kernelWrite . and .. not . buffer % kernelRead ) then call fclRuntimeError ( 'fclBuffer: memory must be at least read or write.' ) elseif (. not . buffer % kernelWrite ) then MEM_FLAGS = CL_MEM_READ_ONLY elseif (. not . buffer % kernelRead ) then MEM_FLAGS = CL_MEM_WRITE_ONLY end if buffer % cl_mem = clCreateBuffer ( cl_context , MEM_FLAGS , & nBytes , C_NULL_PTR , errcode ) call fclHandleError ( errcode , 'fclInitBuffer' , 'clCreateBuffer' ) buffer % nBytes = nBytes buffer % cmdq => cmdq if ( present ( profileName )) then if ( allocated ( buffer % profileName )) then deallocate ( buffer % profileName ) end if buffer % profileName = profileName end if end procedure fclInitBufferUntyped_1 ! --------------------------------------------------------------------------- module procedure fclInitBufferUntyped_2 !(buffer,nBytes,profileName,access) !! Initialise untyped buffer object on the default command queue call fclInitBufferUntyped_1 ( fclDefaultCmdQ , buffer , nBytes , profileName , access ) end procedure fclInitBufferUntyped_2 ! --------------------------------------------------------------------------- module procedure fclInitBufferFloat_1 !(cmdq,buffer,dim,profileName,access) !! Initialise float buffer object on specific command queue integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( real ( 1.0d0 , c_float )) * dim call fclInitBufferUntyped_1 ( cmdq , buffer % fclDeviceBuffer , nBytes , profileName , access ) end procedure fclInitBufferFloat_1 ! --------------------------------------------------------------------------- module procedure fclInitBufferFloat_2 !(buffer,dim,profileName,access) !! Initialise float buffer object on the default command queue call fclInitBufferFloat_1 ( fclDefaultCmdQ , buffer , dim , profileName , access ) end procedure fclInitBufferFloat_2 ! --------------------------------------------------------------------------- module procedure fclInitBufferDouble_1 !(cmdq,buffer,dim,profileName,access) !! Initialise double buffer object on specific command queue integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( real ( 1.0d0 , c_double )) * dim call fclInitBufferUntyped_1 ( cmdq , buffer % fclDeviceBuffer , nBytes , profileName , access ) end procedure fclInitBufferDouble_1 ! --------------------------------------------------------------------------- module procedure fclInitBufferDouble_2 !(buffer,dim,profileName,access) !! Initialise double buffer object on the default command queue call fclInitBufferDouble_1 ( fclDefaultCmdQ , buffer , dim , profileName , access ) end procedure fclInitBufferDouble_2 ! --------------------------------------------------------------------------- module procedure fclInitBufferInt32_1 !(cmdq,buffer,dim,profileName,access) !! Initialise 32bit integer buffer object on specific command queue integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( int ( 1 , c_int32_t )) * dim call fclInitBufferUntyped_1 ( cmdq , buffer % fclDeviceBuffer , nBytes , profileName , access ) end procedure fclInitBufferInt32_1 ! --------------------------------------------------------------------------- module procedure fclInitBufferInt32_2 !(buffer,dim,profileName,access) !! Initialise 32bit integer buffer object on the default command queue call fclInitBufferInt32_1 ( fclDefaultCmdQ , buffer , dim , profileName , access ) end procedure fclInitBufferInt32_2 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferUntyped_1 !(cmdq,subbuffer,sourceBuffer,offset,size,profileName,access) !! Initialise an untyped sub-buffer from an existing buffer use M_strings , only : upperStr => upper integer ( c_int32_t ) :: errcode integer ( c_int64_t ) :: MEM_FLAGS integer ( c_size_t ), target :: info ( 2 ) call fclDbgCheckBufferInit ( sourceBuffer , 'fclInitSubBuffer:sourceBuffer' ) ! Check kernel access flags if ( present ( access )) then subbuffer % kernelRead = index ( upperstr ( access ), 'R' ) > 0 subbuffer % kernelWrite = index ( upperstr ( access ), 'W' ) > 0 else subbuffer % kernelRead = . true . subbuffer % kernelWrite = . true . end if MEM_FLAGS = CL_MEM_READ_WRITE if (. not . subbuffer % kernelWrite . and .. not . subbuffer % kernelRead ) then call fclRuntimeError ( 'fclInitSubBuffer: memory must be at least read or write.' ) elseif (. not . subbuffer % kernelWrite ) then MEM_FLAGS = CL_MEM_READ_ONLY elseif (. not . subbuffer % kernelRead ) then MEM_FLAGS = CL_MEM_WRITE_ONLY end if ! Check for incompatible sub-buffer flags if (. not . sourceBuffer % kernelRead . and . subBuffer % kernelRead ) then call fclRuntimeError ( 'fclInitSubBuffer: sub-buffer cannot allow kernel read access if parent buffer does not.' ) end if if (. not . sourceBuffer % kernelWrite . and . subBuffer % kernelWrite ) then call fclRuntimeError ( 'fclInitSubBuffer: sub-buffer cannot allow kernel write access if parent buffer does not.' ) end if info ( 1 ) = offset info ( 2 ) = size subBuffer % cl_mem = clCreateSubBuffer ( sourceBuffer % cl_mem , MEM_FLAGS , & CL_BUFFER_CREATE_TYPE_REGION , c_loc ( info ), errcode ) call fclHandleError ( errcode , 'fclInitSubBuffer' , 'clCreateSubBuffer' ) subBuffer % nBytes = size subBuffer % cmdq => cmdq if ( present ( profileName )) then if ( allocated ( subBuffer % profileName )) then deallocate ( subBuffer % profileName ) end if subBuffer % profileName = profileName end if end procedure fclInitSubBufferUntyped_1 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferUntyped_2 !(subbuffer,sourceBuffer,offset,size,profileName,access) !! Initialise an untyped sub-buffer from an existing buffer on the default command queue call fclInitSubBufferUntyped_1 ( fclDefaultCmdQ , subbuffer , sourceBuffer , offset , size , profileName , access ) end procedure fclInitSubBufferUntyped_2 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferFloat_1 !(cmdq,subbuffer,sourceBuffer,start,length,profileName,access) !! Initialise a float sub-buffer from an existing float buffer integer ( c_size_t ) :: offset , size offset = start * c_sizeof ( real ( 1.0 , c_float )) size = length * c_sizeof ( real ( 1.0 , c_float )) call fclInitSubBufferUntyped_1 ( cmdq , subbuffer % fclDeviceBuffer , sourceBuffer , offset , size , profileName , access ) end procedure fclInitSubBufferFloat_1 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferFloat_2 !(subbuffer,sourceBuffer,start,length,profileName,access) !! Initialise a float sub-buffer from an existing float buffer on default command queue call fclInitSubBufferFloat_1 ( fclDefaultCmdQ , subbuffer , sourceBuffer , start , length , profileName , access ) end procedure fclInitSubBufferFloat_2 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferDouble_1 !(cmdq,subbuffer,sourceBuffer,start,length,profileName,access) !! Initialise a float sub-buffer from an existing float buffer integer ( c_size_t ) :: offset , size offset = start * c_sizeof ( real ( 1.0d0 , c_double )) size = length * c_sizeof ( real ( 1.0d0 , c_double )) call fclInitSubBufferUntyped_1 ( cmdq , subbuffer % fclDeviceBuffer , sourceBuffer , offset , size , profileName , access ) end procedure fclInitSubBufferDouble_1 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferDouble_2 !(subbuffer,sourceBuffer,start,length,profileName,access) !! Initialise a float sub-buffer from an existing float buffer on default command queue call fclInitSubBufferDouble_1 ( fclDefaultCmdQ , subbuffer , sourceBuffer , start , length , profileName , access ) end procedure fclInitSubBufferDouble_2 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferint32_1 !(cmdq,subbuffer,sourceBuffer,start,length,profileName,access) !! Initialise a 32bit integer sub-buffer from an existing float buffer integer ( c_size_t ) :: offset , size offset = start * c_sizeof ( int ( 1 , c_int32_t )) size = length * c_sizeof ( int ( 1 , c_int32_t )) call fclInitSubBufferUntyped_1 ( cmdq , subbuffer % fclDeviceBuffer , sourceBuffer , offset , size , profileName , access ) end procedure fclInitSubBufferint32_1 ! --------------------------------------------------------------------------- module procedure fclInitSubBufferint32_2 !(subbuffer,sourceBuffer,start,length,profileName,access) !! Initialise a 32bit integer sub-buffer from an existing float buffer on default command queue call fclInitSubBufferint32_1 ( fclDefaultCmdQ , subbuffer , sourceBuffer , start , length , profileName , access ) end procedure fclInitSubBufferint32_2 ! --------------------------------------------------------------------------- module procedure fclMemWriteScalar !(memObject,hostBufferPtr,nBytesPattern) integer ( c_int32_t ) :: errcode type ( fclEvent ), target :: writeEvent call fclDbgCheckBufferInit ( memObject , 'fclMemWriteScalar' ) errcode = clEnqueueFillBuffer ( memObject % cmdq % cl_command_queue , & memObject % cl_mem , hostBufferPtr , nBytesPattern , & int ( 0 , c_size_t ), memObject % nBytes , & memObject % cmdq % nDependency , memObject % cmdq % dependencyListPtr , & c_loc ( writeEvent % cl_event )) call fclPopDependencies ( memObject % cmdq ) fclLastWriteEvent = writeEvent memObject % cmdq % lastWriteEvent = writeEvent call memObject % pushProfileEvent ( writeEvent , 1 ) call fclHandleError ( errcode , 'fclMemWriteScalar' , 'clEnqueueFillBuffer' ) end procedure fclMemWriteScalar ! --------------------------------------------------------------------------- module procedure fclMemWriteScalarInt32 !(memObject,hostValue) integer ( c_size_t ) :: nBytesPattern nBytesPattern = c_sizeof ( int ( 1 , c_int32_t )) call fclMemWriteScalar ( memObject , c_loc ( hostValue ), nBytesPattern ) end procedure fclMemWriteScalarInt32 ! --------------------------------------------------------------------------- module procedure fclMemWriteScalarFloat !(memObject,hostValue) integer ( c_size_t ) :: nBytesPattern nBytesPattern = c_sizeof ( real ( 1.0 , c_float )) call fclMemWriteScalar ( memObject , c_loc ( hostValue ), nBytesPattern ) end procedure fclMemWriteScalarFloat ! --------------------------------------------------------------------------- module procedure fclMemWriteScalarDouble !(memObject,hostValue) integer ( c_size_t ) :: nBytesPattern nBytesPattern = c_sizeof ( real ( 1.0d0 , c_double )) call fclMemWriteScalar ( memObject , c_loc ( hostValue ), nBytesPattern ) end procedure fclMemWriteScalarDouble ! --------------------------------------------------------------------------- module procedure fclMemWrite !(memObject,hostBufferPtr,nBytes) integer ( c_int32_t ) :: errcode integer ( c_int32_t ) :: blocking_write type ( fclEvent ), target :: writeEvent call fclDbgCheckBufferInit ( memObject , 'fclMemWrite' ) call fclDbgCheckBufferSize ( memObject , nBytes , 'fclMemWrite' ) if ( memObject % cmdq % blockingWrite ) then blocking_write = CL_TRUE else blocking_write = CL_FALSE end if errcode = clEnqueueWriteBuffer ( memObject % cmdq % cl_command_queue , memObject % cl_mem , & blocking_write , int ( 0 , c_size_t ), nBytes , hostBufferPtr , & memObject % cmdq % nDependency , memObject % cmdq % dependencyListPtr , & c_loc ( writeEvent % cl_event )) call fclPopDependencies ( memObject % cmdq ) fclLastWriteEvent = writeEvent memObject % cmdq % lastWriteEvent = writeEvent call memObject % pushProfileEvent ( writeEvent , 1 ) call fclHandleError ( errcode , 'fclMemWrite' , 'clEnqueueWriteBuffer' ) end procedure fclMemWrite ! --------------------------------------------------------------------------- module procedure fclMemWriteInt32 !(memObject,hostBuffer) integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( int ( 1 , c_int32_t )) * size ( hostBuffer , 1 ) call fclMemWrite ( memObject , c_loc ( hostBuffer ), nBytes ) end procedure fclMemWriteInt32 ! --------------------------------------------------------------------------- module procedure fclMemWriteFloat !(memObject,hostBuffer) integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( real ( 1.0 , c_float )) * size ( hostBuffer , 1 ) call fclMemWrite ( memObject , c_loc ( hostBuffer ), nBytes ) end procedure fclMemWriteFloat ! --------------------------------------------------------------------------- module procedure fclMemWriteDouble !(memObject,hostBuffer) integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( real ( 1.0d0 , c_double )) * size ( hostBuffer , 1 ) call fclMemWrite ( memObject , c_loc ( hostBuffer ), nBytes ) end procedure fclMemWriteDouble ! --------------------------------------------------------------------------- module procedure fclMemRead !(hostBufferPtr,memObject,nBytes) integer ( c_int32_t ) :: errcode integer ( c_int32_t ) :: blocking_read type ( fclEvent ), target :: readEvent call fclDbgCheckBufferInit ( memObject , 'fclMemRead' ) call fclDbgCheckBufferSize ( memObject , nBytes , 'fclMemRead' ) if ( memObject % cmdq % blockingRead ) then blocking_read = CL_TRUE else blocking_read = CL_FALSE end if errcode = clEnqueueReadBuffer ( memObject % cmdq % cl_command_queue , memObject % cl_mem , & blocking_read , int ( 0 , c_size_t ), nBytes , hostBufferPtr , & memObject % cmdq % nDependency , memObject % cmdq % dependencyListPtr , & c_loc ( readEvent % cl_event )) call fclPopDependencies ( memObject % cmdq ) fclLastReadEvent = readEvent memObject % cmdq % lastReadEvent = readEvent call memObject % pushProfileEvent ( readEvent , 2 ) call fclHandleError ( errcode , 'fclMemRead' , 'clEnqueueReadBuffer' ) end procedure fclMemRead ! --------------------------------------------------------------------------- module procedure fclMemReadInt32 !(hostBuffer,memObject) integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( int ( 1 , c_int32_t )) * size ( hostBuffer , 1 ) call fclMemRead ( c_loc ( hostBuffer ), memObject , nBytes ) end procedure fclMemReadInt32 ! --------------------------------------------------------------------------- module procedure fclMemReadFloat !(hostBuffer,memObject) integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( real ( 1 , c_float )) * size ( hostBuffer , 1 ) call fclMemRead ( c_loc ( hostBuffer ), memObject , nBytes ) end procedure fclMemReadFloat ! --------------------------------------------------------------------------- module procedure fclMemReadDouble !(hostBuffer,memObject) integer ( c_size_t ) :: nBytes nBytes = c_sizeof ( real ( 1 , c_double )) * size ( hostBuffer , 1 ) call fclMemRead ( c_loc ( hostBuffer ), memObject , nBytes ) end procedure fclMemReadDouble ! --------------------------------------------------------------------------- module procedure fclMemCopy !(memObject1,memObject2) integer ( c_int32_t ) :: errcode type ( fclEvent ), target :: copyEvent if ( memObject2 % nBytes < 0 ) then ! Source object is uninitialised: nothing to copy call fclRuntimeError ( 'fclMemCopy: source memory object is uninitialised.' ) else if ( memObject1 % nBytes < 0 ) then ! Receiving memory object is uninitialised !  therefore copy host pointer from source object memObject1 % cl_mem = memObject2 % cl_mem memObject1 % cmdQ => memObject2 % cmdQ memObject1 % nBytes = memObject2 % nBytes if ( allocated ( memObject2 % profileName )) then memObject1 % profileName = memObject2 % profileName end if if ( memObject2 % profilingEnabled ) then memObject1 % profilingEnabled = memObject2 % profilingEnabled memObject1 % profileEvents = memObject2 % profileEvents memObject1 % profileSize = memObject2 % profileSize memObject1 % nProfileEvent = memObject2 % nProfileEvent memObject1 % profileEventType = memObject2 % profileEventType end if else ! Receiving memory object is initialised !  therefore perform a device-to-device copy call fclDbgCheckCopyBufferSize ( memObject1 , memObject2 ) errcode = clEnqueueCopyBuffer ( memObject1 % cmdq % cl_command_queue , & memObject2 % cl_mem , memObject1 % cl_mem , & int ( 0 , c_size_t ), int ( 0 , c_size_t ), & memObject2 % nBytes , & memObject1 % cmdq % nDependency , memObject1 % cmdq % dependencyListPtr , & c_loc ( copyEvent % cl_event )) call fclPopDependencies ( memObject1 % cmdq ) fclLastCopyEvent = copyEvent memObject1 % cmdq % lastCopyEvent = copyEvent call memObject1 % pushProfileEvent ( copyEvent , 3 ) call fclHandleError ( errcode , 'fclMemCopy' , 'clEnqueueCopyBuffer' ) end if end procedure fclMemCopy ! --------------------------------------------------------------------------- module procedure fclMemCopyInt32 !(memObject1,memObject2) call fclMemCopy ( memObject1 , memObject2 ) end procedure fclMemCopyInt32 ! --------------------------------------------------------------------------- module procedure fclMemCopyFloat !(memObject1,memObject2) call fclMemCopy ( memObject1 , memObject2 ) end procedure fclMemCopyFloat ! --------------------------------------------------------------------------- module procedure fclMemCopyDouble !(memObject1,memObject2) call fclMemCopy ( memObject1 , memObject2 ) end procedure fclMemCopyDouble ! --------------------------------------------------------------------------- module procedure fclFreeBuffer !(memObject) !! Release device memory associated with memObject integer ( c_int32_t ) :: errcode call fclDbgCheckBufferInit ( memObject , 'fclFreeBuffer' ) errcode = clReleaseMemObject ( memObject % cl_mem ) call fclHandleError ( errcode , 'fclFreeBuffer' , 'clReleaseMemObject' ) memObject % nBytes = - 1 end procedure fclFreeBuffer ! --------------------------------------------------------------------------- end submodule Focal_Memory","tags":"","loc":"sourcefile/focal_memory.f90.html"},{"title":"Focal_Profile.f90 – Focal API Reference","text":"Contents Submodules Focal_Profile Source Code Focal_Profile.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Profile !!  Implementation module for openCL profiling routines !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran implicit none contains module procedure fclProfilerAdd !(profiler,profileSize,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9) !! Enable profiling for multiple containers (kernel/buffer) and add to profiler collection call fclEnableProfiling ( c0 , profileSize , profiler ) if ( present ( c1 )) then call fclEnableProfiling ( c1 , profileSize , profiler ) end if if ( present ( c2 )) then call fclEnableProfiling ( c2 , profileSize , profiler ) end if if ( present ( c3 )) then call fclEnableProfiling ( c3 , profileSize , profiler ) end if if ( present ( c4 )) then call fclEnableProfiling ( c4 , profileSize , profiler ) end if if ( present ( c5 )) then call fclEnableProfiling ( c5 , profileSize , profiler ) end if if ( present ( c6 )) then call fclEnableProfiling ( c6 , profileSize , profiler ) end if if ( present ( c7 )) then call fclEnableProfiling ( c7 , profileSize , profiler ) end if if ( present ( c8 )) then call fclEnableProfiling ( c8 , profileSize , profiler ) end if if ( present ( c9 )) then call fclEnableProfiling ( c9 , profileSize , profiler ) end if end procedure fclProfilerAdd ! --------------------------------------------------------------------------- module procedure fclEnableProfiling !(container,profileSize,profiler) !! Enable profiling on a specific container by allocating space to save events type ( fclKernelPointer ), allocatable :: kernelsTemp (:) type ( fclBufferPointer ), allocatable :: buffersTemp (:) container % profilingEnabled = . true . ! ------ Allocate space for event objects ------ if ( associated ( container % profileEvents )) then deallocate ( container % profileEvents ) end if allocate ( container % profileEvents ( profileSize )) if ( associated ( container % nProfileEvent )) then deallocate ( container % nProfileEvent ) end if allocate ( container % nProfileEvent ) if ( associated ( container % profileEventType )) then deallocate ( container % profileEventType ) end if allocate ( container % profileEventType ( profileSize )) container % nProfileEvent = 0 container % profileSize = profileSize ! ------ Set profile name, if not specified ------ if (. not . allocated ( container % profileName )) then select type ( c => container ) class is ( fclKernel ) ! allocate(character(len=len(c%name)) :: container%profileName) container % profileName = c % name class is ( fclDeviceBuffer ) ! write(tempStr,'(I10)') c%nBytes container % profileName = 'Unnamed' ! ('//trim(tempStr)//'B)' end select end if ! ------ Add to profiler collection object, if specified ------ if ( present ( profiler )) then select type ( c => container ) type is ( fclKernel ) ! ------ Kernels ------ profiler % nKernels = profiler % nKernels + 1 if (. not . allocated ( profiler % kernels )) then ! --- Allocate for first time --- allocate ( profiler % kernels ( fclAllocationSize )) else if ( profiler % nKernels > size ( profiler % kernels , 1 )) then ! --- Need to reallocate --- kernelsTemp = profiler % kernels deallocate ( profiler % kernels ) allocate ( profiler % kernels ( profiler % nKernels + fclAllocationSize )) profiler % kernels ( 1 : size ( kernelsTemp , 1 )) = kernelsTemp deallocate ( kernelsTemp ) end if end if profiler % kernels ( profiler % nKernels )% target => c class is ( fclDeviceBuffer ) ! ------ Buffers ------ profiler % nBuffers = profiler % nBuffers + 1 if (. not . allocated ( profiler % buffers )) then ! --- Allocate for first time --- allocate ( profiler % buffers ( fclAllocationSize )) else if ( profiler % nBuffers > size ( profiler % buffers , 1 )) then ! --- Need to reallocate --- buffersTemp = profiler % buffers deallocate ( profiler % buffers ) allocate ( profiler % buffers ( profiler % nBuffers + fclAllocationSize )) profiler % buffers ( 1 : size ( buffersTemp , 1 )) = buffersTemp deallocate ( buffersTemp ) end if end if profiler % buffers ( profiler % nBuffers )% target => c class default end select end if end procedure fclEnableProfiling ! --------------------------------------------------------------------------- module procedure fclPushProfileEvent !(container,event,type) !! If profiling is enabled for the container, save an event to it integer ( c_int32_t ) :: errcode if (. not . container % profilingEnabled ) then return end if ! Increment number of events container % nProfileEvent = container % nProfileEvent + 1 ! Don't save if exceeded profile size !  (Only first profileSize events are saved) if ( container % nProfileEvent > container % profileSize ) then return end if ! Save event container % profileEvents ( container % nProfileEvent ) = event ! Save event type if specified if ( present ( type )) then container % profileEventType ( container % nProfileEvent ) = type end if end procedure fclPushProfileEvent ! --------------------------------------------------------------------------- module procedure fclGetEventDurations !(eventList) result(durations) integer :: i , N integer ( c_int32_t ) :: errcode integer ( c_int64_t ), target :: startTime , endTime integer ( c_size_t ) :: size_ret N = size ( eventList , 1 ) ! Iterate over kernel profile events do i = 1 , N ! Get event start time errcode = clGetEventProfilingInfo ( eventList ( i )% cl_event , & CL_PROFILING_COMMAND_START , c_sizeof ( startTime ), c_loc ( startTime ), size_ret ) call fclHandleError ( errcode , 'fclGetProfileEventDurations' , 'clGetEventProfilingInfo' ) ! Get event end time errcode = clGetEventProfilingInfo ( eventList ( i )% cl_event , & CL_PROFILING_COMMAND_END , c_sizeof ( endTime ), c_loc ( endTime ), size_ret ) call fclHandleError ( errcode , 'fclGetProfileEventDurations' , 'clGetEventProfilingInfo' ) ! Save duration (nanoseconds) durations ( i ) = endTime - startTime end do end procedure fclGetEventDurations ! --------------------------------------------------------------------------- module procedure fclDumpProfileData !(profiler,outputUnit) !! Dump summary of profiler data for list of kernels to specific output unit use iso_fortran_env , only : stdout => output_unit integer :: i , unit type ( fclKernel ), allocatable :: kernels (:) type ( fclDeviceBuffer ), allocatable :: buffers (:) call fclDbgCheckDevice ( profiler % device , 'fclDumpProfileData. ' // & '(Has the profiler%device been set?)' ) if (. not . present ( outputUnit )) then unit = stdout else unit = outputUnit end if if ( profiler % nKernels > 0 ) then allocate ( kernels ( profiler % nKernels )) do i = 1 , profiler % nKernels kernels ( i ) = profiler % kernels ( i )% target end do call fclDumpKernelProfileData ( unit , kernels , profiler % device ) deallocate ( kernels ) end if if ( profiler % nBuffers > 0 ) then allocate ( buffers ( profiler % nBuffers )) do i = 1 , profiler % nBuffers buffers ( i ) = profiler % buffers ( i )% target end do call fclDumpBufferProfileData ( unit , buffers ) deallocate ( buffers ) end if end procedure fclDumpProfileData ! --------------------------------------------------------------------------- module procedure fclDumpKernelProfileData !(outputUnit,kernelList,device) !! Dump summary of profile data for list of kernels to specific output unit use iso_fortran_env , only : sp => real32 integer :: k , i , N integer ( c_int64_t ), allocatable :: durations (:) integer ( c_int64_t ) :: localMem , privateMem , preferredWorkGroup logical :: profileSizeWarning profileSizeWarning = . false . ! Get allocation size for durations array N = 0 do k = 1 , size ( kernelList , 1 ) N = max ( N , kernelList ( k )% profileSize ) end do ! Allocate durations array allocate ( durations ( N )) ! Write table header write ( outputUnit , * ) ( '-' , i = 1 , 77 ) write ( outputUnit , '(A20,A1,A8,A1,A8,A1,A8,A1,A8,A1,A6,A1,A6,A1,A4)' ) & 'Profile name' , '|' , 'No. of' , '|' , 'T_avg' , '|' , 'T_max' , '|' , 'T_min' , '|' ,& 'Local' , '|' , 'Private' , '|' , 'PWGS' write ( outputUnit , '(A20,A1,A8,A1,A8,A1,A8,A1,A8,A1,A6,A1,A6,A1,A4)' ) & '(Kernel)' , '|' , 'events' , '|' , '(ns)' , '|' , '(ns)' , '|' , '(ns)' , '|' ,& 'Mem.' , '|' , 'Mem.' , '|' , '' write ( outputUnit , * ) ( '-' , i = 1 , 77 ) durations = 0 localMem = 0 privateMem = 0 preferredWorkGroup = 0 ! Iterate over list of kernels do k = 1 , size ( kernelList , 1 ) associate ( kern => kernelList ( k )) if (. not . kern % profilingEnabled ) then cycle end if ! Get kernel info call fclGetKernelWorkGroupInfo ( kern , device , CL_KERNEL_LOCAL_MEM_SIZE , localMem ) call fclGetKernelWorkGroupInfo ( kern , device , CL_KERNEL_PRIVATE_MEM_SIZE , privateMem ) call fclGetKernelWorkGroupInfo ( kern , device , CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE , & preferredWorkGroup ) N = min ( kern % profileSize , kern % nProfileEvent ) durations ( 1 : N ) = fclGetEventDurations ( kern % profileEvents ( 1 : N )) ! Minimum of 100 nanosecond resolution durations = max ( durations , int ( 100 , c_int64_t )) ! Write to table if ( N > 0 ) then if ( kern % nProfileEvent > kern % profileSize ) then write ( outputUnit , '(A20,A1,I8,A1,I8,A1,I8,A1,I8,A1,I6,A1,I6,A1,I4,A)' ) & kern % profileName , '|' , kern % nProfileEvent , '|' , sum ( durations ( 1 : N )) / N , '|' ,& maxval ( durations ( 1 : N )), '|' , minval ( durations ( 1 : N )), '|' ,& localMem , '|' , privateMem , '|' , preferredWorkGroup , ' *' profileSizeWarning = . true . else write ( outputUnit , '(A20,A1,I8,A1,I8,A1,I8,A1,I8,A1,I6,A1,I6,A1,I4)' ) & kern % profileName , '|' , kern % nProfileEvent , '|' , sum ( durations ( 1 : N )) / N , '|' , & maxval ( durations ( 1 : N )), '|' , minval ( durations ( 1 : N )), '|' ,& localMem , '|' , privateMem , '|' , preferredWorkGroup end if end if end associate end do ! Table footer write ( outputUnit , * ) ( '-' , i = 1 , 77 ) if ( profileSizeWarning ) then write ( outputUnit , * ) ' * - Not all events profiled, increase profileSize' end if write ( outputUnit , * ) ' ns: nanoseconds,  PWGS: Preferred work group size,  Mem: Memory in bytes.' write ( outputUnit , * ) ( '-' , i = 1 , 77 ) write ( outputUnit , * ) '' ! Deallocate durations array deallocate ( durations ) end procedure fclDumpKernelProfileData ! --------------------------------------------------------------------------- module procedure fclDumpBufferProfileData !(outputUnit,bufferList1,bufferList2,bufferList3) !! Dump summary of profile data for list of buffers to specific output unit use iso_fortran_env , only : sp => real32 integer :: k , i , N , m , bl integer ( c_int64_t ), allocatable :: durations (:) real ( sp ) :: S_avg , S_min , S_max class ( fclDeviceBuffer ), pointer :: bList (:) character ( 5 ), parameter :: modes ( 3 ) = [ 'WRITE' , 'READ ' , 'COPY ' ] logical :: profileSizeWarning profileSizeWarning = . false . ! Get allocation size for durations array N = 0 do k = 1 , size ( bufferList1 , 1 ) N = max ( N , bufferList1 ( k )% profileSize ) end do if ( present ( bufferList2 )) then do k = 1 , size ( bufferList2 , 1 ) N = max ( N , bufferList2 ( k )% profileSize ) end do end if if ( present ( bufferList3 )) then do k = 1 , size ( bufferList3 , 1 ) N = max ( N , bufferList3 ( k )% profileSize ) end do end if ! Allocate durations array allocate ( durations ( N )) ! Write table header write ( outputUnit , * ) ( '-' , i = 1 , 77 ) write ( outputUnit , '(A20,A1,A8,A1,A8,A1,A8,A1,A8,A1,A8,A1,A8)' ) & 'Profile name' , '|' , 'No. of' , '|' , 'Size' , '|' , 'Transfer' , '|' , 'S_avg' , '|' , 'S_max' , '|' , 'S_min' write ( outputUnit , '(A20,A1,A8,A1,A8,A1,A8,A1,A8,A1,A8,A1,A8)' ) & '(Buffer)' , '|' , 'events' , '|' , '(KBytes)' , '|' , 'mode' , '|' , '(GB/S)' , '|' , '(GB/S)' , '|' , '(GB/S)' write ( outputUnit , * ) ( '-' , i = 1 , 77 ) durations = 0 ! Iterate over list of buffers do bl = 1 , 3 if ( bl == 1 ) then bList ( 1 : size ( bufferList1 , 1 )) => bufferList1 ( 1 : size ( bufferList1 , 1 )) else if ( bl == 2 ) then if (. not . present ( bufferList2 )) then exit else bList ( 1 : size ( bufferList2 , 1 )) => bufferList2 ( 1 : size ( bufferList2 , 1 )) end if elseif ( bl == 3 ) then if (. not . present ( bufferList3 )) then exit else bList ( 1 : size ( bufferList3 , 1 )) => bufferList3 ( 1 : size ( bufferList3 , 1 )) end if end if do k = 1 , size ( bList , 1 ) associate ( buff => bList ( k )) if (. not . buff % profilingEnabled ) then cycle end if N = min ( buff % profileSize , buff % nProfileEvent ) durations ( 1 : N ) = fclGetEventDurations ( buff % profileEvents ( 1 : N )) ! Minimum of 100 nanosecond resolution durations = max ( durations , int ( 100 , c_int64_t )) ! Write to table, iterate over write,read,copy do i = 1 , 3 m = count ( buff % profileEventType ( 1 : N ) == i ) if ( m > 0 ) then S_avg = real ( buff % nBytes , sp ) / ( real ( sum ( durations ( 1 : N ), mask = buff % profileEventType ( 1 : N ) == i ), sp ) / m ) S_max = real ( buff % nBytes , sp ) / real ( minval ( durations ( 1 : N ), mask = buff % profileEventType ( 1 : N ) == i ), sp ) S_min = real ( buff % nBytes , sp ) / real ( maxval ( durations ( 1 : N ), mask = buff % profileEventType ( 1 : N ) == i ), sp ) if ( buff % nProfileEvent > buff % profileSize ) then write ( outputUnit , '(A20,A1,I8,A1,I8,A1,A8,A1,F8.4,A1,F8.4,A1,F8.4,A)' ) & buff % profileName , '|' , buff % nProfileEvent , '|' , buff % nBytes / 1000 , '|' , modes ( i ), '|' ,& S_avg , '|' , S_max , '|' , S_min , ' *' profileSizeWarning = . true . else write ( outputUnit , '(A20,A1,I8,A1,I8,A1,A8,A1,F8.4,A1,F8.4,A1,F8.4)' ) & buff % profileName , '|' , buff % nProfileEvent , '|' , buff % nBytes / 1000 , '|' , modes ( i ), '|' ,& S_avg , '|' , S_max , '|' , S_min end if end if end do end associate end do end do ! Table footer write ( outputUnit , * ) ( '-' , i = 1 , 77 ) if ( profileSizeWarning ) then write ( outputUnit , * ) ' * - Not all events profiled, increase profileSize' write ( outputUnit , * ) ( '-' , i = 1 , 77 ) end if write ( outputUnit , * ) '' ! Deallocate durations array deallocate ( durations ) end procedure fclDumpBufferProfileData ! --------------------------------------------------------------------------- module procedure fclDumpTracingData !(profiler,filename) integer :: fh , kb , j , i , N , tid integer ( c_intptr_t ), target :: qid integer ( c_int32_t ) :: errcode integer ( c_int64_t ), target :: startTime , endTime integer ( c_size_t ) :: size_ret logical :: isFirstEvent type ( fclKernel ), allocatable , target :: kernels (:) type ( fclDeviceBuffer ), allocatable , target :: buffers (:) class ( fclProfileContainer ), pointer :: containers (:) isFirstEvent = . true . open ( newunit = fh , file = filename , status = 'unknown' ) write ( fh , * ) '[' do kb = 1 , 2 if ( kb == 1 ) then if ( profiler % nKernels > 0 ) then allocate ( kernels ( profiler % nKernels )) do i = 1 , profiler % nKernels kernels ( i ) = profiler % kernels ( i )% target end do ! deallocate(kernels) containers => kernels tid = 1 else cycle end if else if ( kb == 2 ) then if ( profiler % nBuffers > 0 ) then allocate ( buffers ( profiler % nBuffers )) do i = 1 , profiler % nBuffers buffers ( i ) = profiler % buffers ( i )% target end do ! deallocate(buffers) containers => buffers tid = 2 else cycle end if end if do j = 1 , size ( containers , 1 ) associate ( profileContainer => containers ( j )) N = min ( profileContainer % profileSize , profileContainer % nProfileEvent ) ! Iterate over kernel profile events do i = 1 , N ! Get event start time errcode = clGetEventProfilingInfo ( profileContainer % profileEvents ( i )% cl_event , & CL_PROFILING_COMMAND_START , c_sizeof ( startTime ), c_loc ( startTime ), size_ret ) call fclHandleError ( errcode , 'fclGetProfileEventDurations' , 'clGetEventProfilingInfo' ) ! Get event end time errcode = clGetEventProfilingInfo ( profileContainer % profileEvents ( i )% cl_event , & CL_PROFILING_COMMAND_END , c_sizeof ( endTime ), c_loc ( endTime ), size_ret ) call fclHandleError ( errcode , 'fclGetProfileEventDurations' , 'clGetEventProfilingInfo' ) ! Get event command queue errcode = clGetEventInfo ( profileContainer % profileEvents ( i )% cl_event , & CL_EVENT_COMMAND_QUEUE , c_sizeof ( qid ), c_loc ( qid ), size_ret ) call fclHandleError ( errcode , 'fclGetProfileEventDurations' , 'clGetEventInfo' ) if (. not . isFirstEvent ) then write ( fh , * ) ',' else isFirstEvent = . false . end if write ( fh , * ) '{' write ( fh , * ) '\"cat\": \"Focal\",' write ( fh , * ) '\"pid\": 1, \"tid\": ' , qid , ',' write ( fh , * ) '\"ts\": ' , startTime / 1000 , ',' write ( fh , * ) '\"ph\": \"B\",' write ( fh , * ) '\"name\": \"' , profileContainer % profileName , '\"' write ( fh , * ) '},' write ( fh , * ) '{' write ( fh , * ) '\"cat\": \"Focal\",' write ( fh , * ) '\"pid\": 1, \"tid\": ' , qid , ',' write ( fh , * ) '\"ts\": ' , endTime / 1000 , ',' write ( fh , * ) '\"ph\": \"E\",' write ( fh , * ) '\"name\": \"' , profileContainer % profileName , '\"' write ( fh , * ) '}' end do ! loop over container events end associate end do ! loop over containers if ( allocated ( kernels )) then deallocate ( kernels ) end if if ( allocated ( buffers )) then deallocate ( buffers ) end if end do ! loop between kernels and buffers write ( fh , * ) ',{\"name\": \"process_name\", \"ph\": \"M\", \"pid\": 1, \"tid\": 1,' write ( fh , * ) '\"args\": {\"name\" : \"OpenCL device: ' , profiler % device % name , '\"}' write ( fh , * ) '}' write ( fh , * ) ',{\"name\": \"thread_name\", \"ph\": \"M\", \"pid\": 1, \"tid\": 1,' write ( fh , * ) '\"args\": {\"name\" : \"Kernels\"}' write ( fh , * ) '}' write ( fh , * ) ',{\"name\": \"thread_name\", \"ph\": \"M\", \"pid\": 1, \"tid\": 2,' write ( fh , * ) '\"args\": {\"name\" : \"Buffers\"}' write ( fh , * ) '}' write ( fh , * ) ']' close ( fh ) end procedure fclDumpTracingData ! --------------------------------------------------------------------------- end submodule Focal_Profile","tags":"","loc":"sourcefile/focal_profile.f90.html"},{"title":"Focal_HostMemory.f90 – Focal API Reference","text":"Contents Submodules Focal_HostMemory Source Code Focal_HostMemory.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_HostMemory !!  Implementation module !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran implicit none contains module procedure fclAllocHostPtr_1 !(cmdq,hostPtr,nBytes) !! Allocate a 'pinned' (non-paged) host array integer ( c_int32_t ) :: errcode integer ( c_intptr_t ), target :: cl_context integer ( c_size_t ) :: size_ret integer :: n , i integer ( c_intptr_t ) :: devicePtr integer ( c_intptr_t ), allocatable :: mapTemp (:,:) integer ( c_intptr_t ), target :: mapEvent ! Find space to store device pointer map if (. not . allocated ( fclHostPtrMap )) then !! Allocate for first time allocate ( fclHostPtrMap ( fclAllocationSize , 2 )) fclHostPtrMap = - 1 n = 1 else n = minloc ([( i , i = 1 , size ( fclHostPtrMap , 1 ))], dim = 1 , mask = fclHostPtrMap (:, 1 ) ==- 1 ) if ( n == 0 ) then allocate ( mapTemp ( size ( fclHostPtrMap , 1 ), 2 )) mapTemp = fclHostPtrMap n = fclAllocationSize * ( 1 + ( size ( fclHostPtrMap , 1 ) / fclAllocationSize )) deallocate ( fclHostPtrMap ) allocate ( fclHostPtrMap ( n , 2 )) fclHostPtrMap ( 1 : size ( mapTemp , 1 ),:) = mapTemp fclHostPtrMap ( size ( mapTemp , 1 ) + 1 :,:) = - 1 n = size ( mapTemp , 1 ) + 1 deallocate ( mapTemp ) end if end if ! Get command queue context errcode = clGetCommandQueueInfo ( cmdq % cl_command_queue , & CL_QUEUE_CONTEXT , c_sizeof ( cl_context ), & c_loc ( cl_context ), size_ret ) call fclHandleError ( errcode , 'fclAllocHostPtr' , 'clGetCommandQueueInfo' ) devicePtr = clCreateBuffer ( cl_context , CL_MEM_ALLOC_HOST_PTR , nBytes ,& C_NULL_PTR , errcode ) call fclErrorhandler ( errcode , 'fclAllocHostPtr' , 'clCreateBuffer' ) fclHostPtrMap ( n , 2 ) = devicePtr hostPtr = clEnqueueMapBuffer ( cmdq % cl_command_queue ,& devicePtr , CL_TRUE ,& ior ( CL_MAP_WRITE , CL_MAP_READ ), int ( 0 , c_int64_t ), nBytes , 0 ,& C_NULL_PTR , c_loc ( mapEvent ), errcode ) call fclErrorhandler ( errcode , 'fclAllocHostPtr' , 'clEnqueueMapBuffer' ) errcode = clWaitForEvents ( 1 , c_loc ( mapEvent )) call fclErrorhandler ( errcode , 'fclAllocHostPtr' , 'clWaitForEvents' ) fclHostPtrMap ( n , 1 ) = transfer ( hostPtr , deviceptr ) end procedure fclAllocHostPtr_1 ! --------------------------------------------------------------------------- module procedure fclAllocHostPtr_2 !(hostPtr,nBytes) !! Allocate a 'pinned' (non-paged) host array on default command queue call fclAllocHostPtr_1 ( fclDefaultCmdQ , hostPtr , nBytes ) end procedure fclAllocHostPtr_2 ! --------------------------------------------------------------------------- module procedure fclAllocHostInt32D1_1 !(cmdq,hostPtr,dim) !! Allocate a 1D 'pinned' host array for 32bit integers type ( c_ptr ) :: ptr call fclAllocHostPtr_1 ( cmdq , ptr , dim * c_sizeof ( int ( 1 , c_int32_t ))) call c_f_pointer ( ptr , hostPtr ,[ dim ]) end procedure fclAllocHostInt32D1_1 ! --------------------------------------------------------------------------- module procedure fclAllocHostInt32D1_2 !(hostPtr,dim) !! Allocate a 1D 'pinned' host array for 32bit integers on default cmdq call fclAllocHostInt32D1_1 ( fclDefaultCmdQ , hostPtr , dim ) end procedure fclAllocHostInt32D1_2 ! --------------------------------------------------------------------------- module procedure fclAllocHostFloatD1_1 !(cmdq,hostPtr,dim) !! Allocate a 1D 'pinned' host array for 32bit reals type ( c_ptr ) :: ptr call fclAllocHostPtr_1 ( cmdq , ptr , dim * c_sizeof ( real ( 1.0 , c_float ))) call c_f_pointer ( ptr , hostPtr ,[ dim ]) end procedure fclAllocHostFloatD1_1 ! --------------------------------------------------------------------------- module procedure fclAllocHostFloatD1_2 !(hostPtr,dim) !! Allocate a 1D 'pinned' host array for 32bit reals on default cmdq call fclAllocHostFloatD1_1 ( fclDefaultCmdQ , hostPtr , dim ) end procedure fclAllocHostFloatD1_2 ! --------------------------------------------------------------------------- module procedure fclAllocHostDoubleD1_1 !(cmdq,hostPtr,dim) !! Allocate a 1D 'pinned' host array for 64bit reals type ( c_ptr ) :: ptr call fclAllocHostPtr_1 ( cmdq , ptr , dim * c_sizeof ( real ( 1.0 , c_Double ))) call c_f_pointer ( ptr , hostPtr ,[ dim ]) end procedure fclAllocHostDoubleD1_1 ! --------------------------------------------------------------------------- module procedure fclAllocHostDoubleD1_2 !(hostPtr,dim) !! Allocate a 1D 'pinned' host array for 64bit reals on default cmdq call fclAllocHostDoubleD1_1 ( fclDefaultCmdQ , hostPtr , dim ) end procedure fclAllocHostDoubleD1_2 ! --------------------------------------------------------------------------- module procedure fclFreeHostPtr_1 !(cmdq,hostPtr) integer ( c_int32_t ) :: errcode integer ( c_intptr_t ) :: deviceptr integer ( c_intptr_t ), target :: unmapEvent integer :: i , n n = minloc ([( i , i = 1 , size ( fclHostPtrMap , 1 ))], dim = 1 , & mask = fclHostPtrMap (:, 1 ) == transfer ( hostPtr , deviceptr )) devicePtr = fclHostPtrMap ( n , 2 ) errcode = clEnqueueUnmapMemObject ( cmdq % cl_command_queue , devicePtr , & hostPtr , 0 , C_NULL_PTR , c_loc ( unmapEvent )) call fclHandleError ( errcode , 'fclFreeHostPtr' , 'clEnqueueUnmapMemObject' ) errcode = clWaitForEvents ( 1 , c_loc ( unmapEvent )) call fclErrorhandler ( errcode , 'fclFreeHostPtr' , 'clWaitForEvents' ) errcode = clReleaseMemObject ( devicePtr ) call fclHandleError ( errcode , 'fclFreeBuffer' , 'clReleaseMemObject' ) fclHostPtrMap ( n ,:) = - 1 end procedure fclFreeHostPtr_1 ! --------------------------------------------------------------------------- module procedure fclFreeHostPtr_2 !(hostPtr) call fclFreeHostPtr_1 ( fclDefaultCmdQ , hostPtr ) end procedure fclFreeHostPtr_2 ! --------------------------------------------------------------------------- module procedure fclFreeHostInt32_1 !(cmdq,hostPtr) call fclFreeHostPtr_1 ( cmdq , c_loc ( hostPtr )) hostPtr => NULL () end procedure fclFreeHostInt32_1 ! --------------------------------------------------------------------------- module procedure fclFreeHostInt32_2 !(hostPtr) call fclFreeHostInt32_1 ( fclDefaultCmdQ , hostPtr ) end procedure fclFreeHostInt32_2 ! --------------------------------------------------------------------------- module procedure fclFreeHostFloat_1 !(cmdq,hostPtr) call fclFreeHostPtr_1 ( cmdq , c_loc ( hostPtr )) hostPtr => NULL () end procedure fclFreeHostFloat_1 ! --------------------------------------------------------------------------- module procedure fclFreeHostFloat_2 !(hostPtr) call fclFreeHostFloat_1 ( fclDefaultCmdQ , hostPtr ) end procedure fclFreeHostFloat_2 ! --------------------------------------------------------------------------- module procedure fclFreeHostDouble_1 !(cmdq,hostPtr) call fclFreeHostPtr_1 ( cmdq , c_loc ( hostPtr )) hostPtr => NULL () end procedure fclFreeHostDouble_1 ! --------------------------------------------------------------------------- module procedure fclFreeHostDouble_2 !(hostPtr) call fclFreeHostDouble_1 ( fclDefaultCmdQ , hostPtr ) end procedure fclFreeHostDouble_2 ! --------------------------------------------------------------------------- end submodule Focal_HostMemory","tags":"","loc":"sourcefile/focal_hostmemory.f90.html"},{"title":"Focal_Utils.f90 – Focal API Reference","text":"Contents Submodules Focal_Utils Source Code Focal_Utils.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Utils !!  Implementation module for focal utility routines !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote implicit none contains module procedure fclGetKernelResource !(kernelString) use Focal , only : fclKernelStart , fclKernelEnd integer ( c_intptr_t ) :: a0 , a1 integer ( c_intptr_t ) :: i , length character ( 1 ), pointer :: text (:) type ( c_ptr ) :: aa aa = c_loc ( fclKernelStart ) a0 = transfer ( c_loc ( fclKernelStart ), a0 ) a1 = transfer ( c_loc ( fclKernelEnd ), a1 ) length = a1 - a0 call c_f_pointer ( aa , text , shape = [ length ]) allocate ( character ( len = length ) :: kernelString ) do i = 1 , length kernelString ( i : i ) = text ( i ) end do end procedure fclGetKernelResource ! ----------------------------------------------------------------------------- module procedure strStripNum !! Return copy of string with numerical characters removed integer :: i , n , ic , iOut n = len_trim ( linei ) strStripNum = ' ' iOut = 1 do i = 1 , n ic = ichar ( linei ( i : i )) if (. not .( ic > 47 . and . ic < 58 )) then ! ASCII numbers are 48 to 57 inclusive strStripNum ( iOut : iOut ) = linei ( i : i ) iOut = iOut + 1 end if end do end procedure strStripNum ! ----------------------------------------------------------------------------- module procedure fclSourceFromFile !(filename,sourceString) !! Allocae and fill character string from file integer :: fh , iLen , ioStat , i character ( 1 ) :: char ! --- First pass: get kernel source length --- open ( newunit = fh , file = filename , status = 'old' , form = 'formatted' , & access = 'direct' , recl = 1 ) iLen = 1 iostat = 0 do while ( iostat == 0 ) read ( fh , '(A)' , rec = iLen , iostat = iostat ) char iLen = iLen + 1 enddo iLen = iLen - 2 close ( fh ) allocate ( character ( len = iLen ) :: sourceString ) ! --- Second pass: read kernel source into buffer --- open ( newunit = fh , file = filename , status = 'old' , form = 'formatted' , & access = 'direct' , recl = 1 ) do i = 1 , iLen read ( fh , '(A)' , rec = i ) char sourceString ( i : i ) = char end do close ( fh ) end procedure fclSourceFromFile ! ----------------------------------------------------------------------------- end submodule Focal_Utils","tags":"","loc":"sourcefile/focal_utils.f90.html"},{"title":"Focal_Debug.f90 – Focal API Reference","text":"Contents Submodules Focal_Debug Source Code Focal_Debug.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- submodule ( Focal ) Focal_Debug !!  Implementation module for focal debug routines. !!  This submodule is linked in the debug version of Focal build. !! @note This is an implementation submodule: it contains the code implementing the subroutines defined in the !!  corresponding header module file. See header module file (Focal.f90) for interface definitions. @endnote use clfortran implicit none contains module procedure fclDbgCheckContext !(descrip,ctx) !! Check the (default) context is initialised. !! Assumes uninitialised contexts have cl_context = -1. if ( present ( ctx )) then if ( ctx % cl_context == - 1 ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Attempt to use uninitialised context at: ' , descrip write ( * , * ) call fclRuntimeError ( 'fclDbgCheckContext' ) end if else if ( fclDefaultCtx % cl_context == - 1 ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' The default context is uninitialised.' write ( * , * ) '  but referenced at: ' , descrip write ( * , * ) call fclRuntimeError ( 'fclDbgCheckContext' ) end if end if end procedure fclDbgCheckContext ! --------------------------------------------------------------------------- module procedure fclDbgCheckDevice !(device,descrip) !! Check a device object is valid if ( device % cl_device_id < 0 ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Attempt to use uninitialised device at: ' , descrip write ( * , * ) call fclRuntimeError ( 'fclDbgCheckDevice' ) end if end procedure fclDbgCheckDevice ! --------------------------------------------------------------------------- module procedure fclDbgCheckBufferInit !(memObject,descrip) !! Check that a device buffer object has been initialised. if ( memObject % nBytes <= 0 ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Attempt to use uninitialised device buffer at: ' , descrip write ( * , * ) call fclRuntimeError ( 'fclDbgCheckBufferInit' ) end if end procedure fclDbgCheckBufferInit ! --------------------------------------------------------------------------- module procedure fclDbgCheckBufferSize !(memObject,hostBytes,descrip) !! Check that a host buffer matches the size in bytes of a device buffer if ( hostBytes /= memObject % nBytes ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Mismatch in size between host buffer and device buffer at: ' , descrip write ( * , * ) ' Host buffer size: ' , hostBytes write ( * , * ) ' Device buffer size: ' , memObject % nBytes write ( * , * ) call fclRuntimeError ( 'fclDbgCheckBufferSize' ) end if end procedure fclDbgCheckBufferSize ! --------------------------------------------------------------------------- module procedure fclDbgCheckCopyBufferSize !(memObject1,memObject2) !! Check that device buffers match in size in bytes for copying if ( memObject1 % nBytes /= memObject2 % nBytes ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Mismatch in size between source buffer and destination buffer' // & '  while attempting to copy or swap device buffers. (fclMemCopy)' write ( * , * ) ' Source buffer size: ' , memObject2 % nBytes write ( * , * ) ' Destination buffer size: ' , memObject1 % nBytes write ( * , * ) call fclRuntimeError ( 'fclDbgCheckCopyBufferSize' ) end if end procedure fclDbgCheckCopyBufferSize ! --------------------------------------------------------------------------- module procedure fclDbgCheckKernelNArg !(kernel,nArg) !! Check that number of actual args matches number of kernel args integer :: nKernelArg call fclGetKernelInfo ( kernel , CL_KERNEL_NUM_ARGS , nKernelArg ) if ( nKernelArg /= nArg ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Mismatch in number of kernel arguments.' write ( * , * ) ' Kernel name: ' , kernel % name write ( * , * ) ' Number of kernel arguments: ' , nKernelArg write ( * , * ) ' Number of arguments passed: ' , nArg write ( * , * ) call fclRuntimeError ( 'fclDbgCheckKernelNArg' ) end if end procedure fclDbgCheckKernelNArg ! --------------------------------------------------------------------------- module procedure fclDbgCheckKernelArgType !(kernel,argNo,type) character (:), allocatable :: argType call fclGetKernelArgInfo ( kernel , argNo , CL_KERNEL_ARG_TYPE_NAME , argType ) ! Use strStripNum to remove vector type information for comparison argType = trim ( strStripNum ( argType )) if ( index ( argType , type ) == 0 . or . & index ( argType , '*' ) /= index ( type , '*' )) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Mismatch in type of kernel argument.' write ( * , * ) ' Kernel name: ' , kernel % name write ( * , * ) ' Argument index: ' , argNo write ( * , * ) ' Expecting ' , argType , ' but got ' , type write ( * , * ) call fclRuntimeError ( 'fclDbgCheckKernelArgType' ) end if end procedure fclDbgCheckKernelArgType ! --------------------------------------------------------------------------- module procedure fclDbgCheckKernelArgQualifier !(kernel,argNo,qualifier) integer :: argQual character ( 10 ) :: qualStr logical :: matched call fclGetKernelArgInfo ( kernel , argNo , CL_KERNEL_ARG_ADDRESS_QUALIFIER , argQual ) matched = . false . select case ( argQual ) case ( CL_KERNEL_ARG_ADDRESS_LOCAL ) qualStr = 'local' if ( index ( qualifier , 'local' ) > 0 ) then matched = . true . end if case ( CL_KERNEL_ARG_ADDRESS_GLOBAL ) qualStr = 'global' if ( index ( qualifier , 'global' ) > 0 ) then matched = . true . end if case ( CL_KERNEL_ARG_ADDRESS_PRIVATE ) qualStr = 'private' if ( index ( qualifier , 'private' ) > 0 ) then matched = . true . end if case ( CL_KERNEL_ARG_ADDRESS_CONSTANT ) qualStr = 'constant' if ( index ( qualifier , 'constant' ) > 0 ) then matched = . true . end if case default call fclRuntimeError ( 'fclDbgCheckKernelArgQualifier: unknown qualifier returned by opencl api.' ) end select if (. not . matched ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' write ( * , * ) ' Mismatch in address space qualifier of kernel argument.' write ( * , * ) ' Kernel name: ' , kernel % name write ( * , * ) ' Argument index: ' , argNo write ( * , * ) ' Expecting qualifer \"' , trim ( qualStr ), '\" but given argument was one of \"' , qualifier , '\".' write ( * , * ) call fclRuntimeError ( 'fclDbgCheckKernelArgType' ) end if end procedure fclDbgCheckKernelArgQualifier ! --------------------------------------------------------------------------- module procedure fclDbgOptions !(options) !! Returns OpenCL compile options as interoperable string for debug mode options = '-cl-kernel-arg-info' ! Required for focaldbg kernel argument checks end procedure fclDbgOptions ! --------------------------------------------------------------------------- module procedure fclDbgWait !(event,descrip) !! Wait for an event to complete and check for successful completion. !! Throw runtime error if status is not CL_COMPLETE. integer ( c_int32_t ) :: errcode integer ( c_int32_t ), target :: eStatus integer ( c_size_t ) :: temp_size , size_ret ! Call clWaitForEvents & clGetEventInfo directly to avoid built-in error handling here errcode = clWaitForEvents ( 1 , c_loc ( event % cl_event ) ) temp_size = c_sizeof ( int ( 1 , c_int32_t )) errcode = ior ( errcode , clGetEventInfo ( event % cl_event , CL_EVENT_COMMAND_EXECUTION_STATUS , & temp_size , C_LOC ( eStatus ), size_ret )) ! Catch errors if ( errcode /= CL_SUCCESS . or . eStatus /= CL_SUCCESS ) then write ( * , * ) '(!) Focal (debug build) runtime assertion failed.' if ( present ( descrip )) then write ( * , * ) ' An event (' // descrip // ') has terminated abnormally.' else write ( * , * ) ' An event has terminated abnormally.' end if if ( errcode == CL_SUCCESS ) then ! Error is only in event status eStatus = - 1 * eStatus write ( * , * ) ' Event execution error code: ' , eStatus , ' : ' , trim ( fclGetErrorString ( eStatus )) call fclRuntimeError ( 'fclDbgWait' ) else ! Error is in api calls call fclHandleError ( errcode , 'fclDbgWait' , 'clWaitForEvents|clGetEventInfo' ) end if end if end procedure fclDbgWait ! --------------------------------------------------------------------------- end submodule Focal_Debug","tags":"","loc":"sourcefile/focal_debug.f90.html"},{"title":"Focal.f90 – Focal API Reference","text":"Contents Modules Focal Source Code Focal.f90 Source Code ! ----------------------------------------------------------------------------- !  FOCAL ! !   A modern Fortran abstraction layer for OpenCL !   https://lkedward.github.io/focal-docs ! ! ----------------------------------------------------------------------------- ! ! Copyright (c) 2020 Laurence Kedward ! ! Permission is hereby granted, free of charge, to any person obtaining a copy ! of this software and associated documentation files (the \"Software\"), to deal ! in the Software without restriction, including without limitation the rights ! to use, copy, modify, merge, publish, distribute, sublicense, and/or sell ! copies of the Software, and to permit persons to whom the Software is ! furnished to do so, subject to the following conditions: ! ! The above copyright notice and this permission notice shall be included in all ! copies or substantial portions of the Software. ! ! THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR ! IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, ! FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE ! AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER ! LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, ! OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE ! SOFTWARE. ! ! ----------------------------------------------------------------------------- module Focal !!  Header module for all focal parameters, types and interfaces !! @note This is a header module: it contains subroutine interface definitions only. !! Subroutine implementation (code) is found in the corresponding submodule files. @endnote use , intrinsic :: iso_fortran_env , only : real32 , real64 use , intrinsic :: iso_c_binding implicit none ! ---------------------------- CONSTANT PARAMETERS -------------------------- integer , parameter :: errStringLen = 50 !! Max length of OpenCL error code strings integer , parameter :: fclAllocationSize = 10 !! Default allocation increment for dynamically growing lists integer , parameter :: CL_PLATFORM_NOT_FOUND_KHR = - 1001 !! Extension error: No valid ICDs found integer , parameter :: NV_ILLEGAL_BUFFER_READ_WRITE = - 9999 !! Vendor error: Illegal read or write to a buffer in NDRangeKernel ! ---------------------------- FOCAL TYPES ---------------------------------- type :: fclDevice !! Type wrapper for openCL device objects integer ( c_intptr_t ), private :: cl_device_id = - 1 !! OpenCL device pointer integer ( c_int64_t ) :: cl_device_type !! Device type character (:), allocatable :: name !! Device name integer ( c_int32_t ) :: nComputeUnits !! Number of device compute units integer ( c_int64_t ) :: global_memory !! Total global memory, bytes integer ( c_int32_t ) :: clock_freq !! Max clock frequency, MHz character (:), allocatable :: version !! OpenCL version character (:), allocatable :: extensions !! Supported OpenCL extensions type ( fclPlatform ), pointer :: platform !! Pointer to containing platform integer ( c_intptr_t ), private :: cl_platform_id !! OpenCL platform pointer character (:), allocatable :: platformName !! Name of containing platform character (:), allocatable :: platformVendor !! Vendor of containing platform end type fclDevice type :: fclPlatform !! Type wrapper for openCL platform objects integer ( c_intptr_t ), private :: cl_platform_id !! OpenCL platform pointer character (:), allocatable :: profile !! OpenCL Profile string character (:), allocatable :: version !! OpenCL Version character (:), allocatable :: name !! Platform name character (:), allocatable :: vendor !! Platform vendor character (:), allocatable :: extensions !! Platform extensions integer :: numDevice !! No. of devices type ( fclDevice ), allocatable :: devices (:) !! Focal device objects integer ( c_intptr_t ), allocatable , private :: cl_device_ids (:) !! openCL device pointers end type fclPlatform type :: fclContext !! Type wrapper for openCL context objects integer ( c_intptr_t ) :: cl_context = - 1 !! openCL context pointer type ( fclPlatform ) :: platform !! Focal platform object end type fclContext type :: fclEvent !! Type wrapper for OpenCL event pointers integer ( c_intptr_t ) :: cl_event = - 1 !! OpenCL event pointer contains final :: fclReleaseEvent !! Decrement cl reference counter end type fclEvent type :: fclCommandQ !! Type wrapper for openCL command queue objects integer ( c_intptr_t ), private :: cl_command_queue !! openCL command Q pointer logical :: blockingWrite = . true . !! Enable/disable blocking writes when copying from host to device logical :: blockingRead = . true . !! Enable/disable block reads when copying from device to host type ( fclEvent ) :: lastWriteEvent !! Focal event object for the most recent write event (host-to-device) to be enqueued type ( fclEvent ) :: lastReadEvent !! Focal event object for the most recent read event (device-to-host) to be enqueued type ( fclEvent ) :: lastCopyEvent !! Focal event object for the most recent copy event (device-to-device) to be enqueued type ( fclEvent ) :: lastKernelEvent !! Focal event object for the most recent kernel event to be enqueued type ( fclEvent ) :: lastBarrierEvent !! Focal event object for the most recent barrier event to be enqueued integer ( c_intptr_t ), allocatable :: dependencyList (:) !! List of pre-requisite events for next enqueued action. !!  All events in this list are used as dependencies for the next enqueued !!   operation. At enqueueing, the list is cleared unless holdDependencies is .true. type ( c_ptr ) :: dependencyListPtr = C_NULL_PTR !! C pointer to dependency list. C_NULL_PTR when nDependency is zero. integer :: nDependency = 0 !! Number of items in dependency list logical :: holdDependencies = . false . !! Set to true to not automatically clear dependencies after enqueueing. !! Use for applying the same dependencies to multiple commands. !! Use fclClearDependencies to clear and reset. end type fclCommandQ type :: fclCommandQPool !! Collection of fclCommandQ objects with round-robin scheduling. !!  Allows easy handling of multiple command queues for parallel kernels !!  data transfers. integer :: length !! Number of command queues type ( fclCommandQ ), allocatable :: queues (:) !! Array of command queues integer :: idx = 1 !! Index of current command queue contains procedure , pass :: next => fclCommandQPool_Next !! Returns next scheduled queue in queue pool procedure , pass :: current => fclCommandQPool_Current !! Returns current scheduled queue in queue pool end type fclCommandQPool type :: fclProgram !! Type wrapper for openCL program objects private integer ( c_intptr_t ) :: cl_program !! openCL program pointer end type fclProgram type :: fclKernelPointer !! Wrapper type for implementing an array of pointers to kernel objects private class ( fclKernel ), pointer :: target end type fclKernelPointer type :: fclBufferPointer !! Wrapper type for implementing an array of pointers to buffer objects private class ( fclDeviceBuffer ), pointer :: target end type fclBufferPointer type :: fclProfiler !! Helper type to collect objects (kernels and buffers) that !!  are profiled to simply user code. private type ( fclDevice ), public :: device !! Device for which to dump profile data type ( fclKernelPointer ), allocatable :: kernels (:) !! List of pointers to kernels to be profiled integer :: nKernels = 0 !! Number of kernels in kernels array type ( fclBufferPointer ), allocatable :: buffers (:) !! List of pointers to buffers to be profiled integer :: nBuffers = 0 !! Number of buffers in buffers array contains procedure , pass :: add => fclProfilerAdd end type fclProfiler type :: fclProfileContainer !! Base container type for event profiling character (:), allocatable :: profileName !! Descriptive name for output of profiling information logical :: profilingEnabled = . false . !! Switch to enable saving of events for profiling type ( fclEvent ), pointer :: profileEvents (:) => NULL () !! Array of events for profiling integer :: profileSize = 0 !! Allocation size of profileEvents(:) array integer , pointer :: nProfileEvent => NULL () !! Number of events saved to profileEvents(:) array integer , pointer :: profileEventType (:) => NULL () !! Integer for indicating type of buffer event contains ! procedure, pass :: enableProfiling => fclEnableProfiling procedure , pass :: pushProfileEvent => fclPushProfileEvent end type fclProfileContainer type , extends ( fclProfileContainer ) :: fclKernel !! Type wrapper for openCL kernel objects integer ( c_intptr_t ), private :: cl_kernel !! openCL kernel pointer character (:), allocatable :: name !! Kernel name integer ( c_int32_t ) :: work_dim = 1 !! Number of work-range dimensions integer ( c_size_t ) :: global_work_offset ( 3 ) = 0 !! Global work dimension offsets integer ( c_size_t ) :: global_work_size ( 3 ) = 0 !! Global work-range dimensions integer ( c_size_t ) :: local_work_size ( 3 ) = 0 !! Local work-group dimensions contains procedure , pass :: setArgs => fclSetKernelArgs !! Set kernel arguments without launching procedure , pass :: launch => fclLaunchKernel !! Launch the kernel procedure , pass , private :: launchKernelAfterEvent_1 => fclLaunchKernelAfterEvent_1 procedure , pass , private :: launchKernelAfterEvent_2 => fclLaunchKernelAfterEvent_2 procedure , pass , private :: launchKernelAfterEventList_1 => fclLaunchKernelAfterEventList_1 procedure , pass , private :: launchKernelAfterEventList_2 => fclLaunchKernelAfterEventList_2 generic :: launchAfter => launchKernelAfterEvent_1 , launchKernelAfterEvent_2 , & launchKernelAfterEventList_1 , launchKernelAfterEventList_2 !! Launch a kernel with event dependencies final :: fclReleaseKernel end type fclKernel type , extends ( fclProfileContainer ) :: fclDeviceBuffer !! Type wrapper for openCL memory objects private integer ( c_intptr_t ) :: cl_mem !! openCL memory pointer type ( fclCommandQ ), pointer :: cmdq !! Focal commandQ object integer ( c_size_t ), public :: nBytes = - 1 !! Size of buffer in bytes logical :: kernelRead !! Indicates kernel read access logical :: kernelWrite !! Indicate kernel write access end type fclDeviceBuffer type , extends ( fclDeviceBuffer ) :: fclDeviceInt32 !! Type wrapper for memory objects representing int32 end type fclDeviceInt32 type , extends ( fclDeviceBuffer ) :: fclDeviceFloat !! Type wrapper for memory objects representing float end type fclDeviceFloat type , extends ( fclDeviceBuffer ) :: fclDeviceDouble !! Type wrapper for memory objects representing double end type fclDeviceDouble type :: fclLocalArgument !! Type for specifying local kernel arguments. !!  Instantiate with on of: fclLocalInt32, fclLocalFloat, fclLocalDouble integer ( c_size_t ) :: nBytes !! Size of local argument in bytes end type fclLocalArgument type , extends ( fclLocalArgument ) :: fclLocalArgInt32 !! Type wrapper for local kernel arguments representing 32 bit integers end type fclLocalArgInt32 type , extends ( fclLocalArgument ) :: fclLocalArgFloat !! Type wrapper for local kernel arguments representing floats end type fclLocalArgFloat type , extends ( fclLocalArgument ) :: fclLocalArgDouble !! Type wrapper for local kernel arguments representing doubles end type fclLocalArgDouble ! ---------------------------- ABSTRACT INTERFACES -------------------------- abstract interface subroutine fclHandleErrorInterface ( errcode , focalCall , oclCall ) use iso_c_binding integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall end subroutine fclHandleErrorInterface end interface ! ---------------------------- GLOBAL PARAMETERS ---------------------------- !! @note Use of global parameters must not restrict ability to use the module !!       asynchronously or within parallel/multithread environment @endnote type ( fclCommandQ ), target :: fclDefaultCmdQ !! Default command queue: used when command queue is omittetd in focal api calls type ( fclContext ), target :: fclDefaultCtx !! Default context: used when context is omittetd in focal api calls type ( fclEvent ), target :: fclLastWriteEvent !! Focal event object for the most recent write event (host-to-device) to be enqueued type ( fclEvent ), target :: fclLastReadEvent !! Focal event object for the most recent read event (device-to-host) to be enqueued type ( fclEvent ), target :: fclLastCopyEvent !! Focal event object for the most recent copy event (device-to-device) to be enqueued type ( fclEvent ), target :: fclLastKernelEvent !! Focal event object for the most recent kernel event to be enqueued type ( fclEvent ), target :: fclLastBarrierEvent !! Focal event object for the most recent barrier event to be enqueued character ( len = 1 , kind = c_char ), target , bind ( C , name = \"_binary_fclKernels_cl_start\" ) :: fclKernelStart !! c interoperable character for start of fclKernels binary resource character ( len = 1 , kind = c_char ), target , bind ( C , name = \"_binary_fclKernels_cl_end\" ) :: fclKernelEnd !! c interoperable character for sendtart of fclKernels binary resource procedure ( fclHandleErrorInterface ), pointer :: fclErrorHandler => NULL () !fclDefaultErrorHandler !! Procedure pointer for custom OpenCL runtime error handler integer ( c_intptr_t ), allocatable :: fclHostPtrMap (:,:) !! Map allocated host pointers to cl_buffer pointers (needed for deallocation) ! ---------------------------- ERROR ROUTINES ------------------------------- interface module subroutine fclHandleError ( errcode , focalCall , oclCall ) !! Wrapper to invoke fclErrorHandle procedure pointer (fixes issue with ifort) integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall end subroutine fclHandleError module subroutine fclHandleBuildError ( builderrcode , prog , ctx ) !! Check an openCL error code and print build log if necessary integer , intent ( in ) :: builderrcode !! OpenCL API error code type ( fclProgram ), intent ( in ) :: prog !! Focal program object type ( fclContext ), intent ( in ) :: ctx !! Focal context object end subroutine fclHandleBuildError module subroutine fclDefaultErrorHandler ( errcode , focalCall , oclCall ) integer ( c_int32_t ), intent ( in ) :: errcode character ( * ), intent ( in ) :: focalCall character ( * ), intent ( in ) :: oclCall end subroutine fclDefaultErrorHandler module function fclGetErrorString ( errcode ) result ( errstr ) !! Return the text representation for an openCL error code integer , intent ( in ) :: errcode !! OpenCL API error code character ( errStringLen ) :: errstr !! Returns OpenCL error string end function fclGetErrorString module subroutine fclRuntimeError ( descrip ) !! Stop and print message for Focal errors not caused by openCL API call character ( * ), intent ( in ), optional :: descrip !! Description of current API call end subroutine fclRuntimeError end interface ! -------------------------- HOST MEMORY ROUTINES ----------------------------- ! --------- Pinned memory allocation --------- interface fclAllocHost !! Generic interface for allocating host arrays using !!  'pinned' (non-paged) memory. This is required for asynchronous transfers. !! !! Currently implements interfaces for 1D and 2D int32, float and double arrays. !! !! @note This is a blocking command. Execution waits on host until map is complete @endnote !! !! __Example:__ !!  Allocate a 1D integer array with 100 elements !! !! `integer, pointer :: hostArray(:)` !! !! `call fclAllocHost(cmdq,hostArray,100)` !! !! __NB:__ `cmdq` is optional, if omitted then the default command queue is used module subroutine fclAllocHostPtr_1 ( cmdq , hostPtr , nBytes ) !! Allocate a 'pinned' (non-paged) host array type ( fclCommandQ ), intent ( in ) :: cmdq !! Command Q with which to associate the allocated device memory type ( c_ptr ), intent ( out ) :: hostPtr !! c pointer to allocated host memory integer ( c_int64_t ), intent ( in ) :: nBytes !! Desired array size in bytes end subroutine fclAllocHostPtr_1 module subroutine fclAllocHostPtr_2 ( hostPtr , nBytes ) !! Allocate a 'pinned' (non-paged) host array on default cmdq type ( c_ptr ), intent ( out ) :: hostPtr !! c pointer to allocated host memory integer ( c_int64_t ), intent ( in ) :: nBytes !! Desired array size in bytes end subroutine fclAllocHostPtr_2 module subroutine fclAllocHostInt32D1_1 ( cmdq , hostPtr , dim ) !! Allocate a 1D 'pinned' host array for 32bit integers type ( fclCommandQ ), intent ( in ) :: cmdq !! Command Q with which to associate the allocated device memory integer ( c_int32_t ), intent ( inout ), pointer :: hostPtr (:) !! Host array pointer to allocate integer , intent ( in ) :: dim !! Size of array to allocate end subroutine fclAllocHostInt32D1_1 module subroutine fclAllocHostInt32D1_2 ( hostPtr , dim ) !! Allocate a 1D 'pinned' host array for 32bit integers on default cmdq integer ( c_int32_t ), intent ( inout ), pointer :: hostPtr (:) !! Host array pointer to allocate integer , intent ( in ) :: dim !! Size of array to allocate end subroutine fclAllocHostInt32D1_2 module subroutine fclAllocHostFloatD1_1 ( cmdq , hostPtr , dim ) !! Allocate a 1D 'pinned' host array for 32bit reals type ( fclCommandQ ), intent ( in ) :: cmdq !! Command Q with which to associate the allocated device memory real ( c_Float ), intent ( inout ), pointer :: hostPtr (:) !! Host array pointer to allocate integer , intent ( in ) :: dim !! Size of array to allocate end subroutine fclAllocHostFloatD1_1 module subroutine fclAllocHostFloatD1_2 ( hostPtr , dim ) !! Allocate a 1D 'pinned' host array for 32bit reals on default cmdq real ( c_Float ), intent ( inout ), pointer :: hostPtr (:) !! Host array pointer to allocate integer , intent ( in ) :: dim !! Size of array to allocate end subroutine fclAllocHostFloatD1_2 module subroutine fclAllocHostDoubleD1_1 ( cmdq , hostPtr , dim ) !! Allocate a 1D 'pinned' host array for 64bit reals type ( fclCommandQ ), intent ( in ) :: cmdq !! Command Q with which to associate the allocated device memory real ( c_Double ), intent ( inout ), pointer :: hostPtr (:) !! Host array pointer to allocate integer , intent ( in ) :: dim !! Size of array to allocate end subroutine fclAllocHostDoubleD1_1 module subroutine fclAllocHostDoubleD1_2 ( hostPtr , dim ) !! Allocate a 1D 'pinned' host array for 64bit reals on default cmdq real ( c_Double ), intent ( inout ), pointer :: hostPtr (:) !! Host array pointer to allocate integer , intent ( in ) :: dim !! Size of array to allocate end subroutine fclAllocHostDoubleD1_2 end interface fclAllocHost interface fclFreeHost !! Generic interface to free pinned host pointer !! !! @note This is a blocking command. Execution waits on host until unmap is complete @endnote !! module subroutine fclFreeHostPtr_1 ( cmdq , hostPtr ) !! Enqueue unmap/free command to specific command queue type ( fclCommandQ ), intent ( in ) :: cmdq type ( c_ptr ), intent ( in ) :: hostPtr end subroutine fclFreeHostPtr_1 module subroutine fclFreeHostPtr_2 ( hostPtr ) !! Enqueue unmap/free command to default command queue type ( c_ptr ), intent ( inout ) :: hostPtr end subroutine fclFreeHostPtr_2 module subroutine fclFreeHostInt32_1 ( cmdq , hostPtr ) type ( fclCommandQ ), intent ( in ) :: cmdq integer ( c_int32_t ), intent ( inout ), pointer :: hostPtr (:) end subroutine fclFreeHostInt32_1 module subroutine fclFreeHostInt32_2 ( hostPtr ) integer ( c_int32_t ), intent ( inout ), pointer :: hostPtr (:) end subroutine fclFreeHostInt32_2 module subroutine fclFreeHostFloat_1 ( cmdq , hostPtr ) type ( fclCommandQ ), intent ( in ) :: cmdq real ( c_float ), intent ( inout ), pointer :: hostPtr (:) end subroutine fclFreeHostFloat_1 module subroutine fclFreeHostFloat_2 ( hostPtr ) real ( c_float ), intent ( inout ), pointer :: hostPtr (:) end subroutine fclFreeHostFloat_2 module subroutine fclFreeHostDouble_1 ( cmdq , hostPtr ) type ( fclCommandQ ), intent ( in ) :: cmdq real ( c_double ), intent ( inout ), pointer :: hostPtr (:) end subroutine fclFreeHostDouble_1 module subroutine fclFreeHostDouble_2 ( hostPtr ) real ( c_double ), intent ( inout ), pointer :: hostPtr (:) end subroutine fclFreeHostDouble_2 end interface fclFreeHost ! ---------------------------- MEMORY ROUTINES ------------------------------- interface assignment ( = ) !! Generic interface for assignment of fclBuffer objects by operator-overloading procedure :: fclMemWriteScalarInt32 procedure :: fclMemWriteScalarFloat procedure :: fclMemWriteScalarDouble procedure :: fclMemWriteInt32 procedure :: fclMemWriteFloat procedure :: fclMemWriteDouble procedure :: fclMemReadInt32 procedure :: fclMemReadFloat procedure :: fclMemReadDouble procedure :: fclMemCopyInt32 procedure :: fclMemCopyFloat procedure :: fclMemCopyDouble end interface ! --------- Pointer swap --------- interface module subroutine fclBufferSwap ( memObject1 , memObject2 ) !! Helper routine for swapping device buffer pointers. !! Also swaps the command queue pointers associated with each buffer if different. !! @note The debug build will throw an error if either buffer is uninitialised !!        or if the buffers do not match in size. @endnote class ( fclDeviceBuffer ), intent ( inout ) :: memObject1 , memObject2 !! Buffer objects with which to swap pointers end subroutine fclBufferSwap end interface ! --------- Buffer Initialisation --------- interface fclInitBuffer !! Generic interface to initialise buffers on the device module subroutine fclInitBufferUntyped_1 ( cmdq , buffer , nBytes , profileName , access ) !! Initialise untyped buffer object on specified command queue type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceBuffer ), intent ( inout ) :: buffer !! Focal memory object to initialise integer ( c_size_t ), intent ( in ) :: nBytes !! Size of buffer in bytes character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferUntyped_1 module subroutine fclInitBufferUntyped_2 ( buffer , nBytes , profileName , access ) !! Initialise untyped buffer object on the default command queue type ( fclDeviceBuffer ), intent ( inout ) :: buffer !! Focal memory object to initialise integer ( c_size_t ), intent ( in ) :: nBytes !! Size of buffer in bytes character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferUntyped_2 module subroutine fclInitBufferFloat_1 ( cmdq , buffer , dim , profileName , access ) !! Initialise float buffer object on specific command queue type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceFloat ), intent ( inout ) :: buffer !! Focal memory object to initialise integer , intent ( in ) :: dim !! Dimension of buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferFloat_1 module subroutine fclInitBufferFloat_2 ( buffer , dim , profileName , access ) !! Initialise float buffer object on the default command queue type ( fclDeviceFloat ), intent ( inout ) :: buffer !! Focal memory object to initialise integer , intent ( in ) :: dim !! Dimension of buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferFloat_2 module subroutine fclInitBufferDouble_1 ( cmdq , buffer , dim , profileName , access ) !! Initialise double buffer object on specific command queue type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceDouble ), intent ( inout ) :: buffer !! Focal memory object to initialise integer , intent ( in ) :: dim !! Dimension of buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferDouble_1 module subroutine fclInitBufferDouble_2 ( buffer , dim , profileName , access ) !! Initialise double buffer object on the default command queue type ( fclDeviceDouble ), intent ( inout ) :: buffer !! Focal memory object to initialise integer , intent ( in ) :: dim !! Dimension of buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferDouble_2 module subroutine fclInitBufferInt32_1 ( cmdq , buffer , dim , profileName , access ) !! Initialise 32bit integer buffer object on specific command queue type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceInt32 ), intent ( inout ) :: buffer !! Focal memory object to initialise integer , intent ( in ) :: dim !! Dimension of buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferInt32_1 module subroutine fclInitBufferInt32_2 ( buffer , dim , profileName , access ) !! Initialise 32bit integer buffer object on the default command queue type ( fclDeviceInt32 ), intent ( inout ) :: buffer !! Focal memory object to initialise integer , intent ( in ) :: dim !! Dimension of buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitBufferInt32_2 end interface fclInitBuffer ! --------- Sub-Buffer Initialisation --------- interface fclInitSubBuffer !! Generic interface to initialise sub-buffers on the device module subroutine fclInitSubBufferUntyped_1 ( cmdq , subbuffer , sourceBuffer , offset , size , profileName , access ) !! Initialise an untyped sub-buffer from an existing buffer type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceBuffer ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer class ( fclDeviceBuffer ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer ( c_size_t ), intent ( in ) :: offset !! Offset in bytes of sub-buffer within sourceBuffer integer ( c_size_t ), intent ( in ) :: size !! Size in bytes of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferUntyped_1 module subroutine fclInitSubBufferUntyped_2 ( subbuffer , sourceBuffer , offset , size , profileName , access ) !! Initialise an untyped sub-buffer from an existing buffer on the default command queue type ( fclDeviceBuffer ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer class ( fclDeviceBuffer ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer ( c_size_t ), intent ( in ) :: offset !! Offset in bytes of sub-buffer within sourceBuffer integer ( c_size_t ), intent ( in ) :: size !! Size in bytes of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferUntyped_2 module subroutine fclInitSubBufferFloat_1 ( cmdq , subbuffer , sourceBuffer , start , length , profileName , access ) !! Initialise a float sub-buffer from an existing float buffer type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceFloat ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer type ( fclDeviceFloat ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer , intent ( in ) :: start !! Zero-based start element of sub-buffer within sourceBuffer integer , intent ( in ) :: length !! Length (no. of elements) of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferFloat_1 module subroutine fclInitSubBufferFloat_2 ( subbuffer , sourceBuffer , start , length , profileName , access ) !! Initialise a float sub-buffer from an existing float buffer on the default command queue type ( fclDeviceFloat ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer type ( fclDeviceFloat ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer , intent ( in ) :: start !! Zero-based start element of sub-buffer within sourceBuffer integer , intent ( in ) :: length !! Length (no. of elements) of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferFloat_2 module subroutine fclInitSubBufferDouble_1 ( cmdq , subbuffer , sourceBuffer , start , length , profileName , access ) !! Initialise a double sub-buffer from an existing float buffer type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceDouble ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer type ( fclDeviceDouble ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer , intent ( in ) :: start !! Zero-based start element of sub-buffer within sourceBuffer integer , intent ( in ) :: length !! Length (no. of elements) of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferDouble_1 module subroutine fclInitSubBufferDouble_2 ( subbuffer , sourceBuffer , start , length , profileName , access ) !! Initialise a double sub-buffer from an existing float buffer on the default command queue type ( fclDeviceDouble ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer type ( fclDeviceDouble ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer , intent ( in ) :: start !! Zero-based start element of sub-buffer within sourceBuffer integer , intent ( in ) :: length !! Length (no. of elements) of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferDouble_2 module subroutine fclInitSubBufferint32_1 ( cmdq , subbuffer , sourceBuffer , start , length , profileName , access ) !! Initialise a 32bit integer sub-buffer from an existing float buffer type ( fclCommandQ ), intent ( in ), target :: cmdq !! Queue with which to associate new buffer type ( fclDeviceInt32 ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer type ( fclDeviceInt32 ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer , intent ( in ) :: start !! Zero-based start element of sub-buffer within sourceBuffer integer , intent ( in ) :: length !! Length (no. of elements) of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferint32_1 module subroutine fclInitSubBufferint32_2 ( subbuffer , sourceBuffer , start , length , profileName , access ) !! Initialise a 32bit integer sub-buffer from an existing float buffer on the default command queue type ( fclDeviceInt32 ), intent ( inout ) :: subBuffer !! Focal memory object to initialise as new sub-buffer type ( fclDeviceInt32 ), intent ( inout ) :: sourceBuffer !! Focal memory object in which to create sub-buffer integer , intent ( in ) :: start !! Zero-based start element of sub-buffer within sourceBuffer integer , intent ( in ) :: length !! Length (no. of elements) of sub-buffer character ( * ), intent ( in ), optional :: profileName !! Descriptive name for profiling output character ( * ), intent ( in ), optional :: access !! Read/write access of kernels to buffer !! 'rw' = read&write (default), 'r'=read-only, 'w'=write-only end subroutine fclInitSubBufferint32_2 end interface fclInitSubBuffer interface ! --------- Write scalar to device --------- module subroutine fclMemWriteScalar ( memObject , hostBufferPtr , nBytesPattern ) !! Fill device buffer with scalar pattern class ( fclDeviceBuffer ), intent ( inout ), target :: memObject !! Focal memory object to fill type ( c_ptr ), intent ( in ) :: hostBufferPtr !! C Pointer to host scalar patter integer ( c_size_t ), intent ( in ) :: nBytesPattern !! Size of scalar pattern in bytes end subroutine fclMemWriteScalar module subroutine fclMemWriteScalarInt32 ( memObject , hostValue ) !! Assign a scalar integer to a device integer memory buffer !!  Called by operator-overloading of assignment(=) class ( fclDeviceInt32 ), intent ( inout ) :: memObject !! Focal memory object to fill integer ( c_int32_t ), intent ( in ), target :: hostValue !! Host value with which to fill end subroutine fclMemWriteScalarInt32 module subroutine fclMemWriteScalarFloat ( memObject , hostValue ) !! Assign a scalar float to a device float memory buffer !!  Called by operator-overloading of assignment(=) class ( fclDeviceFloat ), intent ( inout ) :: memObject !! Focal memory object to fill real ( c_float ), intent ( in ), target :: hostValue !! Host value with which to fill end subroutine fclMemWriteScalarFloat module subroutine fclMemWriteScalarDouble ( memObject , hostValue ) !! Assign a scalar double to a device double memory buffer !!  Called by operator-overloading of assignment(=) class ( fclDeviceDouble ), intent ( inout ) :: memObject !! Focal memory object to fill real ( c_double ), intent ( in ), target :: hostValue !! Host value with which to fill end subroutine fclMemWriteScalarDouble ! --------- Write host array to device array --------- module subroutine fclMemWrite ( memObject , hostBufferPtr , nBytes ) !! Transfer host buffer to device buffer class ( fclDeviceBuffer ), intent ( inout ), target :: memObject !! Focal memory object (target) type ( c_ptr ), intent ( in ) :: hostBufferPtr !! C Pointer to host array (source) integer ( c_size_t ), intent ( in ) :: nBytes !! Size of buffers in bytes end subroutine fclMemWrite module subroutine fclMemWriteInt32 ( memObject , hostBuffer ) !! Transfer host integer array to device integer array !!  Called by operator-overloading of assignment(=) class ( fclDeviceInt32 ), intent ( inout ) :: memObject !! Focal memory object (target) integer ( c_int32_t ), intent ( in ), target :: hostBuffer (:) !! Host array (source) end subroutine fclMemWriteInt32 module subroutine fclMemWriteFloat ( memObject , hostBuffer ) !! Transfer host float array to device float array !!  Called by operator-overloading of assignment(=) class ( fclDeviceFloat ), intent ( inout ) :: memObject !! Focal memory object (target) real ( c_float ), intent ( in ), target :: hostBuffer (:) !! Host array (source) end subroutine fclMemWriteFloat module subroutine fclMemWriteDouble ( memObject , hostBuffer ) !! Transfer host double array to device double array !!  Called by operator-overloading of assignment(=) class ( fclDeviceDouble ), intent ( inout ) :: memObject !! Focal memory object (target) real ( c_double ), intent ( in ), target :: hostBuffer (:) !! Host array (source) end subroutine fclMemWriteDouble ! --------- Read device array into host array --------- module subroutine fclMemRead ( hostBufferPtr , memObject , nBytes ) !! Transfer device buffer to host buffer type ( c_ptr ), intent ( in ) :: hostBufferPtr !! C pointer to host buffer (target) class ( fclDeviceBuffer ), intent ( in ), target :: memObject !! Focal memory object (source) integer ( c_size_t ), intent ( in ) :: nBytes !! Size of buffers in bytes end subroutine fclMemRead module subroutine fclMemReadInt32 ( hostBuffer , memObject ) !! Transfer device integer array to host integer array !!  Called by operator-overloading of assignment(=) integer ( c_int32_t ), intent ( inout ), target :: hostBuffer (:) !! Host array (target) class ( fclDeviceInt32 ), intent ( in ) :: memObject !! Focal memory object (source) end subroutine fclMemReadInt32 module subroutine fclMemReadFloat ( hostBuffer , memObject ) !! Transfer device float array to host float array !!  Called by operator-overloading of assignment(=) real ( c_float ), intent ( inout ), target :: hostBuffer (:) !! Host array (target) class ( fclDeviceFloat ), intent ( in ) :: memObject !! Focal memory object (source) end subroutine fclMemReadFloat module subroutine fclMemReadDouble ( hostBuffer , memObject ) !! Transfer device double array to host double array !!  Called by operator-overloading of assignment(=) real ( c_double ), intent ( inout ), target :: hostBuffer (:) !! Host array (target) class ( fclDeviceDouble ), intent ( in ) :: memObject !! Focal memory object (source) end subroutine fclMemReadDouble ! --------- Copy device array to device array --------- module subroutine fclMemCopy ( memObject1 , memObject2 ) !! Transfer device buffer to device buffer class ( fclDeviceBuffer ), intent ( inout ), target :: memObject1 !! Focal memory object (target) class ( fclDeviceBuffer ), intent ( in ) :: memObject2 !! Focal memory object (source) end subroutine fclMemCopy module subroutine fclMemCopyInt32 ( memObject1 , memObject2 ) !! Transfer device integer array to device integer array !!  Called by operator-overloading of assignment(=) class ( fclDeviceInt32 ), intent ( inout ), target :: memObject1 !! Focal memory object (target) class ( fclDeviceInt32 ), intent ( in ) :: memObject2 !! Focal memory object (source) end subroutine fclMemCopyInt32 module subroutine fclMemCopyFloat ( memObject1 , memObject2 ) !! Transfer device float array to device float array !!  Called by operator-overloading of assignment(=) class ( fclDeviceFloat ), intent ( inout ), target :: memObject1 !! Focal memory object (target) class ( fclDeviceFloat ), intent ( in ) :: memObject2 !! Focal memory object (source) end subroutine fclMemCopyFloat module subroutine fclMemCopyDouble ( memObject1 , memObject2 ) !! Transfer device double array to device double array !!  Called by operator-overloading of assignment(=) class ( fclDeviceDouble ), intent ( inout ), target :: memObject1 !! Focal memory object (target) class ( fclDeviceDouble ), intent ( in ) :: memObject2 !! Focal memory object (source) end subroutine fclMemCopyDouble ! --------- Free device memory object --------- module subroutine fclFreeBuffer ( memObject ) !! Release device memory associated with memObject class ( fclDeviceBuffer ) :: memObject end subroutine fclFreeBuffer end interface ! ---------------------------- QUERY ROUTINES ------------------------------- interface module subroutine fclGetPlatformInfo ( platform , key , value ) !! Query platform information. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetPlatformInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclplatform ), intent ( in ) :: platform integer ( c_int32_t ), intent ( in ) :: key character (:), allocatable , intent ( out ), target :: value end subroutine fclGetPlatformInfo end interface interface fclGetDeviceInfo !! Generic interface to query device information. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetDeviceInfo.html) !! for values of 'key' argument contained in clfortran module. module subroutine fclGetDeviceInfoString ( device , key , value ) type ( fclDevice ), intent ( in ) :: device integer ( c_int32_t ), intent ( in ) :: key character (:), allocatable , intent ( out ), target :: value end subroutine fclGetDeviceInfoString module subroutine fclGetDeviceInfoInt32 ( device , key , value ) type ( fclDevice ), intent ( in ) :: device integer ( c_int32_t ), intent ( in ) :: key integer ( c_int32_t ), intent ( out ), target :: value end subroutine fclGetDeviceInfoInt32 module subroutine fclGetDeviceInfoInt64 ( device , key , value ) type ( fclDevice ), intent ( in ) :: device integer ( c_int32_t ), intent ( in ) :: key integer ( c_int64_t ), intent ( out ), target :: value end subroutine fclGetDeviceInfoInt64 end interface fclGetDeviceInfo interface fclGetKernelInfo !! Generic interface to query kernel information. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelInfo.html) !! for values of 'key' argument contained in clfortran module. module subroutine fclGetKernelInfoString ( kernel , key , value ) !! Query kernel information for string info. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclKernel ), intent ( in ) :: kernel integer ( c_int32_t ), intent ( in ) :: key character (:), allocatable , intent ( out ), target :: value end subroutine fclGetKernelInfoString module subroutine fclGetKernelInfoInt32 ( kernel , key , value ) !! Query kernel information for 32bit integer. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclKernel ), intent ( in ) :: kernel integer ( c_int32_t ), intent ( in ) :: key integer ( c_int32_t ), intent ( out ), target :: value end subroutine fclGetKernelInfoInt32 end interface fclGetKernelInfo interface fclGetKernelWorkGroupInfo module subroutine fclGetKernelWorkGroupInfoInt64 ( kernel , device , key , value ) !! Query kernel work group information for 64bit integer. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclKernel ), intent ( in ) :: kernel type ( fclDevice ), intent ( in ) :: device integer ( c_int32_t ), intent ( in ) :: key integer ( c_int64_t ), intent ( out ), target :: value end subroutine fclGetKernelWorkGroupInfoInt64 end interface fclGetKernelWorkGroupInfo interface fclGetKernelArgInfo !! Generic interface to query kernel argument information. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelArgInfo.html) !! for values of 'key' argument contained in clfortran module. module subroutine fclGetKernelArgInfoString ( kernel , argNo , key , value ) !! Query kernel information for string info. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelArgInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclKernel ), intent ( in ) :: kernel integer , intent ( in ) :: argNo integer ( c_int32_t ), intent ( in ) :: key character (:), allocatable , intent ( out ), target :: value end subroutine fclGetKernelArgInfoString module subroutine fclGetKernelArgInfoInt32 ( kernel , argNo , key , value ) !! Query kernel information for 32bit integer. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelArgInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclKernel ), intent ( in ) :: kernel integer , intent ( in ) :: argNo integer ( c_int32_t ), intent ( in ) :: key integer ( c_int32_t ), intent ( out ), target :: value end subroutine fclGetKernelArgInfoInt32 end interface fclGetKernelArgInfo interface module subroutine fclGetEventInfo ( event , key , value ) !! Query kernel information for 32bit integer. !! See [clGetPlatformInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetKernelArgInfo.html) !!  for values of 'key' argument containined in clfortran module. type ( fclEvent ), intent ( in ) :: event integer ( c_int32_t ), intent ( in ) :: key integer ( c_int32_t ), intent ( out ), target :: value end subroutine fclGetEventInfo end interface interface module function fclGetPlatforms () result ( platforms ) !! Return pointer to array of available fclPlatforms type ( fclPlatform ), allocatable :: platforms (:) end function fclGetPlatforms module function fclGetPlatform ( platform_id ) result ( platform ) !! Return fclPlatform object for OpenCL platform id integer ( c_intptr_t ), intent ( in ) :: platform_id !! OpenCL platform id type ( fclPlatform ), target :: platform end function fclGetPlatform module function fclGetPlatformDevices ( platform_id ) result ( devices ) !! Return pointer to array of fclDevices on platform id integer ( c_intptr_t ), intent ( in ) :: platform_id !! OpenCL platform id type ( fclDevice ), allocatable :: devices (:) end function fclGetPlatformDevices module function fclGetDevice ( device_id ) result ( device ) !! Return fclDevice for OpenCL device id integer ( c_intptr_t ), intent ( in ) :: device_id !! OpenCL device id type ( fclDevice ), target :: device end function fclGetDevice end interface ! ---------------------------- SETUP ROUTINES ------------------------------- interface fclCreateContext !! Generic interface to create a context module function fclCreateContextWithPlatform ( platform ) result ( ctx ) !! Create a context with fclPlatform object type ( fclPlatform ), intent ( inout ), target :: platform type ( fclContext ), target :: ctx end function fclCreateContextWithPlatform module function fclCreateContextWithVendor ( vendor ) result ( ctx ) !! Create a context with the first platform where the vendor property !!  contains a specified string (case-insensitive). character ( * ), intent ( in ) :: vendor !! String with which to match platform vendor. Separate multiple vendors !!  with commas. First matching vendor in list is used. !!  Matching is case-insensitive substring. !! !!  *e.g.* `vendor='i'` matches 'nvidia' and 'intel' platforms !! !!  *e.g.* `vendor='nvidia,intel'` matches nvidia platform if available, !!  then intel platform if available, then fails fatally if neither !!  are available. !! type ( fclContext ), target :: ctx end function fclCreateContextWithVendor end interface fclCreateContext interface module subroutine fclSetDefaultContext ( ctx ) !! Set the global default context type ( fclContext ), intent ( in ) :: ctx end subroutine fclSetDefaultContext module function fclFilterDevices ( devices , vendor , type , nameLike , extensions , sortBy ) result ( deviceList ) !! Filter and sort list of devices based on criteria type ( fclDevice ), intent ( in ) :: devices (:) character ( * ), intent ( in ), optional :: vendor !! Filter device list based on platform vendor. !!  Specify multiple possible vendors in comma-separate list character ( * ), intent ( in ), optional :: type !! Filter device list based on device type. !! Specify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character ( * ), intent ( in ), optional :: nameLike !! Filter devices based on device name. Look for this substring in device name. character ( * ), intent ( in ), optional :: extensions !! Filter devices based on supported device extensions. !! Specify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetDeviceInfo.html) !! Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character ( * ), intent ( in ), optional :: sortBy !! Sort device list based on either 'memory': total global memory, !!  'cores': total number of compute units, 'clock': maximum clock speed type ( fclDevice ), allocatable :: deviceList (:) !! Filtered and sorted list. Unallocated if no matching devices found. end function fclFilterDevices module function fclInit ( vendor , type , nameLike , extensions , sortBy ) result ( device ) !! Quick setup helper function: find a single device based on criteria !!  and set the default context accordingly. !!  Raises runtime error if no matching device is found. character ( * ), intent ( in ), optional :: vendor !! Filter device based on platform vendor !!  Specify multiple possible vendors in comma-separate list character ( * ), intent ( in ), optional :: type !! Filter device list based on device type. !! Specify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character ( * ), intent ( in ), optional :: nameLike !! Filter devices based on device name. Look for this substring in device name. character ( * ), intent ( in ), optional :: extensions !! Filter devices based on supported device extensions. !! Specify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetDeviceInfo.html) !! Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character ( * ), intent ( in ), optional :: sortBy !! Sort device list based on either 'memory': total global memory, !!  'cores': total number of compute units, 'clock': maximum clock speed type ( fclDevice ), allocatable :: device !! The device chosen based on the user criteria end function fclInit end interface interface fclFindDevices !! Generic interface to list devices, sorted and filtered by properties !!  Raises runtime error if no matching device is found. module function fclFindDevices_1 ( ctx , vendor , type , nameLike , extensions , sortBy ) result ( deviceList ) type ( fclContext ), intent ( in ), target :: ctx !! Context containing device for command queue character ( * ), intent ( in ), optional :: vendor !! Filter device list based on platform vendor. !!  Specify multiple possible vendors in comma-separate list character ( * ), intent ( in ), optional :: type !! Filter device list based on device type. !! Specify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character ( * ), intent ( in ), optional :: nameLike !! Filter devices based on device name. Look for this substring in device name. character ( * ), intent ( in ), optional :: extensions !! Filter devices based on supported device extensions. !! Specify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetDeviceInfo.html) !! Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character ( * ), intent ( in ), optional :: sortBy !! Sort device list based on either 'memory': total global memory, !!  'cores': total number of compute units, 'clock': maximum clock speed type ( fclDevice ), allocatable :: deviceList (:) end function fclFindDevices_1 module function fclFindDevices_2 ( vendor , type , nameLike , extensions , sortBy ) result ( deviceList ) character ( * ), intent ( in ), optional :: vendor !! Filter device list based on platform vendor. !!  Specify multiple possible vendors in comma-separate list character ( * ), intent ( in ), optional :: type !! Filter device list based on device type. !! Specify at least one of 'cpu', 'gpu', default: 'cpu,gpu' (both) character ( * ), intent ( in ), optional :: nameLike !! Filter devices based on device name. Look for this substring in device name. character ( * ), intent ( in ), optional :: extensions !! Filter devices based on supported device extensions. !! Specify comma-separated list of OpenCL extension names, e.g. cl_khr_fp64. !! See [clGetDeviceInfo](https://www.khronos.org/registry/OpenCL/sdk/1.2/docs/man/xhtml/clGetDeviceInfo.html) !! Extensions specified are requirements: devices are filtered-out if they don't support all extensions specified. character ( * ), intent ( in ), optional :: sortBy !! Sort device list based on either 'memory': total global memory, !!  'cores': total number of compute units, 'clock': maximum clock speed type ( fclDevice ), allocatable :: deviceList (:) end function fclFindDevices_2 end interface fclFindDevices interface fclCreateCommandQ !! Generic interface to create a device command queue module function fclCreateCommandQ_1 ( ctx , device , enableProfiling , outOfOrderExec ,& blockingWrite , blockingRead ) result ( cmdq ) !! Create a command queue with a Focal device object type ( fclContext ), intent ( in ), target :: ctx !! Context containing device for command queue type ( fclDevice ), intent ( inout ), target :: device !! Device on which to create command queue logical , intent ( in ), optional :: enableProfiling !! Enable OpenCL profiling logical , intent ( in ), optional :: outOfOrderExec !! Enable out of order execution logical , intent ( in ), optional :: blockingWrite !! Enable/disable host-blocking write to device logical , intent ( in ), optional :: blockingRead !! Enable/disable host-blocking read from device type ( fclCommandQ ) :: cmdq !! Returns fclCommandQ object end function fclCreateCommandQ_1 module function fclCreateCommandQ_2 ( device , enableProfiling , outOfOrderExec ,& blockingWrite , blockingRead ) result ( cmdq ) !! Create a command queue with a Focal device object using default context type ( fclDevice ), intent ( inout ), target :: device !! Device on which to create command queue logical , intent ( in ), optional :: enableProfiling !! Enable OpenCL profiling logical , intent ( in ), optional :: outOfOrderExec !! Enable out of order execution logical , intent ( in ), optional :: blockingWrite !! Enable/disable host-blocking write to device logical , intent ( in ), optional :: blockingRead !! Enable/disable host-blocking read from device type ( fclCommandQ ) :: cmdq !! Returns fclCommandQ object end function fclCreateCommandQ_2 end interface fclCreateCommandQ interface fclCreateCommandQPool !! Generic interface to create a pool of command queues module function fclCreateCommandQPool_1 ( ctx , N , device , enableProfiling , outOfOrderExec ,& blockingWrite , blockingRead ) result ( qPool ) !! Create a command queue pool with a Focal device object type ( fclContext ), intent ( in ), target :: ctx !! Context containing device for command queue integer , intent ( in ) :: N !! Number of command queues to create in pool type ( fclDevice ), intent ( inout ), target :: device !! Device on which to create command queue logical , intent ( in ), optional :: enableProfiling !! Enable OpenCL profiling logical , intent ( in ), optional :: outOfOrderExec !! Enable out of order execution logical , intent ( in ), optional :: blockingWrite !! Enable/disable host-blocking write to device logical , intent ( in ), optional :: blockingRead !! Enable/disable host-blocking read from device type ( fclCommandQPool ) :: qPool !! Returns fclCommandQPool object end function fclCreateCommandQPool_1 module function fclCreateCommandQPool_2 ( N , device , enableProfiling , outOfOrderExec ,& blockingWrite , blockingRead ) result ( qPool ) !! Create a command queue pool with a Focal device object using default context integer , intent ( in ) :: N !! Number of command queues to create in pool type ( fclDevice ), intent ( inout ), target :: device !! Device on which to create command queue logical , intent ( in ), optional :: enableProfiling !! Enable OpenCL profiling logical , intent ( in ), optional :: outOfOrderExec !! Enable out of order execution logical , intent ( in ), optional :: blockingWrite !! Enable/disable host-blocking write to device logical , intent ( in ), optional :: blockingRead !! Enable/disable host-blocking read from device type ( fclCommandQPool ) :: qPool !! Returns fclCommandQPool object end function fclCreateCommandQPool_2 end interface fclCreateCommandQPool interface module function fclCommandQPool_Next ( qPool ) result ( cmdQ ) !! Returns next scheduled queue in queue pool class ( fclCommandQPool ), intent ( inout ), target :: qPool type ( fclCommandQ ), pointer :: cmdQ end function fclCommandQPool_Next module function fclCommandQPool_Current ( qPool ) result ( cmdQ ) !! Returns current scheduled queue in queue pool class ( fclCommandQPool ), intent ( in ), target :: qPool type ( fclCommandQ ), pointer :: cmdQ end function fclCommandQPool_Current end interface interface module subroutine fclSetDefaultCommandQ ( cmdq ) !! Set the global default command queue type ( fclCommandQ ), intent ( in ) :: cmdq end subroutine fclSetDefaultCommandQ end interface interface fclCompileProgram !! Generic interface to compile an openCL program module function fclCompileProgram_1 ( ctx , source , options ) result ( prog ) !! Compile program source on context ctx type ( fclContext ), intent ( in ), target :: ctx character ( * ), intent ( in ) :: source !! Program source code character ( * ), intent ( in ), optional :: options !! OpenCL compilation options type ( fclProgram ) :: prog !! Returns fclProgram object end function fclCompileProgram_1 module function fclCompileProgram_2 ( source , options ) result ( prog ) !! Compile program source on fclDefaultContext character ( * ), intent ( in ) :: source !! Program source code character ( * ), intent ( in ), optional :: options !! OpenCL compilation options type ( fclProgram ) :: prog !! Returns fclProgram object end function fclCompileProgram_2 end interface fclCompileProgram interface fclDumpBuildLog module subroutine fclDumpBuildLog_1 ( ctx , prog , device , outputUnit ) type ( fclContext ), intent ( in ) :: ctx type ( fclProgram ), intent ( in ) :: prog type ( fclDevice ), intent ( in ) :: device integer , intent ( in ), optional :: outputUnit end subroutine fclDumpBuildLog_1 module subroutine fclDumpBuildLog_2 ( prog , device , outputUnit ) type ( fclProgram ), intent ( in ) :: prog type ( fclDevice ), intent ( in ) :: device integer , intent ( in ), optional :: outputUnit end subroutine fclDumpBuildLog_2 end interface fclDumpBuildLog interface module function fclGetProgramKernel ( prog , kernelName , global_work_size , local_work_size , & work_dim , global_work_offset ) result ( kern ) !! Extract a kernel object for execution from a compiled program object type ( fclProgram ), intent ( in ) :: prog !! Compiled program object containing kernel character ( * ), intent ( in ) :: kernelName !! Name of kernel to extract for execution integer , intent ( in ), optional :: global_work_size (:) !! Global work group dimensions, default unset (must set prior to launching) integer , intent ( in ), optional :: local_work_size (:) !! Local work group dimensions, default zeros (decided by OpenCL runtime) integer , intent ( in ), optional :: work_dim !! Number of dimensions for kernel work group, default 1 integer , intent ( in ), optional :: global_work_offset (:) !! Global work group offsets, default zeros type ( fclKernel ) :: kern !! Returns fclKernel object for execution end function fclGetProgramKernel end interface interface fclLaunchKernelAfter !! Generic interface to launch a kernel with event dependencies module subroutine fclLaunchKernelAfterEvent_1 ( kernel , cmdQ , event ) !! Specific interface for a single event dependency on a specific command queue class ( fclKernel ), intent ( inout ) :: kernel !! Focal kernel object to launch type ( fclCommandQ ), intent ( inout ) :: cmdQ !! CmdQ on which to launch kernel type ( fclEvent ), intent ( in ) :: event !! Event dependency for kernel end subroutine fclLaunchKernelAfterEvent_1 module subroutine fclLaunchKernelAfterEvent_2 ( kernel , event ) !! Specific interface a single event dependency on the __default command queue__ class ( fclKernel ), intent ( inout ) :: kernel !! Focal kernel object to launch type ( fclEvent ), intent ( in ) :: event !! Event dependency for kernel end subroutine fclLaunchKernelAfterEvent_2 module subroutine fclLaunchKernelAfterEventList_1 ( kernel , cmdQ , eventList ) !! Specific interface for a multiple event dependencies on a specific command queue class ( fclKernel ), intent ( inout ) :: kernel !! Focal kernel object to launch type ( fclCommandQ ), intent ( inout ) :: cmdQ !! CmdQ on which to launch kernel type ( fclEvent ), intent ( in ) :: eventList (:) !! Event dependency list for kernel end subroutine fclLaunchKernelAfterEventList_1 module subroutine fclLaunchKernelAfterEventList_2 ( kernel , eventList ) !! Specific interface for a multiple event dependencies on the __default command queue__ class ( fclKernel ), intent ( inout ) :: kernel !! Focal kernel object to launch type ( fclEvent ), intent ( in ) :: eventList (:) !! Event dependency list for kernel end subroutine fclLaunchKernelAfterEventList_2 end interface fclLaunchKernelAfter interface module subroutine fclLaunchKernel ( kernel , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 ) !! Enqueue a kernel with command arguments class ( fclKernel ), intent ( inout ), target :: kernel !! Focal kernel object class ( * ), intent ( in ), optional , target :: a0 !! Focal command queue or first kernel argument class ( * ), intent ( in ), optional , target :: a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 !! Subsequent kernel arguments. !! Can be a scalar, an fclDeviceBuffer object, or an fclLocalArgument end subroutine fclLaunchKernel module subroutine fclProcessKernelArgs ( kernel , cmdq , narg , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 ) !! Sets kernel arguments and parses argument list for optional cmdq and actual number of arguments. !! @note This is helper routine used internally by focal.  If you just want set kernel arguments !!  without launching a kernel, use `fclSetKernelArgs`. @endnote class ( fclKernel ), intent ( in ), target :: kernel !! Focal kernel object type ( fclCommandQ ), intent ( out ), pointer :: cmdq !! Returns a0 if it is cmdq, otherwise returns fclDefaultCommandQ integer , intent ( out ) :: narg !! Returns the actual number of arguments passed class ( * ), intent ( in ), optional , target :: a0 !! Focal command queue or first kernel argument class ( * ), intent ( in ), optional , target :: a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 !! Subsequent kernel arguments. !! Can be a scalar, an fclDeviceBuffer object, or an fclLocalArgument end subroutine fclProcessKernelArgs module subroutine fclSetKernelArgs ( kernel , a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 ) !! Set all kernel arguments at once without launching kernel. class ( fclKernel ), intent ( in ), target :: kernel !! Focal kernel object class ( * ), intent ( in ), optional , target :: a0 , a1 , a2 , a3 , a4 , a5 , a6 , a7 , a8 , a9 , & a10 , a11 , a12 , a13 , a14 , a15 , a16 , a17 , a18 , a19 , & a20 , a21 , a22 , a23 , a24 , a25 , a26 , a27 , a28 , a29 , & a30 , a31 , a32 , a33 , a34 , a35 , a36 , a37 , a38 , a39 , & a40 , a41 , a42 , a43 , a44 , a45 , a46 , a47 , a48 , a49 , & a50 , a51 , a52 , a53 , a54 , a55 , a56 , a57 , a58 , a59 , & a60 , a61 , a62 , a63 , a64 , a65 , a66 , a67 , a68 , a69 , & a70 , a71 , a72 , a73 , a74 , a75 , a76 , a77 , a78 , a79 , & a80 , a81 , a82 , a83 , a84 , a85 , a86 , a87 , a88 , a89 , & a90 , a91 , a92 , a93 , a94 , a95 , a96 , a97 , a98 , a99 !! Kernel arguments. !! Can be a scalar, an fclDeviceBuffer object, or an fclLocalArgument end subroutine fclSetKernelArgs module subroutine fclSetKernelArg ( kernel , argIndex , argValue ) !! Set or change a single kernel argument type ( fclKernel ), intent ( in ) :: kernel !! Focal kernel object integer ( c_int32_t ), intent ( in ) :: argIndex !! Index of kernel argument to set class ( * ), intent ( in ), target :: argValue !! Value of kernel argument. !! Can be a scalar, an fclDeviceBuffer object, or an fclLocalArgument end subroutine fclSetKernelArg module function fclLocalInt32 ( nElem ) result ( localArg ) !! Create a integer local kernel argument object for launching kernels integer , intent ( in ) :: nElem !! No of array elements type ( fclLocalArgInt32 ) :: localArg !! Returns local argument object end function fclLocalInt32 module function fclLocalFloat ( nElem ) result ( localArg ) !! Create a float local kernel argument object for launching kernels integer , intent ( in ) :: nElem !! No of array elements type ( fclLocalArgFloat ) :: localArg !! Returns local argument object end function fclLocalFloat module function fclLocalDouble ( nElem ) result ( localArg ) !! Create a double local kernel argument object for launching kernels integer , intent ( in ) :: nElem !! No of array elements type ( fclLocalArgDouble ) :: localArg !! Returns local argument object end function fclLocalDouble module subroutine fclReleaseKernel ( kernel ) !! Release OpenCL memory associated with underlying kernel pointer type ( fclKernel ), intent ( inout ) :: kernel !! Focal kernel object end subroutine fclReleaseKernel end interface interface fclBarrier !! Generic interface to enqueue a command queue barrier !!  Wait on device for all preceding queue events to complete before !!  subsequent events can proceed. module subroutine fclBarrier_1 ( cmdq ) !! Enqueue barrier on all events in command queue type ( fclCommandQ ), intent ( inout ), target :: cmdq end subroutine fclBarrier_1 module subroutine fclBarrier_2 () !! Enqueue barrier on all events in default command queue end subroutine fclBarrier_2 end interface fclBarrier interface fclWait !! Generic interface to wait on host for events module subroutine fclFinish_1 ( cmdq ) !! Wait on host for all events in user-specified command queue type ( fclCommandQ ), intent ( in ) :: cmdq end subroutine fclFinish_1 module subroutine fclFinish_2 () !! Wait on host for all events in focal default command queue end subroutine fclFinish_2 module subroutine fclFinish_3 ( qPool ) !! Wait on host for all events in all queues in a queue pool type ( fclCommandQPool ), intent ( in ) :: qPool end subroutine fclFinish_3 module subroutine fclWaitEvent ( event ) !! Wait on host for a specific event type ( fclEvent ), intent ( in ), target :: event end subroutine fclWaitEvent module subroutine fclWaitEventList ( eventList ) !! Wait on host for set of events type ( fclEvent ), intent ( in ), target :: eventList (:) end subroutine fclWaitEventList end interface fclWait interface assignment ( = ) module subroutine fclEventCopy ( target , source ) !! Overloaded assignment for event assignment. !!  Handles opencl reference counting for the underlying event object type ( fclEvent ), intent ( inout ) :: target type ( fclEvent ), intent ( in ) :: source end subroutine fclEventCopy end interface interface module subroutine fclReleaseEvent ( event ) !! Light weight wrapper for clReleaseEvent (decrement reference count) type ( fclEvent ), intent ( in ) :: event !! Focal event object to release end subroutine fclReleaseEvent module subroutine fclRetainEvent ( event ) !! Light weight wrapper for clRetainEvent (increment reference count) type ( fclEvent ), intent ( in ) :: event !! Focal event object to retain end subroutine fclRetainEvent end interface interface fclSetDependency !! Generic interface to set pre-requisite events for the next enqueued action. !!  This does not append to any existing dependencies - it overwrites the dependency list. module subroutine fclSetDependencyEvent_1 ( cmdQ , event , hold ) !! Interface for specifying a single event dependency on specific cmdq type ( fclCommandQ ), target :: cmdQ !! Command queue type ( fclEvent ), intent ( in ) :: event !! Event dependency logical , intent ( in ), optional :: hold !! Hold dependency list: set to true to not automatically clear dependencies after enqueueing. !!  Use for applying the same dependency to multiple commands. Default false. end subroutine fclSetDependencyEvent_1 module subroutine fclSetDependencyEvent_2 ( event , hold ) !! Interface for specifying a single event dependency on __default cmdq__ type ( fclEvent ), intent ( in ) :: event !! Event dependency logical , intent ( in ), optional :: hold !! Hold dependency list: set to true to not automatically clear dependencies after enqueueing. !!  Use for applying the same dependency to multiple commands. Default false. end subroutine fclSetDependencyEvent_2 module subroutine fclSetDependencyEventList_1 ( cmdq , eventList , hold ) !! Interface for specifying a list of dependent events on specific cmdq type ( fclCommandQ ), target :: cmdQ !! Command queue type ( fclEvent ), intent ( in ) :: eventList (:) !! List of event dependencies logical , intent ( in ), optional :: hold !! Hold dependency list: set to true to not automatically clear dependencies after enqueueing. !!  Use for applying the same dependency to multiple commands. Default false. end subroutine fclSetDependencyEventList_1 module subroutine fclSetDependencyEventList_2 ( eventList , hold ) !! Interface for specifying a list of dependent events on __default cmdq__ type ( fclEvent ), intent ( in ) :: eventList (:) !! List of event dependencies logical , intent ( in ), optional :: hold !! Event dependency !! Hold dependency list: set to true to not automatically clear dependencies after enqueueing. !!  Use for applying the same dependency to multiple commands. Default false. end subroutine fclSetDependencyEventList_2 end interface fclSetDependency interface module subroutine fclPopDependencies ( cmdq ) !! Called after every enqueue operation: !! Clear dependencies unless dependency hold is .true. type ( fclCommandQ ), intent ( inout ) :: cmdq end subroutine fclPopDependencies end interface interface fclClearDependencies !! Generic interface to clear dependency list and reset dependency hold to .false. module subroutine fclClearDependencies_1 ( cmdq ) !! Interface for specific command queue type ( fclCommandQ ), intent ( inout ) :: cmdq end subroutine fclClearDependencies_1 module subroutine fclClearDependencies_2 () !! Interface for default command queueu end subroutine fclClearDependencies_2 end interface fclClearDependencies interface fclCreateUserEvent !! Generic interface to create a user event module function fclCreateUserEvent_1 ( ctx ) result ( userEvent ) !! Create user event in a specific context type ( fclContext ), intent ( in ) :: ctx type ( fclEvent ) :: userEvent end function fclCreateUserEvent_1 module function fclCreateUserEvent_2 () result ( userEvent ) !! Create user event in the default context type ( fclEvent ) :: userEvent end function fclCreateUserEvent_2 end interface fclCreateUserEvent interface module subroutine fclSetUserEvent ( event , stat ) !! Set status of a user event type ( fclEvent ), intent ( inout ) :: event integer ( c_int32_t ), intent ( in ), optional :: stat end subroutine fclSetUserEvent end interface ! ------------------------- PROFILING  ROUTINES ----------------------------- interface module subroutine fclProfilerAdd ( profiler , profileSize , c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 ) !! Enable profiling for multiple container (kernel/buffer) and add to profiler collection class ( fclProfiler ), intent ( inout ) :: profiler !! Profiler - collection of objects to profile integer , intent ( in ) :: profileSize !! Number of events to save for profiling (allocation size) class ( fclProfileContainer ), intent ( inout ), target :: c0 !! Object (kernel/buffer) for which to enable profiling class ( fclProfileContainer ), intent ( inout ), target , optional :: c1 , c2 , c3 , c4 , c5 , c6 , c7 , c8 , c9 !! Subsequent objects (kernel/buffer) for which to enable profiling end subroutine fclProfilerAdd module subroutine fclEnableProfiling ( container , profileSize , profiler ) !! Enable profiling on a specific container by allocating space to save events class ( fclProfileContainer ), intent ( inout ), target :: container !! Container on which to enable profiling. This can be one of: !! `fclKernel`,`fclDeviceBuffer`,`fclProfileContainer`. integer , intent ( in ) :: profileSize !! Number of events to allocate space for type ( fclProfiler ), intent ( inout ), optional :: profiler !! Profiler collection object to which to add the kernel/buffer. end subroutine fclEnableProfiling module subroutine fclPushProfileEvent ( container , event , type ) !! If profiling is enabled for the container, save an event to it class ( fclProfileContainer ), intent ( in ) :: container !! Profiling container (`fclKernel`,`fclDeviceBuffer`,`fclProfileContainer`) type ( fclEvent ), intent ( in ) :: event !! Event to push to container integer , intent ( in ), optional :: type !! For buffer object events only, indicates transfer type end subroutine fclPushProfileEvent module function fclGetEventDurations ( eventList ) result ( durations ) type ( fclEvent ), intent ( in ) :: eventList (:) integer ( c_int64_t ) :: durations ( size ( eventList , 1 )) end function fclGetEventDurations module subroutine fclDumpProfileData ( profiler , outputUnit ) !! Dump summary of profiler data for list of kernels to specific output unit class ( fclProfiler ), intent ( in ) :: profiler !! Profiler object containing collection of kernels & buffers to profile integer , intent ( in ), optional :: outputUnit !! Output unit to write summary data end subroutine fclDumpProfileData module subroutine fclDumpKernelProfileData ( outputUnit , kernelList , device ) !! Dump summary of profile data for list of kernels to specific output unit integer , intent ( in ) :: outputUnit !! Output unit to write summary data class ( fclKernel ), intent ( in ) :: kernelList (:) !! List of kernels for which to dump profile data type ( fclDevice ), intent ( in ) :: device !! Device on which the kernels were executed !! Needed for kernel work group info. end subroutine fclDumpKernelProfileData module subroutine fclDumpBufferProfileData ( outputUnit , bufferList1 , bufferList2 , bufferList3 ) !! Dump summary of profile data for list of buffers to specific output unit. !! !! Three buffer list inputs are provided for different buffer types integer , intent ( in ) :: outputUnit !! Output unit to write summary data. class ( fclDeviceBuffer ), intent ( in ), target :: bufferList1 (:) !! List of buffers for which to dump profile data class ( fclDeviceBuffer ), intent ( in ), optional , target :: bufferList2 (:) !! List of buffers for which to dump profile data class ( fclDeviceBuffer ), intent ( in ), optional , target :: bufferList3 (:) !! List of buffers for which to dump profile data end subroutine fclDumpBufferProfileData module subroutine fclDumpTracingData ( profiler , filename ) !! Writes a chrome://tracing data format for profiled events class ( fclProfiler ), intent ( in ) :: profiler !! Profiler collection object containing kernels/buffers that have been profiled character ( * ), intent ( in ) :: filename !! Filename to which to write chrome://tracing format end subroutine fclDumpTracingData end interface ! ---------------------------- DEBUG ROUTINES ------------------------------- interface module subroutine fclDbgCheckContext ( descrip , ctx ) !! Check the (default) context is initialised. !! Assumes uninitialised contexts have cl_context = -1. !! @note Debug routine: only executed for debug build. @endnote character ( * ), intent ( in ) :: descrip !! Description of program location for error output type ( fclContext ), intent ( in ), optional :: ctx !! Context to test. Uses fclDefaultContext if not present. end subroutine fclDbgCheckContext module subroutine fclDbgCheckDevice ( device , descrip ) !! Check a device object is valid !! Assumes uninitialised devices have cl_device_id = -1. !! @note Debug routine: only executed for debug build. @endnote type ( fclDevice ), intent ( in ) :: device !! Device object to check character ( * ), intent ( in ) :: descrip !! Description of program location for error output end subroutine fclDbgCheckDevice module subroutine fclDbgCheckBufferInit ( memObject , descrip ) !! Check that a device buffer object has been initialised. !! @note Debug routine: only executed for debug build. @endnote class ( fclDeviceBuffer ), intent ( in ) :: memObject character ( * ), intent ( in ) :: descrip end subroutine fclDbgCheckBufferInit module subroutine fclDbgCheckBufferSize ( memObject , hostBytes , descrip ) !! Check that a host buffer matches the size in bytes of a device buffer. !! @note Debug routine: only executed for debug build. @endnote class ( fclDeviceBuffer ), intent ( in ) :: memObject integer ( c_size_t ), intent ( in ) :: hostBytes character ( * ), intent ( in ) :: descrip end subroutine fclDbgCheckBufferSize module subroutine fclDbgCheckCopyBufferSize ( memObject1 , memObject2 ) !! Check that a host buffer matches the size in bytes of a device buffer. !! @note Debug routine: only executed for debug build. @endnote class ( fclDeviceBuffer ), intent ( in ) :: memObject1 ! Destination buffer class ( fclDeviceBuffer ), intent ( in ) :: memObject2 ! Source buffer end subroutine fclDbgCheckCopyBufferSize module subroutine fclDbgCheckKernelNArg ( kernel , nArg ) !! Check that number of actual args matches number of kernel args. !! @note Debug routine: only executed for debug build. @endnote type ( fclKernel ), intent ( in ) :: kernel integer , intent ( in ) :: nArg end subroutine fclDbgCheckKernelNArg module subroutine fclDbgCheckKernelArgType ( kernel , argNo , type ) !! Checks the types of arguments passed to kernels !! @note Debug routine: only executed for debug build. @endnote type ( fclKernel ), intent ( in ) :: kernel integer , intent ( in ) :: argNo character ( * ), intent ( in ) :: type end subroutine fclDbgCheckKernelArgType module subroutine fclDbgCheckKernelArgQualifier ( kernel , argNo , qualifier ) !! Checks the address qualifier of arguments passed to kernels. !! @note Debug routine: only executed for debug build. @endnote type ( fclKernel ), intent ( in ) :: kernel integer , intent ( in ) :: argNo character ( * ), intent ( in ) :: qualifier end subroutine fclDbgCheckKernelArgQualifier module function fclDbgOptions () result ( options ) !(userOptions,options) !! Returns OpenCL compile options as interoperable string for debug mode !! @note Debug routine: only executed for debug build. @endnote ! character(*), intent(in) :: userOptions character (:), allocatable :: options end function fclDbgOptions module subroutine fclDbgWait ( event , descrip ) !! Wait for an event to complete and check for successful completion. !! Throw runtime error if status is not CL_COMPLETE. !! @note Debug routine: only executed for debug build. @endnote type ( fclEvent ), intent ( in ), target :: event !! Event object to check character ( * ), intent ( in ), optional :: descrip !! Description for debugging end subroutine fclDbgWait end interface ! ---------------------------- UTILITY ROUTINES ------------------------------- interface module subroutine fclGetKernelResource ( kernelString ) !! Retrieve kernel source linked as a binary resource. !!  Use linker ld to include kernel source with: !!   ld -r -b binary -o fclKernels.o fclKernels.cl !! (Object file MUST be called fclKernels.o, with no path) !! Then link resulting object file as normal character (:), allocatable , intent ( out ) :: kernelString !! Kernel source as fortran character string end subroutine fclGetKernelResource module subroutine fclSourceFromFile ( filename , sourceString ) !! Allocate and fill character string from file character ( * ), intent ( in ) :: filename character (:), intent ( out ), allocatable :: sourceString end subroutine fclSourceFromFile end interface interface module function strStripNum ( linei ) !! Return copy of string with numerical characters removed character ( len =* ), intent ( in ) :: linei !! Input string character ( len = len ( linei )) strStripNum !! Converted string output end function strStripNum end interface end module Focal","tags":"","loc":"sourcefile/focal.f90.html"}]}